<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试1</title>
    <link href="undefined2019/11/17/%E9%9D%A2%E8%AF%951/"/>
    <url>2019/11/17/%E9%9D%A2%E8%AF%951/</url>
    
    <content type="html"><![CDATA[<h1 id="第一次面试"><a href="#第一次面试" class="headerlink" title="第一次面试"></a>第一次面试</h1><p>2019年11月12日，下午2:15正式迎来了自己的<strong>第一次面试</strong>，这次面试与我想象中的面试完全不一样呢。</p><p>想象中的面试是我与面试官谈笑风声，现实中的我与面试官<strong>尴尬谈笑</strong>，因为面试官根本不笑。我的面试官是一个典型的码农，穿着格子衫，我进去之后，他还在敲代码，随后，过了一会他从打印机拿了两张A4纸过来，一张写着面试问题，一张空白用来写答案，给完我就让我自己拿笔做，然后，他就又回去敲代码了。。。</p><p>下面是面试问题：</p><blockquote><p>1.JAVA数据类型以及所占字节</p><p>2.手写三个单例模式</p><p>3.ArrayList与LinkList区别</p><p>4.HashSet原理</p><p>5.常用的Linux命令</p><p>6.JAVA反射机制</p><p>7.手画一个线程状态图</p><p>8.手写三个线程交替打印ABC</p><p>9.什么是TCP三次握手，为什么四次挥手断开连接，为什么</p><p>10.手写一个冒泡算法</p><p>11.SpringMVC是怎么运行的？</p><p>12.索引类型及作用</p></blockquote><p>由于我太菜了，很多都没答出来，甚至连第一个题都能写错，真是服了我自己了，不过这是第一次面试可以给自己长长教训。</p><p>下面面试答案：</p><h3 id="1-JAVA数据类型及所占字节"><a href="#1-JAVA数据类型及所占字节" class="headerlink" title="1.JAVA数据类型及所占字节"></a>1.JAVA数据类型及所占字节</h3><pre><code class="java">整型:  byte--1字节    short--2字节    int--4字节    long--8字节浮点型:  float--4字节    double--8字节字符型:  char--2字节布尔型:  boolean--1字节</code></pre><h3 id="2-单例模式的三种实现"><a href="#2-单例模式的三种实现" class="headerlink" title="2.单例模式的三种实现"></a>2.单例模式的三种实现</h3><pre><code class="JAVA">//1.懒汉式,默认不实例化，什么时候用什么时候创建对象public class Singleton{    private static Singleton instance;    private Singleton(){}    public static synchronized Singleton getInstance(){        if(instance == null){            instance = new Singleton();        }        return instance;    }}//2.饿汉式，类加载的时候就实例化public class Singleton{    private Singleton(){}    private static final Singleton singleton = new Singleton();    public static Singleton getInstance(){        return singleton;    }}//3.静态内部类public class Singleton{    private Singleton(){}    public static final Singleton getInstance(){        return SingletonHolder.INSTANCE;    }    private static class SingletonHolder{        private static final Singleton INSTANCE = new Singleton();    }}</code></pre><h3 id="3-ArrayList和LinkList的区别"><a href="#3-ArrayList和LinkList的区别" class="headerlink" title="3.ArrayList和LinkList的区别"></a>3.ArrayList和LinkList的区别</h3><pre><code class="JAVA">ArrayList是基于数组实现的，查询快，更新慢。LinkList是基于链表实现的，插入，删除快，查询慢</code></pre><h3 id="4-HashSet原理"><a href="#4-HashSet原理" class="headerlink" title="4.HashSet原理"></a>4.HashSet原理</h3><pre><code class="JAVA">HashSet实现Set接口，由一个HashMap实例支持。不保证set的迭代顺序;不保证舒徐恒久不变。此类允许使用null</code></pre><h3 id="5-常用的Linux命令"><a href="#5-常用的Linux命令" class="headerlink" title="5.常用的Linux命令"></a>5.常用的Linux命令</h3><pre><code class="bash">ll ls cd pwd mkdir touch rm -rf grep less</code></pre><h3 id="6-JAVA反射机制"><a href="#6-JAVA反射机制" class="headerlink" title="6.JAVA反射机制"></a>6.JAVA反射机制</h3><pre><code class="java">java反射机制是指在运行时，对任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取对象信息及动态调用方法的功能称为JAVA反射机制。通过Class.forName(包名.类名)获得类对象Class，通过操作Class对象达到运行时操作类</code></pre><h3 id="7-手画一个线程状态图"><a href="#7-手画一个线程状态图" class="headerlink" title="7.手画一个线程状态图"></a>7.手画一个线程状态图</h3><pre><code class="java">线程有五个状态：新建态(new)、就绪态(runnable)、运行态(running)、阻塞态(blocked)、死亡态(dead)</code></pre><p><img src="https://images2017.cnblogs.com/blog/432513/201712/432513-20171214160438717-1661848063.png" srcset="/img/loading.gif" alt=""></p><h2 id="8-手写三个线程交替打印ABC"><a href="#8-手写三个线程交替打印ABC" class="headerlink" title="8.手写三个线程交替打印ABC"></a>8.手写三个线程交替打印ABC</h2><pre><code class="java">/*** 主要考察的使是线程间的同步唤醒操作，线程的逻辑执行步骤为ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA.......* 要控制线程的执行顺序,就要确定唤醒和等待的顺序,一种解题思路是一个线程持有两个对象锁.一个对象锁是pret即前* * 一个对象所持有的锁,还有一个是自身锁.*/public class SysaAbcThread implements Runnable{    private Object pret;     //上一个锁    private Object self;     //自身锁    private String sout;     //要输出的内容    public SysaAbcThread(Object pret, Object self, String sout) {        super();        this.pret = pret;        this.self = self;        this.sout = sout;    }    @Override    public void run() {        while(true){            synchronized (pret) {     //获取 pret锁                synchronized (self) { //获取 self锁                    System.out.println(sout);                    self.notifyAll();  //释放self锁，唤醒其他线程竞争self锁                }                try {                    pret.wait();      //释放pret锁，休眠等待唤醒                } catch (InterruptedException e) {}            }        }    }    public static void main(String[] args) throws InterruptedException {        Object a = new Object();        Object b = new Object();        Object c = new Object();        SysaAbcThread aThread = new SysaAbcThread(c, a, &quot;A&quot;);        SysaAbcThread bThread = new SysaAbcThread(a, b, &quot;B&quot;);        SysaAbcThread cThread = new SysaAbcThread(b, c, &quot;C&quot;);        /**         * 如果不sleep，则启动顺序会乱         */        new Thread(aThread).start();        Thread.sleep(100);        new Thread(bThread).start();        Thread.sleep(100);        new Thread(cThread).start();        Thread.sleep(100);    }}</code></pre><h2 id="9-什么是TCP三次握手，为什么四次挥手断开连接"><a href="#9-什么是TCP三次握手，为什么四次挥手断开连接" class="headerlink" title="9.什么是TCP三次握手，为什么四次挥手断开连接"></a>9.什么是TCP三次握手，为什么四次挥手断开连接</h2><p><strong>三此握手(Three-way Handshake)是指建立一个TCP连接时</strong>，需要客户端和服务端总共发送三个包。</p><p>三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><ul><li><p>第一次握手(SYN=1,seq=x):   <strong>客户端=&gt;服务端</strong></p><p>客户端发送一个TCP的SYN标志位置1得1包，指明客户端打算连接的服务器的端口，以及初始序号X，保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕客户端进入<strong>SYN_SEND</strong>状态。</p></li></ul><ul><li><p>第二次握手(SYN=1,ACK=1,seq=y,ACKnum=x+1):  <strong>服务端=&gt;客户端</strong></p><p>服务器发回确认包(ACK)应答。即SYN标志和ACK标志位均为1。服务器端选择自己的ISN序列号，放到Seq域里，同时将确认序号(Acknowledgement Number)设置为客户的ISN加1，即X+1。发送完毕后，服务器端进入<strong>SYN_RCVD</strong>状态。</p></li></ul><ul><li><p>第三次握手(ACK=1,ACKnum=y+1)：<strong>客户端=&gt;服务端</strong></p><p>客户端再次发回确认包(ACK)，SYN标志位为0，ACK标志为1，并把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写INS的+1</p><p>发送完毕后，客户端进入<strong>ESTABLISHED</strong>状态，当服务器端接收到这个包时，也进入<strong>ESTABLISHED</strong>状态，TCP握手结束。</p></li></ul><p><strong>四次挥手(Four-Way Wavehand)是指断开一个TCP连接时</strong>，需要客户端和服务端发送四个包确认连接断开。客户端或服务端均可主动发起挥手动作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<strong>FIN_WAIT_1</strong>状态</p></li></ul><ul><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端发送的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<strong>CLOSE_WAIT</strong>状态，客户端接收到这个确认包之后，进入<strong>FIN_WAIT_2</strong>状态，等待服务器关闭连接。</p></li></ul><ul><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN设置为1.</p><p>发送完毕后，服务端进入<strong>LAST_ACK</strong>状态，等待来自客户端的最后一个ACK。</p></li></ul><ul><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收来自服务器端的关闭请求，发送一个确认包，并进入<strong>TIME_WAIT</strong>状态，等待可能出现的要求重传的ACK包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入<strong>CLOSED</strong>状态。</p><p>客户端等待了某个固定时间（两个最大生命周期，2MSL，2 Maximum Segment Lifetime）之后，没收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<strong>CLOSED</strong>状态</p></li></ul><h2 id="10-手写一个冒泡算法"><a href="#10-手写一个冒泡算法" class="headerlink" title="10.手写一个冒泡算法"></a>10.手写一个冒泡算法</h2><pre><code class="java">for     for </code></pre><h2 id="11-SpringMVC是怎么运行的？"><a href="#11-SpringMVC是怎么运行的？" class="headerlink" title="11.SpringMVC是怎么运行的？"></a>11.SpringMVC是怎么运行的？</h2><pre><code class="java"></code></pre><h2 id="12-索引类型及作用"><a href="#12-索引类型及作用" class="headerlink" title="12.索引类型及作用"></a>12.索引类型及作用</h2>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(3)实用指令</title>
    <link href="undefined2019/11/02/3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>2019/11/02/3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h3 id="Linux系统的运行级别"><a href="#Linux系统的运行级别" class="headerlink" title="Linux系统的运行级别"></a>Linux系统的运行级别</h3><pre><code class="bash">0:关机  1:单用户(找回丢失密码)2:多用户无网络服务3:多用户有网络服务4:保留5:图形界面6:重启命令 init [0||num]系统运行级别配置文件： /etc/inittab</code></pre><p><img src="https://i.loli.net/2019/10/09/R9DjLcyuoXtGkFI.png" srcset="/img/loading.gif" alt=""></p><h5 id="如何修改已经忘记密码"><a href="#如何修改已经忘记密码" class="headerlink" title="如何修改已经忘记密码"></a>如何修改已经忘记密码</h5><p><img src="https://i.loli.net/2019/10/09/rcNa2gMqbYtGkLe.png" srcset="/img/loading.gif" alt=""></p><p>首先，在进入启动页面的时候按<strong>e</strong>键，然后会进入下面这个页面</p><p><img src="https://i.loli.net/2019/10/09/g4j2GNFevKImaQn.png" srcset="/img/loading.gif" alt=""></p><p>将光标移动到下图那一行</p><p><img src="https://i.loli.net/2019/10/09/8k4sZdrAvRgEVno.png" srcset="/img/loading.gif" alt=""></p><p>在行尾添加 <strong>init=/bin/sh</strong>,</p><p><img src="https://i.loli.net/2019/10/09/LhdHGqYpItZvMAK.png" srcset="/img/loading.gif" alt=""></p><p>添加完，按<strong>Ctrl + X</strong>执行，即可进入单用户模式</p><p><img src="https://i.loli.net/2019/10/09/JBKHTxbWS5dGYIy.png" srcset="/img/loading.gif" alt=""></p><p>然后，就可以<strong>修改密码</strong>了</p><p><img src="https://i.loli.net/2019/10/09/4wbFxDeHrJGKBm8.png" srcset="/img/loading.gif" alt=""></p><p>这里可以看见会字符不可见，你需要输入<strong>LANG=en</strong>，才能让字符可见</p><p><img src="https://i.loli.net/2019/10/09/trswoihHCvd7JGu.png" srcset="/img/loading.gif" alt=""></p><p>最后,执行<strong>exec /sbin/init</strong>即可退出单用户模式</p><p><img src="https://i.loli.net/2019/10/09/gvKOq5eVhc3FwXd.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当你对某个指令不收悉的时候，就可以使用帮助指令</p><h4 id="获得帮助信息"><a href="#获得帮助信息" class="headerlink" title="获得帮助信息"></a>获得帮助信息</h4><ul><li><p>语法</p><pre><code class="bash">man [命令||配置文件]</code></pre></li><li><p>命令演示</p><pre><code class="bash">[root@localhost ~]# man ls</code></pre><p>输入命令按<strong>回车</strong>,</p><p><img src="https://i.loli.net/2019/10/10/AnB285ODQH9RKLf.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>ls加-a可以<strong>显示隐藏文件</strong></p><p><img src="https://i.loli.net/2019/10/10/mNfp1tGsEaX38D9.png" srcset="/img/loading.gif" alt=""></p><p>ls加-l可以以<strong>另外的列表形式显示</strong></p><p><img src="https://i.loli.net/2019/10/10/eOT45wiHoPu6gys.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">[root@localhost home]# ls -a.  ..  crg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><p>命令选项不光可以单个用，也可以连用，</p><pre><code class="bash">[root@localhost home]# ls -la总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy</code></pre><h4 id="help-命令"><a href="#help-命令" class="headerlink" title="help 命令"></a>help 命令</h4><ul><li><p>基本语法</p><pre><code class="bash">help 命令</code></pre></li><li><p>实例演示</p><pre><code class="bash">[root@localhost home]# help cdcd: cd [-L|[-P [-e]]] [dir]    Change the shell working directory.    Change the current directory to DIR.  The default DIR is the value of the    HOME shell variable.    The variable CDPATH defines the search path for the directory containing    DIR.  Alternative directory names in CDPATH are separated by a colon (:).    A null directory name is the same as the current directory.  If DIR begins    with a slash (/), then CDPATH is not used.    If the directory is not found, and the shell option `cdable_vars&#39; is set,    the word is assumed to be  a variable name.  If that variable has a value,    its value is used for DIR.    Options:        -L      force symbolic links to be followed        -P      use the physical directory structure without following symbolic        links        -e      if the -P option is supplied, and the current working directory        cannot be determined successfully, exit with a non-zero status    The default is to follow symbolic links, as if `-L&#39; were specified.    Exit Status:    Returns 0 if the directory is changed, and if $PWD is set successfully when    -P is used; non-zero otherwise.[root@localhost home]# </code></pre></li></ul><hr><h3 id="查看目录类命令"><a href="#查看目录类命令" class="headerlink" title="查看目录类命令"></a>查看目录类命令</h3><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p><strong>这个命令用来显示当前工作的绝对路径</strong></p><pre><code class="bash">[root@localhost ~]# pwd/root[root@localhost ~]# </code></pre><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p><strong>该命令用来查看当前目录的所有内容</strong></p><pre><code class="bash">ls [选项] [目录||文件]</code></pre><pre><code class="bash">[root@localhost home]# lscrg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# ls -al总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p><strong>用于切换目录</strong></p><pre><code class="bash">cd [参数](指定目录)</code></pre><pre><code class="bash">[root@localhost /]# ll总用量 16lrwxrwxrwx.   1 root root    7 9月   4 20:33 bin -&gt; usr/bindr-xr-xr-x.   5 root root 4096 9月   4 20:37 bootdrwxr-xr-x.  20 root root 3220 10月 10 09:01 devdrwxr-xr-x.  75 root root 8192 10月 10 09:01 etcdrwxr-xr-x.   4 root root   27 9月  29 09:45 homelrwxrwxrwx.   1 root root    7 9月   4 20:33 lib -&gt; usr/liblrwxrwxrwx.   1 root root    9 9月   4 20:33 lib64 -&gt; usr/lib64drwxr-xr-x.   2 root root    6 4月  11 2018 mediadrwxr-xr-x.   2 root root    6 4月  11 2018 mntdrwxr-xr-x.   2 root root    6 4月  11 2018 optdr-xr-xr-x. 135 root root    0 10月 10 09:01 procdr-xr-x---.   2 root root  151 10月  9 14:26 rootdrwxr-xr-x.  24 root root  720 10月 10 09:01 runlrwxrwxrwx.   1 root root    8 9月   4 20:33 sbin -&gt; usr/sbindrwxr-xr-x.   2 root root    6 4月  11 2018 srvdr-xr-xr-x.  13 root root    0 10月 10 09:01 sysdrwxrwxrwt.  12 root root  265 10月 10 10:09 tmpdrwxr-xr-x.  13 root root  144 9月  28 15:29 usrdrwxr-xr-x.  19 root root  267 9月   4 20:37 var[root@localhost /]# cd /home[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><hr><h3 id="操作文件类命令"><a href="#操作文件类命令" class="headerlink" title="操作文件类命令"></a>操作文件类命令</h3><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p><strong>用于创建目录</strong></p><pre><code class="bash">mkdir [选项] 要创建的目录-p : 创建多级目录</code></pre><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# mkdir dog[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mkdir /home/animal/catmkdir: 无法创建目录&quot;/home/animal/cat&quot;: 没有那个文件或目录[root@localhost home]# mkdir -p /home/animal/cat[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:46 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost animal]# cd animal[root@localhost animal]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 10 13:46 cat</code></pre><h4 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h4><p><strong>rmdir命令用于删除空目录</strong></p><pre><code class="bash">rmdir [目录]</code></pre><p>删除dog目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir dog[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir animalrmdir: 删除 &quot;animal&quot; 失败: 目录非空</code></pre><p>如果要删除一个<strong>非空的目录</strong>需要用<strong>rm -rf</strong>命令</p><pre><code class="bash">[root@localhost home]# rm -rf animal[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p><strong>创建一个空的文件</strong></p><p>接下来，创建一个Hello.txt</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# touch hello.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:14 hello.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# </code></pre><p><strong>touch</strong>也可以创建多个文件</p><pre><code class="bash">[root@localhost home]# touch sb.txt dl.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:15 dl.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy-rw-r--r--. 1 root root  0 10月 10 15:15 sb.txt[root@localhost home]# </code></pre><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p><strong>拷贝文件到指定目录</strong></p><pre><code class="bash">cp [选项] [待拷贝文件] [拷贝目标]-r: 拷贝整个文件夹</code></pre><p>接下来,将a.txt<strong>拷贝到</strong>aaa目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:23 aaa-rw-r--r--. 1 root root  0 10月 10 15:23 a.txtdrwxr-xr-x. 2 root root  6 10月 10 15:25 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# cp a.txt aaa[root@localhost home]# cd aaa[root@localhost aaa]# ll总用量 0-rw-r--r--. 1 root root 0 10月 10 15:23 a.txt[root@localhost aaa]# </code></pre><p>如果，要将aaa目录拷贝到bbb目录下，</p><pre><code class="bash">[root@localhost home]# cp aaa bbbcp: 略过目录&quot;aaa&quot;[root@localhost home]# </code></pre><p>会提示一个错误，略过目录”aaa”，这个时候就需要加入选项<strong>-r</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbb[root@localhost home]# cd bbb[root@localhost bbb]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:29 aaa[root@localhost bbb]# </code></pre><p>如果，再复制一次，会提示要不要覆盖，如果默认要覆盖可以使用<strong>\cp</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbbcp：是否覆盖&quot;bbb/aaa/a.txt&quot;？ y[root@localhost home]# /cp -r aaa bbb-bash: /cp: 没有那个文件或目录[root@localhost home]# \cp -r aaa bbb[root@localhost home]# </code></pre><p>这里注意是<strong>\cp</strong>，不仔细的话容易弄反</p><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p><strong>用于移除文件或目录</strong></p><pre><code class="bash">rm [文件||目录]-r : 递归删除整个文件夹-f : 强制删除不提示</code></pre><p>删除<strong>/home/a.txt</strong>，</p><pre><code class="bash">[root@localhost home]# rm a.txtrm：是否删除普通空文件 &quot;a.txt&quot;？y[root@localhost home]# </code></pre><p>删除<strong>/home/aaa</strong></p><pre><code class="bash">[root@localhost aaa]# rm /home/aaarm: 无法删除&quot;/home/aaa&quot;: 是一个目录[root@localhost aaa]# rm -r /home/aaarm：是否进入目录&quot;/home/aaa&quot;? yrm：是否删除普通空文件 &quot;/home/aaa/a.txt&quot;？yrm：是否删除目录 &quot;/home/aaa&quot;？y[root@localhost aaa]# </code></pre><p>这里可以看出如果要删除目录，要对目录下所有文件确认是否删除，非常麻烦，所以，如果不想提示，加上<strong>-f</strong>命令强制删除<strong>/home/bbb</strong>，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 15:29 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rm -rf /home/bbb/[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p><strong>mv指令用于移动文件或重命名</strong></p><pre><code class="bash">重命名 ： mv oldNameFile newNameFile移动 ： mv /oldPath /newPath</code></pre><p>接下来，我们将<strong>/home/aaa.txt</strong>重命名为<strong>sz.txt</strong></p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root  6 10月 11 09:26 aaa.txtdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mv aaa.txt sz.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# </code></pre><p>然后，将sz.txt移动到<strong>crg</strong>目录里面，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# mv /home/sz.txt/ /home/crg/[root@localhost home]# ll总用量 0drwx------. 3 crg dw 76 10月 11 09:34 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# cd crg[root@localhost crg]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 11 09:26 sz.txt[root@localhost crg]# </code></pre><hr><h3 id="查看文件类命令"><a href="#查看文件类命令" class="headerlink" title="查看文件类命令"></a>查看文件类命令</h3><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p><strong>用来查看文件内容，以只读的方式</strong></p><pre><code class="bash">cat [选项] [目标文件]</code></pre><p>用cat的方式查看<strong>/etc/profile</strong></p><pre><code class="bash">[root@localhost ~]# cat /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091155.png" srcset="/img/loading.gif" alt=""></p><p>这里可以查看，但没有行号，我们给他设定一个行号,加上选项<strong>-n</strong></p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091429.png" srcset="/img/loading.gif" alt=""></p><p>但是，cat命令每次都会直接跑到文件末尾，让你看不清，所以，一般还会给和<strong>| more</strong>连用，</p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile | more</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091759.png" srcset="/img/loading.gif" alt=""></p><p><strong>| more</strong>用来<strong>分页显示</strong>，按<strong>空格</strong>看下一页</p><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p><strong>more命令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件内容</strong></p><p>用<strong>more命令</strong>查看文件,</p><pre><code class="bash">[root@localhost ~]# more /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095423.png" srcset="/img/loading.gif" alt=""></p><p>快捷键,</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095608.png" srcset="/img/loading.gif" alt=""></p><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><p><strong>less命令和more命令类似，但它功能更强大，不会将整个文件加载完后再显示，比more效率更高，一般用于查看大型文件</strong></p><p>接下来，用less命令查看<strong>/etc/services</strong></p><pre><code class="bash">[root@localhost etc]# less /etc/services</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/1570846827372.png" srcset="/img/loading.gif" alt=""></p><p>可以看出，它只加载了这么多就不往下显示了，</p><p><strong>less快捷键：</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012102549.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(2)用户管理</title>
    <link href="undefined2019/11/02/2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>2019/11/02/2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h3 id="Linux用户基本介绍"><a href="#Linux用户基本介绍" class="headerlink" title="Linux用户基本介绍"></a>Linux用户基本介绍</h3><blockquote><p> Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 </p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录</p></blockquote><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927160228.png" srcset="/img/loading.gif" alt=""></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code class="bash">useradd [选项] 用户名</code></pre><p>接下来，添加一个用户 dl</p><pre><code class="bash">[root@localhost ~]# useradd dl</code></pre><p>可能界面看不出什么效果，其实系统已经创建了一个叫<strong>dl的用户</strong>并创建了同名的<strong>组</strong>和 <strong>/home/dl目录</strong></p><pre><code class="bash">[root@localhost /]# cd /home/[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 lj lj 83 9月   5 09:02 lj</code></pre><p>如果你不想创建在<strong>home目录</strong>下，你还可以将<strong>用户</strong>创建在其他目录，这里我想将用户创建在<strong>/home/sb/#</strong></p><pre><code class="bash">[root@localhost home]# mkdir sb[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwxr-xr-x. 2 root root  6 9月  28 08:54 sb</code></pre><p>此时目录已经创建完毕，接着输入命令：</p><pre><code class="bash">[root@localhost home]# useradd -d /home/sb/ qyuseradd：警告：此主目录已经存在。不从 skel 目录里向其中复制任何文件。正在创建信箱文件: 文件已存在</code></pre><p>然后，给用户<strong>dl</strong>和<strong>qy</strong>设置密码:</p><pre><code class="bash">[root@localhost home]# passwd dl更改用户 dl 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@localhost home]# passwd qy更改用户 qy 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。</code></pre><p>这里我两个用户密码都设置为：<strong>12345678</strong>,就算系统提示为通过字典检查，只要你无视它，接着输入<strong>密码</strong>，还是会设置成功，然后我使用<strong>SmarTTY</strong> 登录用户 <strong>dl</strong>和<strong>qy</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928094858.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928102011.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><h5 id="1-删除用户，但保留目录"><a href="#1-删除用户，但保留目录" class="headerlink" title="1.删除用户，但保留目录"></a>1.删除用户，但保留目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 qy qy 62 9月  28 13:48 qy[root@localhost home]# userdel qy //执行删除[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwx------. 2 1002 1002 62 9月  28 13:48 qy</code></pre><h5 id="2-删除用户和目录"><a href="#2-删除用户和目录" class="headerlink" title="2.删除用户和目录"></a>2.删除用户和目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  28 14:19 dldrwx------. 2 qy qy 62 9月  28 14:19 qy[root@localhost home]# userdel -r dl  //执行删除[root@localhost home]# ll总用量 0drwx------. 2 qy qy 62 9月  28 14:19 qy</code></pre><hr><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><pre><code>id  [用户名]</code></pre><pre><code class="bash">[root@localhost home]# id rootuid=0(root) gid=0(root) 组=0(root)[root@localhost home]# id qyuid=1001(qy) gid=1001(qy) 组=1001(qy)[root@localhost home]# </code></pre><hr><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre><code>su [用户名]</code></pre><pre><code class="bash">[root@localhost ~]# su qy[qy@localhost root]$ su root密码：[root@localhost ~]# </code></pre><p>这是一种从<strong>低权限用户</strong>切换到<strong>高权限用户</strong>的方法，</p><p>还有一种</p><pre><code class="bash">[qy@localhost /]$ exitexit[root@localhost ~]# </code></pre><p>直接<strong>exit</strong>，这样就避免了输密码</p><hr><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h5 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h5><pre><code class="bash">groupadd [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupadd dang[root@localhost ~]# </code></pre><h5 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h5><pre><code class="bash">groupdel [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupdel dang[root@localhost ~]# </code></pre><h5 id="增加用户直接加上组"><a href="#增加用户直接加上组" class="headerlink" title="增加用户直接加上组"></a>增加用户直接加上组</h5><pre><code class="bash">useradd -g [组] [用户名]</code></pre><p>增加一个用户crg，分组到zf</p><pre><code class="bash">[root@localhost ~]# useradd -g zf crguseradd：“zf”组不存在[root@localhost ~]# groupadd zf[root@localhost ~]# useradd -g zf crg[root@localhost ~]# id crguid=1002(crg) gid=1002(zf) 组=1002(zf)</code></pre><p>这里我原本以为直接用命令，系统会自动帮我建组，看来我想多了😭，必须你自己建个组，然后再分组</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg zf 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><pre><code class="bash">usermod -g [用户组] [用户名]</code></pre><pre><code class="bash">[root@localhost home]# groupadd dw[root@localhost home]# usermod -g dw crg[root@localhost home]# id crguid=1002(crg) gid=1003(dw) 组=1003(dw)</code></pre><p>这样我们就把<strong>crg</strong>从<strong>zf组</strong>调到<strong>dw组</strong></p><hr><h3 id="用户的配置文件"><a href="#用户的配置文件" class="headerlink" title="用户的配置文件"></a>用户的配置文件</h3><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190929105530.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009095520.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">crg: 用户名x: 加密的密码 真正的密码在 shadow文件里1002: 用户id1003: 组id/home/crg: 用户所在home目录/bin/bash：对应的shell</code></pre><h5 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009100032.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009140544.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">dw: 组名1003: 组id</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(1)vim与vi</title>
    <link href="undefined2019/11/02/1-vim%E4%B8%8Evi/"/>
    <url>2019/11/02/1-vim%E4%B8%8Evi/</url>
    
    <content type="html"><![CDATA[<h1 id="vim与vi"><a href="#vim与vi" class="headerlink" title="vim与vi"></a>vim与vi</h1><h3 id="什么是vim？"><a href="#什么是vim？" class="headerlink" title="什么是vim？"></a>什么是vim？</h3><blockquote><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p></blockquote><h3 id="vi和vim的三种模式转化图如下"><a href="#vi和vim的三种模式转化图如下" class="headerlink" title="vi和vim的三种模式转化图如下:"></a>vi和vim的三种模式转化图如下:</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtbszrfgj30ik0a4whj.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><pre><code class="linux">[root@localhost ~]# ll总用量 4-rw-------. 1 root root 1416 9月   4 20:36 anaconda-ks.cfg[root@localhost ~]# </code></pre><p>可以看出我没有Hello.java文件</p><p>使用命令</p><pre><code class="linux">[root@localhost ~]# vim Hello.java</code></pre><p>随后进入一般模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1dy0j2nj30lf0tb3yo.jpg" srcset="/img/loading.gif" alt=""></p><p>此时还不能编辑，如果要编辑 需要按  <strong>Insert</strong> 或 按 <strong>i</strong> ，进入编辑模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1gyfv0bj30ho0a5q2v.jpg" srcset="/img/loading.gif" alt=""></p><p>当左下角出现<strong>插入</strong>的时候才能开始编辑，如图</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1jlvw60j30ib04i3ys.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，如果要保存</p><blockquote><p><strong>Shift + ; + wq</strong>(wq是 写入(wirte)并退出(queit))</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1mqs047j303p03gmwz.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>:q!</strong>是不保存退出</p><h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtnweqdbj30q90f0gr2.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="1-拷贝"><a href="#1-拷贝" class="headerlink" title="1. 拷贝"></a>1. 拷贝</h5><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dubycqkbj307105zt8s.jpg" srcset="/img/loading.gif" alt=""></p><p>首先插入一些字符,随后按<strong>ESC</strong>进入<strong>命令模式</strong>，选定一行按<strong>yy</strong>，之后按<strong>p</strong>，按一次<strong>P</strong>，粘贴一次</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7duf1mpdzj3063071dft.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，将<strong>光标</strong>移动到第一行，并按<strong>5yy</strong>（Linux的所有数字都是大键盘上的，小键盘的数字会产生其他效果）,随后按<strong>P</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dulepza4j308b02g744.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dumcpa0bj30530bajrl.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h5><p>和拷贝语法类似，我们用<strong>5dd</strong>删除五行</p><p>效果如下:</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dusx4k7gj304406gdfu.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h5><p>进入<strong>命令模式</strong>，输入<strong>/ + [关键字] + 回车</strong>即可查询,按<strong>N</strong>查找下一个</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv1j36y1j303w01ft8h.jpg" srcset="/img/loading.gif" alt=""></p><p>这里要注意Linux的查找字符是<strong>严格区分大小写</strong>的，我这里小写的sbdl就没匹配到😭</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv20n1r3j305u0ag74k.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="4-设置行号"><a href="#4-设置行号" class="headerlink" title="4.设置行号"></a>4.设置行号</h5><p>例行进入<strong>命令模式</strong>，输入 <strong>:set nu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvy3a60vj304o02e3yc.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvygdj6ej307008xq37.jpg" srcset="/img/loading.gif" alt=""></p><p>取消，行号<strong>:set nonu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzjksdfj305r023t8i.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzwzaktj3049081jrj.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="5-行尾和行首"><a href="#5-行尾和行首" class="headerlink" title="5.行尾和行首"></a>5.行尾和行首</h5><pre><code>[root@localhost ~]# vim /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>Shift + g</strong>，进入行尾</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145504.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>gg</strong>回到行首</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><h5 id="6-撤消"><a href="#6-撤消" class="headerlink" title="6.撤消"></a>6.撤消</h5><p>在<strong>编辑模式</strong>下乱输字符</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145915.png" srcset="/img/loading.gif" alt=""></p><p>随后,按<strong>ESC</strong>进入<strong>正常模式</strong>按<strong>u</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927150026.png" srcset="/img/loading.gif" alt=""></p><h5 id="7-移动光标"><a href="#7-移动光标" class="headerlink" title="7.移动光标"></a>7.移动光标</h5><p>第一步：进入<strong>编辑模式</strong>，设置行号， <strong>:set nu</strong></p><p>第二步：进入<strong>正常模式</strong>，输入你要去的行数  10 + <strong>Shift + g</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927153646.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/10/30/hello-world/"/>
    <url>2019/10/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>