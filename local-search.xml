<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>成功日记（十七）</title>
    <link href="undefined2020/09/13/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-17/"/>
    <url>2020/09/13/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-17/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（十七）"><a href="#成功日记（十七）" class="headerlink" title="成功日记（十七）"></a>成功日记（十七）</h1><h2 id="《穷查理宝典》"><a href="#《穷查理宝典》" class="headerlink" title="《穷查理宝典》"></a>《穷查理宝典》</h2><p>进度：<strong>第五讲 需要多元学科技能教育</strong></p><h4 id="职业人士需要多学科知识"><a href="#职业人士需要多学科知识" class="headerlink" title="职业人士需要多学科知识"></a>职业人士需要多学科知识</h4><p>萧伯纳说过：“所谓职业，不过是蒙骗外行人的阴谋。”在我们潜意识层面的思想倾向会导致可怕的后果，其中有两个倾向最突出：</p><ol><li><strong>动机引起的偏见（inventive-caaused bias）</strong>，这是一种先天的认知倾向，认为对职业有利的东西必将对客户或其他事物有利。</li><li><strong>锤子倾向（man-with-a-hammer-tendency）</strong>，来自那个芒格经常提到的谚语：“对于一个拿着锤子的人来说，他眼中的问题都像钉子。”</li></ol><p>如果一个人懂得多学科知识，掌握多种工具，这会限制由于锤子倾向带来的认知偏差。如果不想使自己认知过于主观，避免人生走向偏离的轨道，必须毕生都与上述两种倾向做斗争，这样就会在通往智慧的道路上，更近一步。</p><h4 id="高效率教育模型"><a href="#高效率教育模型" class="headerlink" title="高效率教育模型"></a>高效率教育模型</h4><p>文中查理以飞行员教育为例，列出<strong>六因素系统</strong></p><ol><li>所接受的正规教育的广度足以让飞行员应付飞行实践中几乎所有可能遇上的问题</li><li>所接受的必要的专业教育不仅能让他顺利通过一两项测试，而且能够让他应付自如的地实践问题，甚至能同时处理一至两个复杂的危险情况</li><li>必须学会正向和逆向思考，还必须学会何时把注意力放在期待的效果上，何时放在避免错误上</li><li>训练内容赢更具学科的不同合理分配，以追求未来实践错误损失最小化为目标。针对实践中最重要的内容，进行强化训练，达到灵活运用的地步</li><li>必须养成检查“清单”的习惯</li><li>接受以上教育之后，必须养成复习知识的习惯——经常使用飞行模拟器，防止应对罕见和重要问题的知识在长期闲置后发生钝化</li></ol><h2 id="《经济学原理》"><a href="#《经济学原理》" class="headerlink" title="《经济学原理》"></a>《经济学原理》</h2><p>进度：<strong>第十章 外部性</strong></p><p><strong>外部性：</strong>是一个人的行为对旁观者的影响。</p><p><strong>正外部性：</strong>对旁观者的影响是有利的。</p><p><strong>负外部性：</strong>即对旁观者的影响是不利的。</p><ul><li>新技术研究提供了正外部性，因为它可以提高生产效率，增加了新的知识。</li><li>汽车废气是有负外部性的，因为它产生的废气会被别人吸入，损害别人的健康。</li></ul><h4 id="生产外部性"><a href="#生产外部性" class="headerlink" title="生产外部性"></a>生产外部性</h4><h5 id="生产中的负外部性"><a href="#生产中的负外部性" class="headerlink" title="生产中的负外部性"></a>生产中的负外部性</h5><p>我们以铝工厂排放污染为例：</p><p><img src="https://i.loli.net/2020/09/13/TSzWPUl7p1IRZG3.png" srcset="/img/loading.gif" alt="ProductionNegetive.png"></p><p>这种外部性是负外部性，因为生产铝会产生有害烟尘，给吸入烟尘的人造成健康危害。</p><p>由于这种外部性，生产铝的社会成本大于铝的生产成本。<strong>社会成本</strong>包括铝生产者的私人成本加上受污染影响的不利旁观者成本。</p><p>图中铝的均衡数量（市场量）大于社会最适当的量（最适量）。这里的市场均衡仅仅是对铝企业有利，对整个社会来说并不是均衡的，此时需求曲线在社会成本线之下，因此这是无效率的。</p><h5 id="生产中的正外部性"><a href="#生产中的正外部性" class="headerlink" title="生产中的正外部性"></a>生产中的正外部性</h5><p>以工业机器人市场为例：</p><p><img src="https://i.loli.net/2020/09/13/UntNOBsu2lk5AvE.png" srcset="/img/loading.gif" alt="ProductionPositive.png"></p><p>只要企业建造一个机器人，就有发现新的、更好的设计的机会。这种新设计不仅有利于这个企业，也有利于整个社会，因为这种设计增加了技术知识，加强了生产力，这种正外部性被称为<strong>技术溢出效应</strong>，因此生产的社会成本小于私人成本。</p><h4 id="消费外部性"><a href="#消费外部性" class="headerlink" title="消费外部性"></a>消费外部性</h4><h5 id="消费负外部性"><a href="#消费负外部性" class="headerlink" title="消费负外部性"></a>消费负外部性</h5><p>以酒为例：</p><p><img src="https://i.loli.net/2020/09/13/Zj5pRIFgeKcH1iy.png" srcset="/img/loading.gif" alt="ConsumeNegative.png"></p><p>在这种情况下，社会价值小于个人价值，而且社会最适量小于市场数量。</p><h5 id="消费正外部性"><a href="#消费正外部性" class="headerlink" title="消费正外部性"></a>消费正外部性</h5><p>以教育为例：</p><p><img src="https://i.loli.net/2020/09/13/Dv23JbctLeBYfKh.png" srcset="/img/loading.gif" alt="ConsumePositive.png"></p><p>教育的社会价值大于私人价值，而且社会最适量大于私人最适量。</p><h2 id="《计算机网络原理》"><a href="#《计算机网络原理》" class="headerlink" title="《计算机网络原理》"></a>《计算机网络原理》</h2><p>进度：<strong>第三章 传输层</strong></p><h4 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h4><p>TCP提供<strong>面向连接、可靠、 有序、字节流传输服务。</strong></p><h5 id="一-TCP报文"><a href="#一-TCP报文" class="headerlink" title="一.TCP报文"></a>一.TCP报文</h5><p><img src="https://i.loli.net/2020/09/12/cBgjylu9XWqdJSo.png" srcset="/img/loading.gif" alt="TCPContent.png"></p><ol><li><strong>源端口号</strong>和<strong>目的端口号</strong>分别占16位，用于<strong>标识</strong>发送该报文段的源端口和目的端口，用于多路复用/分解来自或送到上层应用的数据。</li><li><strong>序号</strong>字段与<strong>确认序号</strong>字段分别占32位。如果传输的数据比较大，就会将数据分解成若干分组进行传输，而这些分组传输的速度有的快，有的慢会造成<strong>乱序</strong>，而有了序号就可以让乱序的数组<strong>重新排序</strong>。确认序号是希望发送方下个发送的数据的序号，确认序号是很重要的可靠性保障。</li><li><strong>头部长度</strong>（首部长度）占4位，以4字节为计算单位，当该字段值为5时，表示TCP段首部长度为20字节（5 * 4）。</li><li><strong>保留</strong>字段占6位，保留为以后使用。</li><li><strong>URG、ACK、FIN、RST、PSH、SYN</strong>字段各占1位，共6位。<strong>URG=1</strong>时，表明紧急字段有效，通知系统该报文有经济数据，优先发送；<strong>ACK=1</strong>时，标识确认序号有效，代表这是个确认报文；<strong>FIN=1</strong>时，表明TCP报文发送端数据已发送完毕，请求释放TCP连接；<strong>RST=1</strong>时，表明TCP连接中出现严重差错，必须释放连接然后重连；<strong>PSH=1</strong>时尽快将报文中的数据交付接收应用进程；<strong>SYN=1</strong>时，表示该TCP报文段是一个建立新连接请求控制段或同意建立新连接的确认段。</li><li><strong>窗口</strong>字段占16位，用于向对方通告接收窗口大小，表示接收方的可以接收的数据字节数量啊个，用于流量控制。</li><li><strong>检验和</strong>字段占16字节，对数据进行校验，进行差错检验和控制。</li><li><strong>紧急指针</strong>占16位，当URG=1时才有效，紧急字段指出在本TCP报文中紧急数据共有多少字节，窗口大小为零时，也可以发送紧急数据。</li><li><strong>选项</strong>字段长度可变，最大为32位字节，一般只规定最大报文段按，可以由开发人员往里加需要的项。</li><li><strong>填充</strong>字段，长度为0-3字节，目的为了使整个首部长度为4字节的整数倍。</li></ol><h5 id="二-TCP连接管理"><a href="#二-TCP连接管理" class="headerlink" title="二.TCP连接管理"></a>二.TCP连接管理</h5><p><strong>三此握手(Three-way Handshake)是指建立一个TCP连接的过程。</strong></p><p><img src="https://i.loli.net/2020/09/12/S7Bg9Wj6mEJo4sp.png" srcset="/img/loading.gif" alt="Three-way Handshake.png"></p><p>三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><ul><li><p>第一次握手(SYN=1,seq=x):   <strong>客户端=&gt;服务端</strong></p><p>客户端发送一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口，以及初始序号X，保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕客户端进入<strong>SYN_SEND</strong>状态。</p></li></ul><ul><li><p>第二次握手(SYN=1,ACK=1,seq=y,ACKnum=x+1):  <strong>服务端=&gt;客户端</strong></p><p>服务器发回确认包(ACK)应答。即SYN标志和ACK标志位均为1。服务器端选择自己的序列号，放到Seq域里，同时将确认序号设置为客户端的序列号加1，即X+1。发送完毕后，服务器端进入<strong>SYN_RCVD</strong>状态。</p></li></ul><ul><li><p>第三次握手(ACK=1,ACKnum=y+1)：<strong>客户端=&gt;服务端</strong></p><p>客户端再次发回确认包(ACK)，SYN标志位为0，ACK标志为1，并把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写INS的+1</p><p>发送完毕后，客户端进入<strong>ESTABLISHED</strong>状态，当服务器端接收到这个包时，也进入<strong>ESTABLISHED</strong>状态，TCP握手结束。</p></li></ul><p>完成<strong>三次握手</strong>后，客户端和服务器就可以户向发送包含数据的报文了。在此后每一个报文的SYN都被设置为0。</p><p><strong>四次挥手(Four-Way Wavehand)是指断开一个TCP连接时</strong>，需要客户端和服务端发送四个包确认连接断开。客户端或服务端均可主动发起挥手动作。</p><p><img src="https://i.loli.net/2020/09/12/qYwmvuL3BOnE2fa.png" srcset="/img/loading.gif" alt="Four-Way Wavehand.png"></p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<strong>FIN_WAIT_1</strong>状态（只能接收服务器发过来的数据，不再发送数据）</p></li></ul><ul><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端发送的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<strong>CLOSE_WAIT</strong>状态（仍可以发送数据，但不再接收数据），客户端接收到这个确认包之后，进入<strong>FIN_WAIT_2</strong>状态（仍可以接收服务器数据），等待服务器关闭连接。</p></li></ul><ul><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN设置为1.</p><p>发送完毕后，服务端进入<strong>LAST_ACK</strong>状态（服务器不再发送数据），等待来自客户端的最后一个ACK。</p></li></ul><ul><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收来自服务器端的关闭请求，发送一个确认包，并进入<strong>TIME_WAIT</strong>状态，等待可能出现的要求重传的ACK包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入<strong>CLOSED</strong>状态。</p><p>客户端等待了某个固定时间（两个最大生命周期，2MSL，2 Maximum Segment Lifetime）之后，没收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<strong>CLOSED</strong>状态</p></li></ul><h2 id="Java小技巧"><a href="#Java小技巧" class="headerlink" title="Java小技巧"></a>Java小技巧</h2><h4 id="覆盖equals的通用约定"><a href="#覆盖equals的通用约定" class="headerlink" title="覆盖equals的通用约定"></a>覆盖equals的通用约定</h4><p>在你覆盖类的<strong>equals</strong>方法时需要遵守一定的约定：</p><ul><li><strong>自反性（reflexive）：</strong>对于任何非null的引用值<strong>x</strong>,<strong>x.equals(x)</strong>必须返回<strong>true</strong>。</li><li><strong>对称性（symmetric）：</strong>对于任何非null的引用值<strong>x</strong>和<strong>y</strong>，当且仅当<strong>y.equals(x)</strong>返回<strong>true</strong>时，<strong>x.equals(y)</strong>必须返回<strong>true</strong>。</li><li><strong>传递性（transitive）：</strong>对于任何非null的引用值<strong>x,y **和</strong>z<strong>，如果</strong>x.equals(y)<strong>返回</strong>true<strong>，并且</strong>y.equals(z)<strong>也返回</strong>true<strong>，那么</strong>x.equals(z)<strong>也必须返回</strong>true**。</li><li><strong>一致性（consistent）：</strong>对于任何非null的引用值<strong>x</strong>和<strong>y</strong>，只要<strong>equals</strong>的比较操作在对象中所用的信息没有被修改，多次调用<strong>x.equals(y)</strong>就会一致的返回<strong>true</strong>，或一致的返回<strong>false</strong>。</li><li>对于任何非null的引用值<strong>x</strong>，<strong>x.equals(null)</strong>必须返回<strong>false</strong>。</li></ul><p>这次我们举一个破坏<strong>传递性</strong>的例子,我们以一个简单的<strong>Point</strong>类开始：</p><pre><code class="java">public class Point {    private final int x;    private final int y;   public Point(int x,int y){       this.x = x;       this.y = y;   }    @Override    public boolean equals(Object o) {        if(!(o instanceof Point))            return false;        Point p = (Point) o;        return p.x == x &amp;&amp; p.y == y;    }}</code></pre><p>然后我们想扩展这个类，给它加个颜色</p><pre><code class="java">public class ColorPoint extends Point {    private final Color color;    public ColorPoint(int x, int y, Color color) {        super(x, y);        this.color = color;    }}</code></pre><p>这样会产生什么后果呢？<strong>equals</strong>方法不生效，因为当前类没有<strong>equals</strong>方法而是直接从<strong>Point</strong>继承过来的，这显然不符合我们的逻辑。我们的想法是，当<strong>ColorPoint</strong>的<strong>x,y</strong>一样并且颜色一样才返回<strong>true</strong>：</p><pre><code class="java">    //Broken - violates symmetry!    @Override    public boolean equals(Object o) {        if(!(o instanceof  ColorPoint))            return false;        return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;    }</code></pre><p>这样写在比较普通点和有色点会产生问题，普通点会忽略颜色，返回<strong>true</strong>，有色点会返回<strong>false</strong>，显然破坏了<strong>对称性</strong>：</p><pre><code class="java">    public static void main(String[] args) {        Point p = new Point(1,2);        ColorPoint cp = new ColorPoint(1, 2, Color.RED);        System.out.println(p.equals(cp));   //输出结果： true        System.out.println(cp.equals(p));   //输出结果： false    }</code></pre><p>所以，我们可以让<strong>ColorPoint</strong>在混合比较时忽略颜色信息：</p><pre><code class="java">    //Broken - violates transitivity!    @Override    public boolean equals(Object o) {        if(!(o instanceof  Point))            return false;        //if o is a normal Point,do a color-blind comparison        if(!(o instanceof ColorPoint))            return o.equals(this);        return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;    }</code></pre><p>这样确实有了对称性，但又破坏了传递性：</p><pre><code class="java">    public static void main(String[] args) {        ColorPoint p1 = new ColorPoint(1,2,Color.RED);        Point p2 = new Point(1, 2);        ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);        System.out.println(p1.equals(p2));  //输出结果： true        System.out.println(p2.equals(p3));  //输出结果： true        System.out.println(p1.equals(p3));  //输出结果： false    }</code></pre><p>所以，我们有没有一种方法，既增加新的值组件，又保留<strong>equals</strong>约定？答案就是<strong>复合优于继承</strong>：</p><pre><code class="java">public class ColorsPoint {    private final Point point;    private final Color color;    public ColorsPoint(int x, int y, Color color) {        point = new Point(x, y);        this.color = Objects.requireNonNull(color);    }    /**     * Returns the point-view of this color point.     */    public Point asPoint(){        return point;    }    @Override    public boolean equals(Object o) {        if(!(o instanceof ColorPoint))            return false;        ColorsPoint cp = (ColorsPoint) o;        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);    }}</code></pre><p>不再让<strong>ColorPoint</strong>继承<strong>Point</strong>，而是在<strong>ColorPoint</strong>中加入一个私有<strong>Point</strong>域，以及一个公有视图方法，该方法返回有色点在相同位置的<strong>Point</strong>对象</p><pre><code class="java">    public static void main(String[] args) {        ColorPoint p1 = new ColorPoint(1,2,Color.RED);        Point p2 = new Point(1, 2);        ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);        System.out.println(p1.equals(p2));  //输出结果： false        System.out.println(p2.equals(p3));  //输出结果： false        System.out.println(p1.equals(p3));  //输出结果： false    }</code></pre><p>最后，还有一些<strong>equals</strong>需要注意的点：</p><ul><li>覆盖<strong>equals</strong>时总要覆盖<strong>hashCode</strong></li><li>不要企图让<strong>equals</strong>方法过于智能。如果简单的比较值是否相等，就不难做到遵守<strong>equals约定</strong>，如果过度的寻求等价关系，就会容易陷入麻烦之中，如上面的<strong>Point</strong>和<strong>ColorPoint</strong>。</li><li>不要将<strong>equals</strong>声明的<strong>Object</strong>对象替换为其他类型。这样编译器会提示并不是重写方法，因为它和<strong>Object.equals</strong>不同。</li></ul><pre><code class="java">public boolean equals(Myclass o){    ...}</code></pre><h2 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h2><p><strong>√打卡</strong></p><p><img src="https://i.loli.net/2020/09/12/cVWuj64IxaiOofS.jpg" srcset="/img/loading.gif" alt="Keep.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（十六）</title>
    <link href="undefined2020/09/06/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-16/"/>
    <url>2020/09/06/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-16/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（十六）"><a href="#成功日记（十六）" class="headerlink" title="成功日记（十六）"></a>成功日记（十六）</h1><h2 id="自考"><a href="#自考" class="headerlink" title="自考"></a>自考</h2><p>这周最开心的事莫过于得知我的自考过了<strong>三科</strong>(芜湖~ 起飞🛫)。</p><p>由于疫情原因这次自考从原本的4月推迟到了8月，多给了4个月时间，但考前我还是没有把握，尤其是陌生的管理经济学，非常厚的一本书。最离谱的是我在考试时才发现，原来经济学考试是可以带计算器的（只有加减乘除功能的计算器），别人都是做足准备，就我一人傻傻的在这一根一根数手指的慢慢算。</p><p><strong>经济学</strong>算是打开了我新世界的大门，给了我看世界的另外一种方式，以后我要接触更多的学科，像查理·芒格一样可以用多维度，跨学科的方式来处理事物。</p><p>下面附上我考的非常吉利的成绩👇</p><p><img src="https://i.loli.net/2020/09/05/kd8rq3VQD7ocRBl.jpg" srcset="/img/loading.gif" alt="SelfTest.jpg"></p><h2 id="《经济学原理》"><a href="#《经济学原理》" class="headerlink" title="《经济学原理》"></a>《经济学原理》</h2><p>这周看到了<strong>第九章： 国际贸易</strong></p><h4 id="出口国的自由贸易"><a href="#出口国的自由贸易" class="headerlink" title="出口国的自由贸易"></a>出口国的自由贸易</h4><p>以一个国家的钢铁为例，首先假设这个国家国内的钢铁价格格低于<strong>世界价格</strong>，允许自由贸易，国内价格上升到等于世界价格，没有一个钢铁卖者接受低于世界价格的价格，没有一个买者支付高于世界价格的价格。</p><p>当国内钢铁供给量大于国内需求量，这个国家就成为了一个钢铁<strong>出口国</strong>。</p><p><img src="https://i.loli.net/2020/09/06/9aVbMYw1z4PRfWI.png" srcset="/img/loading.gif" alt="ExportCountry.png"></p><p>上图为出口国的国际贸易供求图，我们再用一个表来看福利变动情况</p><p><img src="https://i.loli.net/2020/09/06/jofN725kusmP9We.png" srcset="/img/loading.gif" alt="ExportTable.png"></p><p>由此可以得出结论：</p><ul><li>当一国允许贸易并成为一种物品的出口者时，该物品的国内生产者状况变好，而该物品的国内消费者状况变坏</li><li>贸易增加了一国的经济福利，因为赢家的收益超过了输家的收益</li></ul><h4 id="进口国的自由贸易"><a href="#进口国的自由贸易" class="headerlink" title="进口国的自由贸易"></a>进口国的自由贸易</h4><p>现假设某国国内钢铁价格高于世界价格。一旦允许自由贸易后，国内价格必须等于世界价格。由于国内供给量小于国内需求量，于是该国成为了一个钢铁<strong>进口国</strong>。</p><p><img src="https://i.loli.net/2020/09/06/RhYSFB8TNc7grj2.png" srcset="/img/loading.gif" alt="ImportCountry.png"></p><p>该图为钢铁进口国的供需图，用一个表来表示进口福利变动情况：</p><p><img src="https://i.loli.net/2020/09/06/XTQw6DGLKoxP35O.png" srcset="/img/loading.gif" alt="ImportTable.png"></p><p>由此可以得出一个与出口国平行的结论：</p><ul><li>当一国允许贸易并成为一种物品的进口者时，国内物品消费状况变好，而国内该物品生产者状况变坏</li><li>贸易增加了一国经济福利，因为赢家的好处超过输家的损失</li></ul><h2 id="《自控力》"><a href="#《自控力》" class="headerlink" title="《自控力》"></a>《自控力》</h2><p>已看到《自控力》<strong>第二章 意志力的本能：人生来就能抵制奶酪蛋糕的诱惑</strong></p><h4 id="心率变异度"><a href="#心率变异度" class="headerlink" title="心率变异度"></a>心率变异度</h4><p>这是个生理学的测量指标，用于反映压力状态和平静状态下的不同身体状态。</p><p>当人们感到压力，交感神经会控制身体，让你准备战斗或逃跑，此时<strong>心率升高，心率变异度降低</strong>。</p><p>当人们成功自控的时候，副交感神经会发挥主要作用，缓解压力，克制冲动，此时<strong>心率降低，心率变异度升高</strong>。</p><p><strong>苏珊娜·希格斯托姆</strong>(美国肯塔基大学心理学家) 在一次实验中发现了这个指标，这个实验是<strong>要求饥饿的学生们不准吃旁边刚做好的曲奇饼。</strong>曲奇饼旁边放了胡萝卜，然后实验人员要求，学生们可以随便吃胡萝卜，但是不能吃曲奇饼，小朋友们很不情愿，但碍于实验人员要求又必须拒绝甜食，这时学生们的<strong>心率变异度</strong>升高了。</p><p>心率变异度可以很好的<strong>反应一个人的意志力程度</strong>，当一个戒酒的人看到酒时，心率变异度生升高，那么他就能保持清醒，相反，他的心率变异度降低，那么他可能会故态复萌，继续饮酒。</p><h4 id="意志力提升方法"><a href="#意志力提升方法" class="headerlink" title="意志力提升方法"></a>意志力提升方法</h4><p><strong>锻炼：</strong>锻炼不仅可以缓解普通的日常压力，还可以像百忧解一样抵抗抑郁。锻炼可以提高你的心率变异度，从而改善自控力。开始锻炼后，大脑会产生更多的细胞灰质和白质，这能让你的大脑更充实、运转更迅速。</p><p><strong>睡眠：</strong>睡眠不足会使大脑前额皮质受损，前额皮质受损就会失去对大脑其他区域的控制。这样你会对普通的压力反应过度，身体会一直处于应激状态，从而释放大量荷尔蒙，使心率变异度大大降低，结果就是 压力越来越大，自控力越来越差。不过睡眠时可以补的，如果睡眠不足的人补充一个好觉，那前额皮质就会恢复如初。想要获得更强的意志力，那么你就早点睡吧。</p><h4 id="自控力的代价"><a href="#自控力的代价" class="headerlink" title="自控力的代价"></a>自控力的代价</h4><p>自控需要的大量能量，科学家认为长时间的自控就像慢性压力一样，会削落免疫系统功能，增加患病概率。</p><p>适度压力是健康生活不可缺少的一部分，适当的自控也是必须的，但如果长期地、不间断的自控，就很容易遇到麻烦。我们需要时间恢复自控消耗的能量，有时需要将脑力和体力放到别的地方，给自己放松一下，弦绷得太紧是会容易断的。</p><h2 id="Java小技巧"><a href="#Java小技巧" class="headerlink" title="Java小技巧"></a>Java小技巧</h2><h4 id="覆盖equals的通用约定"><a href="#覆盖equals的通用约定" class="headerlink" title="覆盖equals的通用约定"></a>覆盖equals的通用约定</h4><p>在你覆盖类的<strong>equals</strong>方法时需要遵守一定的约定：</p><ul><li><strong>自反性（reflexive）：</strong>对于任何非null的引用值<strong>x</strong>,<strong>x.equals(x)</strong>必须返回<strong>true</strong>。</li><li><strong>对称性（symmetric）：</strong>对于任何非null的引用值<strong>x</strong>和<strong>y</strong>，当且仅当<strong>y.equals(x)</strong>返回<strong>true</strong>时，<strong>x.equals(y)</strong>必须返回<strong>true</strong>。</li><li><strong>传递性（transitive）：</strong>对于任何非null的引用值<strong>x,y **和</strong>z<strong>，如果</strong>x.equals(y)<strong>返回</strong>true<strong>，并且</strong>y.equals(z)<strong>也返回</strong>true<strong>，那么</strong>x.equals(z)<strong>也必须返回</strong>true**。</li><li><strong>一致性（consistent）：</strong>对于任何非null的引用值<strong>x</strong>和<strong>y</strong>，只要<strong>equals</strong>的比较操作在对象中所用的信息没有被修改，多次调用<strong>x.equals(y)</strong>就会一致的返回<strong>true</strong>，或一致的返回<strong>false</strong>。</li><li>对于任何非null的引用值<strong>x</strong>，<strong>x.equals(null)</strong>必须返回<strong>false</strong>。</li></ul><p>下面有一个<strong>破坏对称性</strong>的例子：</p><pre><code class="java">//Broken - violates symmetrypublic final class CaseInsensitiveString {    private final String s;    public CaseInsensitiveString(String s) {        this.s = Objects.requireNonNull(s);    }    //Broken - violates symmetry    @Override    public boolean equals(Object o) {        if(o instanceof  CaseInsensitiveString)            return s.equalsIgnoreCase( ((CaseInsensitiveString) o).s );        if(o instanceof String)     //单向操作            return s.equalsIgnoreCase((String) o);        return  false;    }}</code></pre><p>假设有一个不区分大小的字符串和一个普通字符串：</p><pre><code class="java">      public static void main(String[] args) {        CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);        String s = &quot;polish&quot;;        System.out.println(cis.equals(s));    //输出：true        System.out.println(s.equals(cis));    //输出：false    }</code></pre><p>这里的问题在于<strong>CaseInsensitiveString</strong>类中的<strong>equals</strong>知道如何处理普通的字符串对象，但是<strong>String</strong>类中的<strong>equals</strong></p><p>却不知道如何区分大小写，显然违反了对称性，解决这个问题的办法就是去掉企图与<strong>String</strong>类互操作的代码：</p><pre><code class="java">    @Override    public boolean equals(Object o) {        return o instanceof CaseInsensitiveString &amp;&amp;                ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);    }------------------------------------------------------    public static void main(String[] args) {        CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);        String s = &quot;polish&quot;;        System.out.println(cis.equals(s));    //输出：false        System.out.println(s.equals(cis));    //输出：false    }</code></pre><p><strong>equals</strong>方法注意事项比较长，先写这么多，下篇日记接着写！</p><h2 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h2><p><strong>√打卡</strong></p><p><img src="https://i.loli.net/2020/09/05/KBctuw7HFbYO6dn.jpg" srcset="/img/loading.gif" alt="Keep.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（十五）</title>
    <link href="undefined2020/08/30/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-15/"/>
    <url>2020/08/30/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-15/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（十五）"><a href="#成功日记（十五）" class="headerlink" title="成功日记（十五）"></a>成功日记（十五）</h1><h2 id="《穷查理宝典》"><a href="#《穷查理宝典》" class="headerlink" title="《穷查理宝典》"></a>《穷查理宝典》</h2><p>目前已看到查理十一讲中的<strong>第三讲 论基本的、普世的智慧（修正稿）</strong></p><h4 id="掌握跨学科方法"><a href="#掌握跨学科方法" class="headerlink" title="掌握跨学科方法"></a>掌握跨学科方法</h4><p>查理认为想要获得普世的智慧，那么掌握各种思维模型，让知识融汇贯通是比绝大多数方法都有效的。像巴菲特和通用电气CEO 杰克·韦尔奇，他们都是掌握这种方法的人，杰克·韦尔奇拥有工程学博士学位，巴菲特了解很多学科的专业知识。不要理会学科的法定界限，因为世界的组成是多种多样的，而实际上世界是一个整体，只是人们为了方便理解事物人为划分为了很多学科。掌握多学科思维模型，不需要你去了解所有的知识，只要吸取各个学科的精华部分就好。</p><blockquote><p><strong>如果我们试图理解一样看似独立存在的东西，我们将会发现它和宇宙间的其他一切都有联系。</strong><br>                                                                                                                                                       ——约翰·缪尔</p></blockquote><h4 id="要远离极端的意识形态"><a href="#要远离极端的意识形态" class="headerlink" title="要远离极端的意识形态"></a>要远离极端的意识形态</h4><p><strong>严重的意识形态会扭曲人的思想</strong>，像中东的恐怖分子，自爆前还会喊一句”安拉胡可吧“(真主万岁)，在他们的意识形态里，生命一文不值，只有伟大的、唯一的真主才重要，傻孩子，真主其实也只不过是掌权者为了获取自己利益而推出来的傀儡罢了。</p><p>意识形态可以理解为一个人的思想和观念，如果你深受某种意识形态的影响，那你就是自己给自己桎梏，禁锢自己的思想，你的认知会被扭曲。比如：你相信的政府一定是腐败到底的，或者相信你的政府一定是清廉的白莲花，那你就变成了傻子。</p><p>还有像香港近来一直在闹民粹主义，要民主，民主到底是什么？这个东西就一定好吗？</p><p>美国有个阿拉斯加州，就是俄罗斯旁边那个，这块地原本是俄国的，被<strong>美国国务卿威廉·西华德（William Seward）</strong>以每英亩两分钱的价格买下来，当时国内骂声一片，并称阿拉斯加为<strong>西华德冰箱</strong>，然而到了今天，阿拉斯加有很多机场，帮航空公司节省了大量成本，并在上面部署了很多反导系统，使俄罗斯不得不发展<strong>远程导弹</strong>，如果真的民主，就应该听民众的，把阿拉斯加还给俄国，那么美国人过的日子肯定没今天这么舒服。</p><h2 id="《经济学原理》"><a href="#《经济学原理》" class="headerlink" title="《经济学原理》"></a>《经济学原理》</h2><p>目前进度<strong>第八章：税收的代价</strong></p><p>说明税收如何影响福利的先请看一张图</p><p><img src="https://i.loli.net/2020/08/29/XDxfFehESBA6Qqg.png" srcset="/img/loading.gif" alt="Tax.png"></p><p>此时市场的价格为P1，市场销量为Q1，市场总剩余为：A+B+C+D+E+F</p><p>而有税收之后又会发生什么变化呢？我们用一张图表来表示</p><p><img src="https://i.loli.net/2020/08/29/jLuwTVivq1sbdZC.png" srcset="/img/loading.gif" alt="TaxTable.png"></p><p>有了税收之后，使消费者剩余减少了 B+C，生产者剩余减少了 D+E，税收收入增加了 B+D，税收使买卖者状况变坏了，政府状况变好了，但你此时将三者收益相加 （A+B+D+F），发现市场总剩余少了 C+E。</p><p>税收引起的总剩余减少被称为<strong>无谓损失</strong>。C+E的面积是无谓损失的规模。</p><p>为什么会产生无谓损失？因为市场的<strong>供需规律</strong>，当你收取税收时，提高了买者的价格，降低了卖者的价格，于是买者会少买物品，卖者会比之前少生产物品，<strong>市场规模缩小</strong>，所以产生了无谓损失。</p><p>那么什么因素决定无谓损失大还是小呢？</p><p><img src="https://i.loli.net/2020/08/29/vrWPTeQYOXMckd6.png" srcset="/img/loading.gif" alt="TaxNAP.png"></p><p><strong>供给和需求的价格弹性越大，产生的无谓损失也越大。</strong></p><h2 id="《计算机网络原理》"><a href="#《计算机网络原理》" class="headerlink" title="《计算机网络原理》"></a>《计算机网络原理》</h2><p>目前已经看到了<strong>第二章 网络应用</strong>，写篇笔记复习一下看过的知识。</p><h4 id="域名系统-Domain-Name-System，DNS"><a href="#域名系统-Domain-Name-System，DNS" class="headerlink" title="域名系统(Domain Name System，DNS)"></a>域名系统(Domain Name System，DNS)</h4><p>DNS是网络上一个重要的基础应用，它的功能就是<strong>将域名映射为IP地址</strong>。实现将域名映射为IP地址的过程，称为过程解析。</p><p>打个比方，假设你要来我家玩（你要访问我的网站），你就要到我家所在的经纬度（网站的IP地址和端口号），但这样非常不方便记忆，所以一般都是告诉你地名（域名），我家在XX市XX区XX街道。域名和IP地址的关系，就类似经纬度和地名的关系，DNS就是中间转换的这么一个应用。</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP是Web应用的应用层协议，定义浏览器如何向Web服务器发送请求以及Web服务器如何响应。</p><p>HTTP基于传输层的TCP传输报文。浏览器向服务器发送请求之前，首先需要先建立TCP连接，然后才能发送<strong>请求HTTP报文</strong>，并接收<strong>响应HTTP报文。</strong>HTTP在使用TCP连接的策略不同，分为<strong>非持久连接</strong>的HTTP和<strong>持久连接</strong>的HTTP。</p><ul><li><p>非持久连接：非持久连接指HTTP客户与HTTP服务器建立TCP连接后，通过该连接发送HTTP请求报文，接收HTTP响应报文，然后断开连接。每请求传输一个对象，都需要建立新TCP连接，传输结束，断开连接。</p><p><img src="https://i.loli.net/2020/08/29/8qtzS1dNZy47MBo.jpg" srcset="/img/loading.gif" alt="HTTPNotLong.jpg"></p></li><li><p>持久连接：当客户端请求到Web页之后，可以访问Web页所在服务器其他资源(如图片，文件等)，这种情况可以不断开已经建立的TCP连接，称为持久连接。</p><p>而持久连接分为<strong>非流水式连接</strong>和<strong>流水式连接</strong></p><ol><li>非流水式连接：客户端在通过持久连接接收到<strong>前一个响应报文之后</strong>，才发出对下一个对象的请求报文。</li><li>流水式连接：客户端在通过持久连接收到<strong>前一个响应报文之前</strong>，连续依次发送对后续对象的请求报文，然后通过该连接依次接收服务器发回的响应报文。</li></ol></li></ul><p><img src="https://i.loli.net/2020/08/29/TOzkGuih1P26BKV.jpg" srcset="/img/loading.gif" alt="HTTPLongCon.jpg"></p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie中文名小型文本文件，指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</p><p>Cookie一般由服务器端生成，发送给User-Agent(一般是浏览器)，浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站就发送该Cookie给服务器。</p><p>Cookie主要包括4部分内容：</p><ol><li>使用Cookie技术的网站，在给用户发送的HTTP响应报文中，通过Set-Cookie头行，发送大小通常超过4KB的Cookie信息，包括用户ID、用户对网站的访问偏好等</li><li>浏览器每当获得新Cookie信息，便会在Cookie文件中追加一行Cookie信息，包括网站的域、路径、内容、有效期和安全5个字段。</li><li>当用户向已经访问过且已经获得Cookie信息的网站发送HTTP请求报文时，浏览器会自动检索本地的Cookie文件，并在每个请求报文中通过Cookie头行，携带上网站为用户分配的Cookie信息。</li><li>网站在后台数据库存储、维护Cookie信息</li></ol><h2 id="Java小技巧"><a href="#Java小技巧" class="headerlink" title="Java小技巧"></a>Java小技巧</h2><h4 id="try-with-resources优于try-finally"><a href="#try-with-resources优于try-finally" class="headerlink" title="try-with-resources优于try-finally"></a>try-with-resources优于try-finally</h4><p>许多java类库中都有通过调用<strong>close</strong>方法来手工关闭资源。比如<strong>java.sql.Connection</strong>、<strong>InputStream</strong>、<strong>OutputStream</strong>。</p><p>通常我们都是使用<strong>try-finally</strong>来关闭资源：</p><pre><code class="java">    /**     * 读取任意文件第一行     * @param path 文件路径     * @return  文件内容     * @throws IOException 抛出异常     */    public static String  firstLineOfFile(String path) throws IOException {        BufferedReader br = new BufferedReader(new FileReader(path));        try {            return br.readLine();        } finally {            br.close();        }    }</code></pre><p>看起来也不是很麻烦，如果你引用两个资源呢？</p><pre><code class="java">    /**     * 拷贝文件     * @param src   源文件路径     * @param dst   目标文件路径     * @throws IOException  抛出异常     */    public static void copy(String src,String dst) throws IOException {        InputStream in = new FileInputStream(src);        try{            OutputStream out = new FileOutputStream(dst);            try{                byte[] buf = new byte[5];                int n;                while((n = in.read(buf)) &gt;= 0 )                    out.write(buf,0,n);            } finally {                out.close();            }        } finally {            in.close();        }    }</code></pre><p>这看起来和写<strong>if-else</strong>没啥区别，破坏了代码的可读性，当我们使用了<strong>try-with-resources</strong>，这个问题迎刃而解。</p><p>使用<strong>try-with-resources</strong>第一个例子</p><pre><code class="java">    public static String firstLineOfFile(String path) throws IOException {        try(BufferedReader br = new BufferedReader(                new FileReader(path)        )){            return br.readLine();        }    }</code></pre><p>使用<strong>try-with-resources</strong>第二个例子</p><pre><code class="java">    public static void copy(String src,String dst) throws IOException {        try(InputStream in = new FileInputStream(src);            OutputStream out = new FileOutputStream(dst)                ){            byte[] buf = new byte[5];            int n;            while ((n = in.read(buf)) &gt;= 0)                out.write(buf,0,n);        }    }</code></pre><p>发现了吗？使用<strong>try-with-resources</strong>的好处就是不用再去手动<strong>close</strong>资源，使代码变得简洁易懂。书上形容这种写法<strong>short and sweet</strong>。我们依然还可以在<strong>try-with-resources</strong>增加<strong>catch</strong>子句来处理发生异常后的流程。</p><p><strong>try-with-resources</strong>不仅可以使用jdk内置类，开发者也可以通过实现<strong>java.lang.AutoCloseable</strong>接口，然后使自己的类可以在<strong>try-with-resources</strong>生效：</p><p><strong>AutoCloseable</strong>就一个方法：</p><pre><code class="java">public interface AutoClosable{    public void close() throws Exception;}</code></pre><p>下面自己写一个简单的例子</p><pre><code class="java">public class MyClose implements AutoCloseable {    public void doSomething(){        System.out.println(&quot;MyClose Do Something！&quot;);    }    @Override    public void close() throws Exception {        System.out.println(&quot;MyClose Closed!&quot;);    }}</code></pre><p>这样我们也能在<strong>try-with-resources</strong>使用自己的类了：</p><pre><code class="java">    public static void myAutoClose() throws Exception {        try(MyClose myClose = new MyClose()){            myClose.doSomething();        }    }输出：    MyClose Do Something！      MyClose Closed!</code></pre><p>结论：在处理必须关闭的资源时，始终要优先考虑使用<strong>try-with-resources</strong>，而不是复杂的<strong>try-finally</strong>。</p><h2 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h2><p><strong>√</strong>打卡</p><div align="center"><img src="https://i.loli.net/2020/08/29/x7qo8dT2StgXwRa.jpg" srcset="/img/loading.gif"></div>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（十四）</title>
    <link href="undefined2020/08/22/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-14/"/>
    <url>2020/08/22/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-14/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（十四）"><a href="#成功日记（十四）" class="headerlink" title="成功日记（十四）"></a>成功日记（十四）</h1><h2 id="《穷查理宝典》"><a href="#《穷查理宝典》" class="headerlink" title="《穷查理宝典》"></a>《穷查理宝典》</h2><p>已看到查理十一讲中的 <strong>第二讲 论基本的、普世的智慧，及其与投资管理和商业的关系</strong></p><h4 id="要掌握多种思维模型"><a href="#要掌握多种思维模型" class="headerlink" title="要掌握多种思维模型"></a>要掌握多种思维模型</h4><p>可以理解为用多学科的方式来理解事物，如果你只会一两个，你看问题将会扭曲现实，有句谚语<strong>”在在手里拿着铁锤的人看来，任何问题都像钉子“</strong>。</p><p>下面是文中有具体提出过的思维模型</p><p><strong>复利原理</strong>、<strong>排列组合原理</strong>、<strong>工程学类的思维模型（断裂点原则）</strong>、<strong>生物学/生理学模型</strong>、<strong>心理学模型（误判心理学）</strong>、<strong>微观经济学</strong></p><p>其中只有<strong>微观经济学</strong>和<strong>心理学</strong>的书我看过一点，剩下其他的基本没怎么接触过，学海无涯，这么多模型怕是有的学了，有目标总比无头苍蝇好。</p><h4 id="伯克希尔哈撒韦的投资哲学"><a href="#伯克希尔哈撒韦的投资哲学" class="headerlink" title="伯克希尔哈撒韦的投资哲学"></a>伯克希尔哈撒韦的投资哲学</h4><p><strong>伯克希尔哈撒韦不投高科技行业</strong>，查理表示很难理解高科技、芯片等行业发展的实质。高科技行业的改朝换代非常快，像苹果和诺基亚，原本诺基亚已经统治了手机市场，结果乔布斯的苹果一发布，直接把诺基亚拉下神坛。巴菲特不投高科技行业的原因，有一部分可能是因为高科技行业这种颠覆性。</p><p><strong>将股市比作赛马场</strong>，股票的未来的回报率相当于赛马赌博的赔率，他们会仔细的分析，看哪只<strong>“马”</strong>的赔率高，等待机会然后下重注，其他时间则按兵不动。</p><p><strong>伯克希尔哈撒韦喜欢投资优质企业</strong>，他们的绝大部分利润都是通过这个方式来实现的。在一些伟大的企业还没成长起来的时候及早的发现，他们会去关注哪些企业拥有优秀的管理人员，<strong>因为管理人员很重要。</strong></p><h2 id="《经济学原理》"><a href="#《经济学原理》" class="headerlink" title="《经济学原理》"></a>《经济学原理》</h2><p>进度：<strong>第七章 消费者、生产者与市场效率</strong></p><ul><li><p><strong>支付意愿</strong>：一个人愿意为某件商品支付的最高价格，称为 支付意愿</p></li><li><p><strong>消费者剩余</strong>：消费者剩余 是买者支付意愿价格 减去 实际付出的钱</p><p><strong>消费者剩余 = 买者的评估价格 - 买者支付的价格</strong></p><p>例子： 你为了偶像的演唱会门票愿意出1000￥，你买门票的价格为800￥，那你就得到了200￥的消费者剩余</p></li></ul><p>消费者剩余是衡量消费者从一种物品中得到了多少<strong>效用</strong>，是一种买者自己才能感觉到的收益。</p><ul><li><p><strong>生产者剩余</strong>： 卖者得到的价格家减去生产成本。</p><p><strong>生产者剩余 = 卖者得到的价格 - 卖者的成本</strong></p><p>例子：你愿意以100￥的价格去从事保安这个工作，但这份工作的工资为200￥，你就得到了100￥的生产者剩余。</p></li><li><p><strong>总剩余：</strong>要衡量社会经济福利，就是消费者剩余和生产者剩余的总和</p><p><strong>总剩余 = 买者的评估价格 - 买者的支付价格 + 卖者得到的价格 - 卖者的成本</strong></p><p>因为，买者支付的价格就等于卖者得到的价格，所以相互抵消，结果就是：</p><p><strong>总剩余 = 买者的评估价格 - 卖者的成本</strong></p></li></ul><p>消费者剩余可以用 <strong>需求曲线 ** 表示，生产者剩余可以用 **供给曲线</strong> 表示</p><p>市场会把供给分配给那些评估价格高的买者，市场也会把需求分配给那些生产成本低的卖者。</p><p>所以说，市场通常可以让资源得到最优配置，它就是亚当·斯密说的”看不见的手”。</p><p>但有时候也会发生<strong>市场失灵</strong>的情况：</p><ul><li><strong>市场势力：</strong>也就是垄断，当市场中只有一家企业时，这家企业可以任意定价造成市场失灵</li><li><strong>外部性：</strong>环境污染，导致别人的市场利益受到损害，这个时候的政府政策就可以开始行动了</li></ul><h2 id="《自控力》"><a href="#《自控力》" class="headerlink" title="《自控力》"></a>《自控力》</h2><div align="center"><img src="https://i.loli.net/2020/08/23/ciXvYLIulk6GaHo.png" srcset="/img/loading.gif">=</div><p><strong>第一章 我要做，我不要，我想要</strong></p><p>一般说到意志力，大部分人估计都会想到拒绝诱惑，拒绝蛋糕，拒绝高卡路里的炸鸡或是拒绝香烟之类的。这就是<strong>“我不要”</strong>。</p><p>但意志力不只是一味的说<strong>“我不”</strong>，除了说不，你还得学会说<strong>“我要”</strong>，减肥，学习这些事情也是需要意志力的，这就是<strong>“我要做”</strong>。</p><p><strong>“我不要”</strong>和<strong>“我要做”</strong>是自控的两种表现，但不是全部。要权衡如何在<strong>需要”说不”时”说不“，需要”说要“时”说要“</strong>，还需要第三种因素，就是<strong>我想要</strong>，这个我想要不是我想要一只炸鸡，想要吃巧克力蛋糕。但你真正想要的其实是，赚更多的钱、变得更苗条、变得更优秀。这些事情才是你真正的目标，关键时刻明确自己的目标，这就是<strong>”我想要“</strong>。</p><p>书中提到一种训练意志力方法——<strong>五分钟冥想</strong>。</p><ol><li><p>原地不动，安静做好</p></li><li><p>注意自己的呼吸</p><p>吸气时脑中默念<strong>“吸”</strong>，呼气时脑中默念<strong>”呼“</strong></p></li><li><p>感受呼吸，弄清自己是怎么走神的</p><p>几分钟后，可以不再默念”呼“ ”吸“。这时你可能更容易走神，当你发现自己想别的事情时，很难集中注意力，可以重新在脑中默念 ”呼“ ”吸“，这样可以锻炼自我意识和自控力。</p></li></ol><h2 id="JAVA小技巧"><a href="#JAVA小技巧" class="headerlink" title="JAVA小技巧"></a>JAVA小技巧</h2><p><strong>注意过期的对象引用</strong></p><p>Java比C好用的地方，就是java有<strong>GC</strong>，不用的对象系统会自动帮你回收，不用像C用完还要自己手动<strong>free</strong>。这方便了程序员们工作，但你不能认为你不用考虑<strong>内存管理</strong>的事情。</p><p>看一下用java实现简单的栈：</p><pre><code class="java">public class Stack {    private Object[] elements;    private int top = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 3;    public Stack(){        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e){        ensureCapacity();        elements[top++] = e;    }    public Object pop(){        if(top == 0)            throw new EmptyStackException();        Object result = elements[--top];        return result;    }    /**     *  保证每次新增元素都有足够空间     */    private void ensureCapacity(){        if(elements.length == top)            elements = Arrays.copyOf(elements,2 * top + 1);    }}</code></pre><p>这样写看起来好像没啥问题，但是当你调用的时候就发现——靠北，问题大了！</p><pre><code class="java">        Stack stack = new Stack();        stack.push(&quot;a&quot;);         stack.push(&quot;b&quot;);        stack.pop();        stack.pop();输出：    Stack{elements=[a, null, null], top=1}    Stack{elements=[a, b, null], top=2}    Stack{elements=[a, b, null], top=1}    Stack{elements=[a, b, null], top=0}</code></pre><p>你会发现<strong>pop()</strong>不起作用，我明明不用这个对象了，为啥java不把他回收呢？那是因为栈内部维护着这些对象的<strong>过期引用(obsolete reference)</strong>，而过期引用是永远不会被回收的。</p><p>因为你的Stack类是自己管理着内存，开发人员知道，<strong>elements</strong>里数组下标<strong>小于top</strong>的对象重要，其余的需要回收，但是垃圾回收器不懂，他认为整个<strong>elements</strong>里的元素都是一视同仁的，都是有用的。于是就造成了<strong>过期引用</strong>，<strong>只要是类自己管理内存，程序员就要警惕内存泄漏问题。</strong></p><p>解决的办法也很简单就是<strong>手动清空</strong>。</p><pre><code class="java">    public Object pop(){        if(top == 0)            throw new EmptyStackException();        Object result = elements[--top];        elements[top] = null; /* 手动清空 */        return result;    }</code></pre><p>因为JDK也有Stack类,所以我去翻了翻JDK<strong>java.util.Stack</strong>的源码，看看它是怎么做的，下面是JDK的Stack类的pop方法：</p><pre><code class="java">    public synchronized E pop() {        E       obj;        int     len = size();        obj = peek();        removeElementAt(len - 1);        return obj;    }</code></pre><p>这里面调用了一个<strong>removeElementAt()</strong>方法，这是<strong>java.util.Vector</strong>的方法，而JDK里的Stack类继承自<strong>Vector</strong>类，进去<strong>Vector.removeElementAt()</strong>你就会看见下面这句话：</p><pre><code class="java">        elementData[elementCount] = null; /* to let gc do its work */</code></pre><p>原来JDK的Stack也是用的手动清空的方式来回收内存！</p><h2 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h2><p><strong>√</strong>打卡</p><div align="center">    <img src="https://i.loli.net/2020/08/22/2WgnejqFudKlYOQ.jpg" srcset="/img/loading.gif"></div>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（十三）</title>
    <link href="undefined2020/08/17/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-13/"/>
    <url>2020/08/17/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-13/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（十三）"><a href="#成功日记（十三）" class="headerlink" title="成功日记（十三）"></a>成功日记（十三）</h1><h2 id="1-Java小技巧"><a href="#1-Java小技巧" class="headerlink" title="1.Java小技巧"></a>1.Java小技巧</h2><p><strong>建造者模式也可以适用于类的层次结构</strong></p><p>比如，用类的层次根部的一个抽象类表示各种披萨:</p><pre><code class="java">public abstract class Pizza {    //HAM:火腿，MUSHROOM: 蘑菇，ONION:洋葱，PEPPER:胡椒，SAUSAGE:香肠    public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }    Set&lt;Topping&gt; toppings;    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; {        /**         * 创建一个枚举Set集合里面元素为Topping         * EnumSet.noneOf(Topping.class)输出:[]         * EnumSet.allOf(Topping.class)输出：[HAM, MUSHROOM, ONION, PEPPER, SAUSAGE]         */        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);        public T addTopping(Topping topping){            toppings.add(topping);            return self();        }        abstract Pizza build();        protected abstract T self();    }    Pizza(Builder&lt;?&gt; builder){        toppings = builder.toppings.clone();    }}</code></pre><p>有两个具体的Pizza子类，一个是纽约风味披萨NyPizza，一个是半月型披萨Calzone</p><pre><code class="java">//纽约披萨public class NyPizza extends Pizza{    //中，大，超大    public enum Size{ SMALL,  MEDIUM, LARGE, }    private Size size;    public static class Builder extends Pizza.Builder&lt;Builder&gt;{        private Size size;        public Builder(Size size){            this.size = Objects.requireNonNull(size);        }        @Override        public NyPizza build() {            return new NyPizza(this);        }        @Override        protected Builder self() {            return this;        }    }    private NyPizza(Builder builder) {        super(builder);        size = builder.size;    }}//半月形披萨public class Calzone extends Pizza {    //是否加酱    private boolean sauceInside;    public static class Builder extends Pizza.Builder&lt;Builder&gt;{        private boolean sauceInside = false;    //Default        public Builder sauceInside(){            this.sauceInside = true;            return this;        }        @Override        public Calzone build() {            return new Calzone(this);        }        @Override        protected Builder self() {            return this;        }    }    private Calzone(Builder builder) {        super(builder);        sauceInside = builder.sauceInside;    }}</code></pre><p>每个子类的<strong>build</strong>方法都返回了正确的子类：<strong>NyPizza.Builder</strong>的<strong>build</strong>返回了<strong>NyPizza</strong>，而<strong>Calzone.Builder</strong>返回了<strong>Calzone</strong>。这样就不需要子类转换类型，这被称作<strong>协变返回类型</strong>(covariant return type)</p><p>调用示例：</p><pre><code class="java">NyPizza nyPizza = new NyPizza.Builder(LARGE).addTopping(SAUSAGE)    .addTopping(HAM).build();    //输出：size=LARGE, toppings=[HAM, SAUSAGE]Calzone calzone = new Calzone.Builder().addTopping(MUSHROOM)    .addTopping(ONION).addTopping(PEPPER)    .sauceInside().build();    //输出：sauceInside=true, toppings=[MUSHROOM, ONION, PEPPER]</code></pre><p><strong>使用枚举实现单例模式</strong></p><p>实现单例模式的常用方法都是，保持构造器私有，然后导出公有静态成员</p><pre><code class="java">public class FakeInstance {    public static final FakeInstance INSTANCE = new FakeInstance();    private FakeInstance(){}}</code></pre><p>但这种单例模式是可以被反射攻击的</p><pre><code class="java">    public static void fakeInstance() throws Exception {        Class&lt;FakeInstance&gt; clazz = FakeInstance.class;        Constructor&lt;FakeInstance&gt; constructor = clazz.getDeclaredConstructor(null);        constructor.setAccessible(true);        FakeInstance fakeInstance = constructor.newInstance();        FakeInstance instance = FakeInstance.INSTANCE;        System.out.println(fakeInstance.equals(instance) &amp;&amp; fakeInstance == instance);  //输出：false    }</code></pre><p>而单例最好的实现方式是枚举，这种方式的好处有三个，枚举类没法反射、线程安全、防止序列化生成新的类，而且代码简洁</p><pre><code class="java">public enum RealInstance {        INSTANCE;        public void become(){            System.out.println(&quot;成为单例&quot;);        }}</code></pre><p>调用示例：</p><pre><code class="java">    RealInstance.INSTANCE.become();  //输出：成为单例</code></pre><h2 id="2-《穷查理宝典》"><a href="#2-《穷查理宝典》" class="headerlink" title="2.《穷查理宝典》"></a>2.《穷查理宝典》</h2><p>目前已经看到<strong>第四章 查理十一讲</strong>的第一讲，查理哈佛大学毕业典礼上的演讲。</p><p>查理在文中提到<strong>约翰尼·卡森</strong>(美国著名脱口秀主持人)的演讲，教你如何获得痛苦人生</p><ul><li>1.为了改变心情或感觉使用化学物质</li><li>2.妒忌</li><li>3.怨恨</li></ul><p>而后查理开了一些可以使你达到痛苦人生的处方</p><p>第一，<strong>你要反复无常</strong>，这个习惯可以抵消你所有优点产生的效应。</p><p>第二，<strong>依靠自己的经验获取知识，不要吸取别人的教训</strong>。</p><p>第三，<strong>遭遇失败后就一蹶不振</strong>，这个方法可以让你们永远的陷入痛苦生活中。</p><p>第四，<strong>忘记乡下人故事</strong>，有个乡下人曾经说过：“要是我知道我会死在哪里就好了，这样我就永远都不会去那个地方”。</p><p>第五，<strong>尽可能减少客观性</strong>。</p><p>这种说反话的演讲真的很奇妙，查理·芒格简直是个<strong>失败学大师</strong>，和国内的成功学大师完全反过来，但他可比所谓的成功学大师成功多了。</p><h2 id="3-《经济学原理》"><a href="#3-《经济学原理》" class="headerlink" title="3.《经济学原理》"></a>3.《经济学原理》</h2><p>目前已看到<strong>第六章 供给、需求与政府政策</strong></p><p>任何一桩物品的交易中，买家总想要低价格，卖家总想要高价格。</p><p>政府为了买家利益，可以规定物品的法定最高价格，这称为<strong>价格上限</strong>。</p><p>政府为了卖家利益，可以规定物品的法定最低价格，这称为<strong>价格下限</strong>。</p><p><strong>价格上限的影响：</strong>如果价格上限过低，就会产生<strong>商品短缺</strong>，以冰淇凌为例</p><p><img src="https://i.loli.net/2020/08/17/1b7ip9NKU5vI2lz.png" srcset="/img/loading.gif" alt="UpLimit.png"></p><p>当政府规定价格小于市场均衡价格的时候，此时<strong>商品供给量少于商品需求量</strong>，于是造成了商品短缺。</p><p><strong>价格下限的影响：</strong>如果价格下限过低，则会产生<strong>商品过剩</strong>，比如最低工资</p><p><img src="https://i.loli.net/2020/08/17/2vCp5QGcnhti178.png" srcset="/img/loading.gif" alt="LowerLimit.png"></p><p>如果最低工资高于均衡工资，<strong>劳动供给量大于需求量</strong>，结果就是失业。最低工资增加了有工作人士的收入，但减少了没工作人士的收入。</p><p>价格控制的初衷都是想帮助人们，尤其是穷人，但是最后的结果都往往伤害了它想要帮助的对象，如果政府限制了物品的最高价格，结果就是物品会更难被买到，急需要该物品的消费者就会支付更高的价格来购买这个物品，于是就有了黑市交易。</p><p>最低工资会增加一些人的收入，却也会使一些人成为失业者。</p><h2 id="4-《计算机网络原理》"><a href="#4-《计算机网络原理》" class="headerlink" title="4.《计算机网络原理》"></a>4.《计算机网络原理》</h2><p>这周我买的计算机网络原理到了，下次考试搞定这门。</p><p>计划30天看完这本书，15天用来刷题；</p><div align="center">    <img src="https://i.loli.net/2020/08/16/m1oUTwrSVs6BxFR.jpg" srcset="/img/loading.gif"></div><h2 id="5-Keep"><a href="#5-Keep" class="headerlink" title="5.Keep"></a>5.Keep</h2><p>*<em>√ *</em> 打卡</p><div align="center">    <img src="https://i.loli.net/2020/08/15/YQh5eF9lcJNPbkD.jpg" srcset="/img/loading.gif"></div>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（十二）</title>
    <link href="undefined2020/08/08/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-12/"/>
    <url>2020/08/08/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-12/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（十二）"><a href="#成功日记（十二）" class="headerlink" title="成功日记（十二）"></a>成功日记（十二）</h1><h2 id="1-《穷查理宝典：查理·芒格的智慧箴言录》"><a href="#1-《穷查理宝典：查理·芒格的智慧箴言录》" class="headerlink" title="1.《穷查理宝典：查理·芒格的智慧箴言录》"></a>1.《穷查理宝典：查理·芒格的智慧箴言录》</h2><div align="center"><img src="https://bkimg.cdn.bcebos.com/pic/37d3d539b6003af33a875d1cba63d15c10385343183f" srcset="/img/loading.gif" width="300px" height="300px"></div><p><strong>查理·芒格</strong>巴菲特的黄金搭档，是股神身后的男人，伯克希尔哈撒韦的副主席。</p><p>他有着百科全书般的知识，分析事情喜欢用多学科的方式来看待问题，对问题进行降维打击。巴菲特称有个“两分钟效应”，查理具有的敏锐的眼光和洞察力，即使是面对陌生的领域，他也能一眼看穿事物的本质。感觉这个人就是快达到了经济学中“绝对理性人”的存在。</p><p>这本书我觉得能算一本哲学书，我称之为《查理·芒格主义》，目前才刚看，开头几章就已经让我感到惊艳，书中对芒格的思维描述非常精彩，都不像在读书，像走进了这个老头的脑子里一样。</p><p>其中有一段关于查理·芒格逆向思维的描述，让我感觉到仿佛有一道光照在了我的混沌的脑袋上</p><blockquote><p>查理思考问题总是从逆向开始。如果要明白人生如何才能得到幸福，查理首先会研究人生如何才能变得痛苦；要研究企业如何做强做大，查理首先研究企业是如何衰败的；大部分人更关心如何在股市投资上成功，查理最关心的却是为什么在股市投资上大部分人都失败了。他的这种思考方法来源于下面这句农夫谚语中所蕴含的哲理：我只想知道将来我会死在什么地方，这样我就永远不去那儿了。 </p></blockquote><p>什么是学习？学习就是发现新事物，接受新思想。</p><p><strong>公众号 成长的青年 回复：穷查理宝典，即可获得PDF电子书</strong></p><h2 id="2-《经济学原理》"><a href="#2-《经济学原理》" class="headerlink" title="2.《经济学原理》"></a>2.《经济学原理》</h2><p>目前曼昆的经济学原理我已经看到了<strong>第五章 弹性及应用</strong>。</p><p><strong>弹性：</strong>需求量或供给量对其决定因素中某一种反应程度的衡量。</p><p><strong>需求价格弹性</strong>：一杯小鹿茶，现卖20元，我一个星期喝2杯，然后它降价到10元，于是我变成一个星期喝5杯，物品的需求量对价格反应变动大，可以说这种物品是<font color="blue">需求富有弹性</font>。</p><p>一部华为手机卖5000￥，我买不起，购买数量为0，它降价为4000￥，我还是买不起，购买数量还是0，这种物品我们称为为<font color="blue">缺乏弹性</font>（我很爱国，我只是有点穷，买不起华为）</p><p>书中有句老话说，<strong>一只鹦鹉只要学会说“供给与需求”就可以成为一个经济学家</strong>。</p><p>所以我现在勉强算个民间经济科学家了吧，简称民科。</p><h2 id="3-Java小技巧"><a href="#3-Java小技巧" class="headerlink" title="3.Java小技巧"></a>3.Java小技巧</h2><p>遇到多个构造器参数时要考虑使用<strong>建造者模式(Builder Pattern)</strong></p><p>我们经常遇到一个开发场景，就是一个实体类的参数很多，你要创建它的对象然后给它赋值。</p><p>第一种方法，使用类的构造方法</p><pre><code class="java">public User(String id,String account,String password,String sex,String name,String phone){       this.id        = id;       this.account   = account;       ...   }</code></pre><p>创建实例</p><pre><code class="java">User user = new User(UUID,&quot;123456&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;会飞的猪&quot;,&quot;10010&quot;);</code></pre><p>这样的过多的参数会使你眼花缭乱，值很多不知道什么意思，有时候还容易弄错属性的顺序，可读性不太好。</p><p>第二种方法，就是使用JavaBeans模式，也就是Getter Setter</p><pre><code class="java">public void setId(String id) {this.id = id;}public void setAccount(String account){this.account = account;}  ....</code></pre><p>创建对象</p><pre><code class="java">User user = new User();user.setId(UUID);user.setAccount(&quot;123456&quot;);...</code></pre><p>绝大部分人肯定用的都是这种方式，可惜的是这种方式其实是有缺点的。因为有很多set，所以构造过程被拆分成好几个调用，在构造过程中会导致JavaBeans可能处于<strong>不一致状态</strong>，于是你就需要额外写代码来保持线程安全。</p><p>   第三种方法，既可以像构造器模式那样安全，也可以像JavaBeans模式那样可读性好。这就是建造者模式(Builder Pattern)</p><pre><code class="java">public class User {    private String id;    private String account;    private String password;    private String sex;    private String name;    private String phone;    public static class Builder{        private String id;        private String account;        private String password;        private String sex;        private String name;        private String phone;        public Builder id(String var){ id = var;   return this; }        public Builder account(String var){ account = var;return this;};        public Builder password(String var){        password = var;  return this; };        public Builder sex(String var){ sex = var;  return this; };        public Builder name(String var){ name = var;  return this; };        public Builder phone(String var){ phone = var;  return this; };        //将构造器的值赋给实体类        public User build(){            return new User(this);        }    }    //私有类的构造方法保证安全性(类似单例模式)    private User(Builder builder){        this.id = builder.id;        this.account = builder.account;        this.password = builder.password;        this.sex = builder.sex;        this.name = builder.name;        this.phone = builder.phone;    }}</code></pre><p>创建对象</p><pre><code class="java">User user = new  User.Builder()    .id(&quot;1As5w86a1d&quot;).account(&quot;123456&quot;)    .password(&quot;123456&quot;).sex(&quot;男&quot;)    .name(&quot;轩辕狂傲&quot;).phone(&quot;111111&quot;).build();</code></pre><p>这样既可以像构造器模式那样安全，也可以像JavaBeans模式那样可读性好，一举两得！</p><h2 id="4-公众号"><a href="#4-公众号" class="headerlink" title="4.公众号"></a>4.公众号</h2><p>之前自考周末要复习，时间比较少，所以我把成功日记搬到微博上去了，现在自考考完了，所以我胡汉三又回来了。</p><p>微博也有很多人在写成功日记的，但他们都是一条一条的写，没有像我这样长篇大论似的写，可能我是个话痨吧，主要是我觉得公众号放着不用有点可惜。</p><h2 id="5-Keep"><a href="#5-Keep" class="headerlink" title="5.Keep"></a>5.Keep</h2><p>*<em>√ *</em> 打卡</p><div align="center">    <img src="https://i.loli.net/2020/08/09/mj2vwDEbLcrCpNG.jpg" srcset="/img/loading.gif" width="350" height="500"></div>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（六）</title>
    <link href="undefined2020/06/27/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-6/"/>
    <url>2020/06/27/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-6/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（六）"><a href="#成功日记（六）" class="headerlink" title="成功日记（六）"></a>成功日记（六）</h1><h2 id="1-《经济学原理》读后笔记"><a href="#1-《经济学原理》读后笔记" class="headerlink" title="1.《经济学原理》读后笔记"></a>1.《经济学原理》读后笔记</h2><p><strong>经济</strong>一词源于希腊语，意为“管理家庭的人”，事实上，家庭和经济有着许多共同之处。</p><p>经济学领域很广，但可以用一些中心思想统一这个领域，那就是</p><p><strong>经济学十大原理</strong></p><p><font color="blue">原理一：人们面临交替关系</font></p><p>每个人都有的宝贵资源——时间，你可以用一小时去学习经济学，也可以用这一小时去学习心理学，当你用一小时拿来学习，你就不能去刷抖音，看综艺或为爱豆打榜，这就是我们面临的交替关系。</p><p><font color="blue">原理二：某种东西的成本是为了得到它而放弃的东西</font></p><p>这个原理对应经济学一个专有名词叫做<strong>机会成本</strong>，到了读大学年龄的运动员，如果退学去参加职业比赛就能赚几百万，而去读书不一定有机会能赚到这么多钱，所以他们去读书的机会成本是很高的。</p><p><font color="blue">原理三：理性人考虑边际量</font></p><p>生活中许多决策涉及对现有行动计划进行微小的增量调整。这些调整被称为<strong>边际变动</strong></p><p>航空公司，每个乘客的成本为500元，假设一个飞机在即将起飞时，仍有10个空位，那么航空公司能不能以300元价格卖一张票呢？一般都认为不可以，因为低于500元就会亏本，但其实是可以的，因为多增加一名乘客的成本是微乎其微的，边际成本为一顿飞机餐加一罐饮料的成本(50元)。只要等退票的乘客支付的钱大于边际成本，那就是赚的。多增加乘客付的钱(300元)为边际收益。</p><p>个人和企业考虑边际量可以做出更好的决策。</p><p><font color="blue">原理四：人们会对激励作出反应</font></p><p>当成本与收益变动时，人们的行为也会改变。比如今年疫情的口罩价格上升，于是很多企业和个人，都去制作口罩了。</p><p><font color="blue">原理五：贸易能使每个人状况更好</font></p><p>家庭成员找工作时也在与找工作的其他人竞争。当购物的时候，也相互竞争，因为大家都想以最低的价格买到最好的东西。因此，经济中每个家庭都在与其他家庭竞争。</p><p>但如果你与别的家庭隔绝来往，那你就得自己学会种地，自己学会做衣服，自己学会盖房自己住。</p><p>贸易可以使大家做自己最擅长的事，用最低的价格买到各种各样的东西，经济全球化，大家既是竞争对手，也是合作伙伴。</p><p><font color="blue">原理六：市场通常是组织经济活动的一种好方法</font></p><p>从中国改革开放看这条原理无疑是非常正确的，市场经济确实比计划经济有活力的多，市场经济讲究效率，计划经济讲究平等，一个是把蛋糕做大，一个是把蛋糕切的平均。</p><p>亚当·斯密的《国富论》中提出：家庭和企业在市场上相互交易，他们彷佛被一只“看不见的手”所指引，引起合意的市场结果。这只手就是 <strong>价格</strong>。</p><p><font color="blue">原理七：政府有时可以改善市场结果</font></p><p>市场确实是组织经济的好方法，但有时候也会有例外。</p><p>有时候会<strong>市场失灵</strong>的情况的出现，有两个原因，一个是<strong>外部性</strong>，一个人的行动对旁观者福利的影响。比如环境污染，工厂排放烟尘不承担成本的话，它就会大量排放，影响别人的生产。一个是<strong>市场势力</strong>，也可称市场权力，指一个人(或一群人)不适当地影响市场价格的能力。比如，一个镇里的全部水资源被一个公司掌控，这个公司就对水的销售有市场势力，它是一个垄断企业。这个企业不受竞争限制，使看不见的手失效。</p><p>这个时候就需要政府介入解决市场失灵的情况。</p><p><font color="blue">原理八：一国的生活水平取决于它生产物品与劳务能力</font></p><p>世界各国生活水平的差距是巨大的，发达国家生活很好，是因为发达国家工业化程度高，生产的东西多，人均比发展中国家拥有更多汽车，更多电视，更多营养。几乎所有生活水平的变动都可以归因于<strong>生产率</strong>的差别，即一个工人一小时生产的物品与劳务量的差别。</p><p><font color="blue">原理九：当政府发行过多货币时，物价上升</font></p><p><font color="blue">原理十：社会面临通货膨胀与失业之间的短期交替关系</font></p><h2 id="2-个人战略改变"><a href="#2-个人战略改变" class="headerlink" title="2.个人战略改变"></a>2.个人战略改变</h2><p>调整个人计划，成功日记可以搬运至微博，进行简化，详细的知识如读后感之类的，则写成一篇稿子发布在公众号内。</p><h2 id="3-《管理经济学》学习"><a href="#3-《管理经济学》学习" class="headerlink" title="3.《管理经济学》学习"></a>3.《管理经济学》学习</h2><p>这星期已经学完了<strong>第十章 垄断竞争市场中的企业决策</strong>，希望下一周可以看完最后两章，然后进入刷题模式。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-《操作系统》"><a href="#4-《操作系统》" class="headerlink" title="4.《操作系统》"></a>4.《操作系统》</h2><p>刷题，这周进行了三张试卷的完成，发现已知的一些问题，填空和简答是我的弱项，对书的细节知识不够明确，需要加快刷题速度。</p><h2 id="5-Keep"><a href="#5-Keep" class="headerlink" title="5.Keep"></a>5.Keep</h2><p>下面是我最近练习情况👇</p><div align=center ><img src="https://i.loli.net/2020/06/27/hmsqad6zrSCR3Vf.jpg" srcset="/img/loading.gif" ></div><p>这周我开始更改了我的<strong>Keep频率</strong>，从原来的三天一次锻炼，缩短到两天一次。</p><p>为什么呢？因为我看到了一个好兄弟的近照，看到他的麒麟臂，羡慕，这也侧面提醒我做的不够好，摆脱舒适圈。</p><blockquote><p><strong>萧伯纳：自我控制是最强者的本能</strong></p></blockquote><p><img src="https://i.loli.net/2020/06/27/LD4ZHgGN9zubAwY.jpg" srcset="/img/loading.gif" alt="garry.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（五）</title>
    <link href="undefined2020/06/14/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-5/"/>
    <url>2020/06/14/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-5/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（五）"><a href="#成功日记（五）" class="headerlink" title="成功日记（五）"></a>成功日记（五）</h1><h2 id="1-《富爸爸穷爸爸》阅后小笔记"><a href="#1-《富爸爸穷爸爸》阅后小笔记" class="headerlink" title="1.《富爸爸穷爸爸》阅后小笔记"></a>1.《富爸爸穷爸爸》阅后小笔记</h2><p>这本书内容比较少，我在通勤的地铁上就给他读完了。</p><p>书里面一直在强调一个概念，<strong>财商(Financial IQ)</strong>，这是一种由<strong>会计、投资、了解市场和法律</strong>相关知识所构成的综合能力。有了财商你才能更好的去赚钱，不过我个人感觉里面的财商算一种钻空子的行为，作者举得最多的例子就是<strong>倒卖房子</strong>，基本每次提到房地产还会顺带出现川普老师的名字，作者还表示要像川老师一样思考，我打算多看看川老师推特，看看能不能从他的只言片语中悟出致富之道，毕竟没有人比川老师更懂什么是富人</p><div align=center>    <img src="https://i.loli.net/2020/06/13/UP8qD7JSTAQG1Wg.jpg" srcset="/img/loading.gif" width="500px" height="375px"></div><p>如果你想致富，你就多购买<strong>资产</strong>，如果你想变穷你就多购买<strong>负债</strong></p><blockquote><p>资产是能把钱放进你口袋里的东西</p><p>负债是能把钱从你空袋里拿走的东西                    ——《富爸爸穷爸爸》第二课</p></blockquote><p>书中有一种现金流图，直观的表示了穷人，中产和富人三个阶级的钱的流动方向</p><p>穷人：</p><p><img src="https://i.loli.net/2020/06/13/1k9rcU3pudxVq2n.png" srcset="/img/loading.gif" alt="poor.png"></p><p>中产：</p><p><img src="https://i.loli.net/2020/06/13/uABOmUyEn8q3GcN.png" srcset="/img/loading.gif" alt="middle.png"></p><p>富人：</p><p><img src="https://i.loli.net/2020/06/13/xS5QZWELnaRsmr3.png" srcset="/img/loading.gif" alt="rich.png"></p><p>贷款买房，很多人可能认为这是一种资产，但你其实买的是抵押贷款(负债)，而非真正的房产，因为它会把钱从你的口袋里拿走。</p><p>这本书里面我觉得最有意思的一部分就是介绍 富人的秘密—<strong>拥有自己的公司</strong>。</p><p>有了一个公司就可以拥有<strong>减税优惠</strong>，因为<strong>企业所得税率远低于个人所得税率</strong>，企业所得税率一般为<strong>25%</strong>，符合条件的小微企业为<strong>20%</strong>。</p><p>个人所得税率，月收入超过<strong>两万五</strong>就需要缴<strong>25%</strong>的税，超过<strong>三万五</strong>需要缴<strong>30%</strong>的税。</p><p>而一个企业月入三万五已经算是小的不能再小的企业了，却只需要缴<strong>20%</strong>的税。如果你能说动你的老板和你签个企业合作协定，把发你的工资变成你的企业所得税，那么每年就可以少缴很多税，如果你每月工资5000￥，那你可以直接不缴税。</p><p>企业还可以用税前收入支付开支，职员是赚钱，缴税，剩余的钱支出，而企业却可以赚钱，花钱，缴税，比如你可以以企业名义先买一辆车，然后买车用剩下的钱去缴税，但是个人却不行，个人得先缴完税，才能用剩下的钱去买车。</p><p>金钱从来都不是资产，头脑才是你真正的资产，投资好它，钱会自动跑进你口袋的。</p><blockquote><p>我们唯一的，也是最重要的资产就是我们的头脑    ——《富爸爸穷爸爸》第五课</p></blockquote><p><strong>公众号 成长的青年 回复：富爸爸穷爸爸，即可获得PDF电子书</strong></p><h2 id="2-《信息资源管理》复习"><a href="#2-《信息资源管理》复习" class="headerlink" title="2.《信息资源管理》复习"></a>2.《信息资源管理》复习</h2><h4 id="第二章-信息规划与组织"><a href="#第二章-信息规划与组织" class="headerlink" title="第二章 信息规划与组织"></a>第二章 信息规划与组织</h4><p><strong>1.组织战略与信息化</strong></p><p>① 组织战略</p><p>定义：是组织达到目标完成使命的综合计划</p><p>② 组织战略与信息化的关系</p><p>组织信息化要以支持战略实现为目的</p><p>信息化是组织战略制定的工具</p><p>信息化效果的好坏或效率高低，已经成为影响组织战略制定和实现的重要因素，信息化是实现组织战略的重要保证</p><p><strong>2.信息化规划内涵、意义和层次</strong></p><p>① 内涵</p><p>为了规避风险，保证信息化建设的成功和健康发展，需要事先对组织信息化进行周密的计划</p><p>② 意义</p><p>(1) 有效管理组织的信息资产，对组织的信息资源进行统筹安排，资源共享，最大限度地避免“信息孤岛”的出现</p><p>(2) 降低信息化建设的整体风险和投资成本</p><p>(3) 使信息技术与组织战略保持一致，增强组织的竞争力 </p><p>(4) 改善业务部门与信息部门间的交流和合作，使信息化工作有序进行</p><p>③ 层次</p><p>战略管理层面——信息化战略规划（含信息基础设施规划）</p><p>管理业务层面——信息资源规划</p><p>技术实现层面——信息化项目规划</p><p><strong>3.信息化战略的内涵</strong></p><p>信息化战略：描述组织信息化建设的方向、重点、步骤和措施等的策略被称为 信息化战略</p><p>信息化战略主要包括三个方面:</p><p>(1) 信息化建设的愿景与架构</p><p>(2) 项目方案选择与组织</p><p>(3) 信息化项目规划</p><p><strong>4.信息化战略规划的内涵、步骤和主要方法</strong></p><p>① 内涵</p><p>以组织战略为指导，以各个部门的业务需求为基础，结合行业信息化方面的实践和对信息化技术发展趋势的掌握，定义出组织信息化建设的远景、使命、目标和战略，规划出组织信息化建设的未来架构——组织结构、信息基础设施架构、信息系统及其集成架构等</p><p>② 步骤</p><p>(1) 基础信息调研</p><p>1) 信息化的现状和发展趋势调研   2) 组织信息化需求调研  3) 信息化建设基础条件调研</p><p>(2) 现状评估与问题分析</p><p>(3) 信息化战略目标设计和制定</p><p>③ 主要方法</p><p>(1) 战略目标集转法</p><p>(2) 价值链分析法</p><p>(3) 关键成功因素法</p><p><strong>5.信息资源规划的产生、内涵和主要任务</strong></p><p>①  产生</p><p>美国学者詹姆斯·马丁等针对维护信息系统所出现的“数据处理危机”，提出了战略数据规划，我国学者高复先生在继承前人工作的基础上，提出了信息资源规划的概念</p><p>② 内涵</p><p>进行总体数据规划的过程中，同时进行数据管理标准化工作，通过数据标准化工作使总体数据规划更为扎实</p><p>信息资源规划的核心就算基于实体数据分析和主题数据库设计的总体数据规划</p><p>信息资源规划使对组织管理或经营活动所需要的信息，从产生、获取、到处理、存储、传输及利用进行全面的规划</p><p>③ 主要任务</p><p>(1) 业务分析  (2) 主题数据库与数据标准化</p><p><strong>6.信息化项目规划的内涵和工作内容</strong></p><p>① 内涵</p><p>指利用项目管理方法和工具，在项目实施前，对其所作的范围、进度、成本、质量等进行全面计划</p><p>② 工作内容</p><p>(1) 范围计划</p><p>对信息化项目最终交付物及工作范围的说明</p><p>(2) 进度计划</p><p>制定切合实际的项目时间计划</p><p>(3) 成本计划</p><p>在保证满足工程质量、工期等合同要求前提下，对项目实施过程中所发生的费用进行估算的管理活动</p><p><strong>7.信息化组织机构与CIO机制</strong></p><p>① 信息化组织机构</p><p>广义： 指整个组织机构。</p><p>狭义： 指专门负责信息化管理的机构，也称信息部门或IT部门</p><p>② CIO机制</p><p>CIO是专门负责组织信息化建设、实施和运作的管理者，通常是组织决策层的成员。</p><p>CIO机制则是组织信息化发展比较成熟以后的一种信息化管理机制</p><h2 id="3-继续夜读"><a href="#3-继续夜读" class="headerlink" title="3.继续夜读"></a>3.继续夜读</h2><p>坚持夜读，这个月有望将《管理经济学》看完，然后进入快乐的刷题环节，我超喜欢这个环节，刷题会让我有种重回应试教育温暖的怀抱错觉，只是没有老师给我布置要考的题目了，得自己去网上翻以前的考试题目。</p><h2 id="4-梦想储蓄罐"><a href="#4-梦想储蓄罐" class="headerlink" title="4.梦想储蓄罐"></a>4.梦想储蓄罐</h2><p>上周的两个梦想储蓄罐，一个《经济学原理》—曼昆，一个《社会心理学》—戴维，我从神奇的互联网上找到了这两本书。</p><p>如果实体书带在地铁上看会给人格格不入的感觉，毕竟大家都在看手机，所以我还是不搞特殊了，去找了PDF版，放在手机里，有时间就安排。</p><p>到时候写读书笔记的时候再把这两本书丢到公众号里面，分享给各位读者。</p><h2 id="5-Keep"><a href="#5-Keep" class="headerlink" title="5.Keep"></a>5.Keep</h2><p>这周完成两个课程，<strong>腹肌塑造强化</strong>和<strong>篮球弹跳</strong>👇</p><div align=center><img src="https://i.loli.net/2020/06/13/jUbXD2MvJwQm3qG.jpg" srcset="/img/loading.gif" ></div>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（四）</title>
    <link href="undefined2020/06/07/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-4/"/>
    <url>2020/06/07/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-4/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（四）"><a href="#成功日记（四）" class="headerlink" title="成功日记（四）"></a>成功日记（四）</h1><h2 id="1-坚持夜读一周"><a href="#1-坚持夜读一周" class="headerlink" title="1.坚持夜读一周"></a>1.坚持夜读一周</h2><p>上周的<strong>成功日记（三）</strong>里我提出要进行夜读，我没食言，坚持了一周夜读。</p><p>因为八月份要自考的关系，所以我夜读都在复习自考的知识，我还打算将我所学的知识写进成功日记里面，之后可能会每一本书要给它整理成一篇单独的笔记发布到我的博客和公众号内。</p><p>咱不能白买了这些书对吧，不获得点什么我会觉得自己亏。</p><p><img src="https://i.loli.net/2020/06/06/XkDOtvHoCbj1Y7L.jpg" srcset="/img/loading.gif" alt="kui.jpg"></p><h2 id="2-《爱的博弈》阅读笔记"><a href="#2-《爱的博弈》阅读笔记" class="headerlink" title="2.《爱的博弈》阅读笔记"></a>2.《爱的博弈》阅读笔记</h2><p><strong>信任重建</strong>(出轨后的救赎)：弥补、协调、接触</p><ul><li><p>弥补：</p><p>这个阶段也可称之为“赎罪”。出轨的一方要持续表现出后悔之意且要直面伴侣的怀疑。有了这个作为基础才有重建信任的可能。此时，出轨一方必须保持耐心不能申辩，要接受伴侣的一切指责，承担一切责任。要倾听伴侣诉说的痛苦，并尽力去理解。如果出轨的一方不能承担所有责任，为自己找借口或申辩，那么双方就很难再重建信任了。</p><p>弥补三步骤：</p><p>1.坦白</p><p>背叛一方若被伴侣责问，必须如实回答。问题可能有，为什么是他/她？她比我漂亮吗？出轨是怎么开始的？怎么进行的？这个时候背叛的一方必须详细描述每一次幽会的时间，地点等细节。这种全盘交代可能会使双方不安，如果不想加深伤害，全盘交代是十分必要的。</p><p>2.行为转变、透明和验证</p><p>意味着背叛一方必须允许自己的伴侣检查自己的日程表，电话记录和银行卡账单等。这类行为是对个人隐私的侵犯，看似不公平，其实是必需的。如果你不能像你的伴侣长期且频繁的提供你忠贞的<strong>证据</strong>，你就不能赢回他/她的信任。</p><p>3.开始原谅</p><p>受伤的一方接受道歉，开始逐渐原谅伴侣的过错，但这不意味着就此免罪。这里的原谅是试着重新给予一些信任。作者用了博弈论中最出名的<strong>囚徒困境</strong>来说明，背叛后的感情重建上来了，才能达成双方最大利益。</p></li></ul><ul><li><p>协调：</p><p>第一阶段表现出“试探性”的宽恕之后，双方就可以一起重建关系了，双方要互相理解，要让伴侣知道自己内心深处的悲伤，黑暗和脆弱。要学会控制冲突，可以使用<strong>戈特曼-拉波波特蓝图</strong>（在促成对立双方开展合作时，如果你不能陈述对方的观点并且令其满意，就不要妄想说服对方、解决问题或达成共识）。重建关系后要将“最新协定”告知亲近之人，比如孩子，兄弟姐妹或亲密的朋友。</p></li></ul><ul><li><p>接触：</p><p>这里的接触指的是<strong>sex</strong>，完全重建关系，仅仅是“宽恕”是不够的，必须重回卧室。</p></li></ul><p>这本书基本就快看完了，虽然写的是婚恋关系方面的问题，但里面蕴含的人际关系道理可以通用，像<strong>戈特曼-拉波波特蓝图</strong>就可以用在日常工作生活中，作为和人打交道的一个好方法。</p><p>本书的后几章作者都在讲<strong>sex topic</strong>，这个是爱情的润滑剂，这种联系可以有效阻止外来诱惑。</p><p>碍于我国国情问题，我就不写这方面的内容了 <del>怕我号没了</del>。</p><p><img src="https://i.loli.net/2020/06/06/YqBofd2JDnwHVjO.jpg" srcset="/img/loading.gif" alt="AccountNotExit"></p><p><strong>公众号 成长的青年 回复：爱的博弈，即可获得PDF电子书</strong></p><h2 id="3-《信息资源管理》复习"><a href="#3-《信息资源管理》复习" class="headerlink" title="3.《信息资源管理》复习"></a>3.《信息资源管理》复习</h2><h4 id="第1章-信息资源管理基础"><a href="#第1章-信息资源管理基础" class="headerlink" title="第1章 信息资源管理基础"></a>第1章 信息资源管理基础</h4><p><strong>1.信息技术及其应用和发展趋势</strong></p><p><strong>信息技术(Information Technology，简称IT)</strong>是应用信息科学的原理和方法研究信息产生、传递、处理的技术。</p><p>发展趋势：</p><p>① 数字化 ②小型化 ③网络化 ④智能化 ⑤系统化</p><p><strong>2.信息革命的特点和影响</strong></p><p>特点：① 技术科学化 ② 群体化 ③ 智能化 ④ 高新性</p><p>影响：信息技术的发展完全改变了人类社会的面貌，深刻影响着社会的组织、经济、文化、政治等多个方面，信息技术的水平、规模和应用程度以及成为衡量一个国家现代化程度的重要标志。</p><p><strong>3.不同角度下的信息化内涵</strong></p><p>① 信息化是指信息技术在国民经济和社会生活中逐步应用的过程</p><p>② 信息化是继农业化、工业化之后人类生存和发展的一个历史阶段，其结果是导致人类进入信息化</p><p>③ 信息化是政府促进经济发展和社会进步的重要战略；国家信息化包含领域信息化、区域信息化、企业信息化和家庭个人信息化等多个层面</p><p>④ 信息化是各级社会组织为顺应社会发展潮流而从事的应用信息技术提高信息资源开发和利用效率的活动</p><p><strong>4.信息的概念</strong></p><p>信息被定义为：事物运动的状态和状态变化方式的自我表述或自我显示</p><p><strong>5.信息的性质与分类</strong></p><p>性质：① 信息是普遍的无限的 ② 信息依附于媒体且可以独立于源事物 ③ 信息可以共享 ④ 信息可以变换 ⑤ 信息可以传递但不可以增值 ⑥ 信息是动态且有时效的 ⑦ 信息是具体而可以被感知和处理的</p><p>分类：<br>（1）按信息介质分</p><p>磁介质信息( 磁盘，磁带)、电介质信息( 电路)、光介质信息(光盘)、声介质信息(录音设备)、实体介质信息(实物和人)</p><p>（2）按信息表现形式分</p><p>文字信息、图像信息、声音信息、气味信息、形态信息</p><p>（3）按信息记录方式分</p><p>记录型信息(笔记，电视录播)、智力型信息(设计师的灵感、企业员工的技能等)</p><p>（4）按信息源顺序或信息效用层次划分</p><p>迹象、事实、知识、智能</p><blockquote><p>一位司机在汽车运行中发现前方有异物，这就是”迹象”，司机进一步发现或被告知道路有塌方现象，这属于”事实“，连日下雨是导致塌方的原因，属于”知识“，找到其他路线绕过塌方，属于”智能“</p></blockquote><p> （5）按信息生成范围划分</p><p>宇宙空间、自然界、人类社会、人类思维</p><p>（6）按应用领域分</p><p>政府信息、企业信息、工业信息、农业信息、军事信息、商业信息、科教信息、文化信息等</p><p><strong>6.信息的测度方法、功能、过程</strong></p><p>测度方法：</p><p>常用单位包括：B(字节)、KB(KiloByte,千字节)、MB(MegaByte,兆字节)、GB(GigaByte,吉字节)、TB(TeraByte)、PB(PeraByte)和EB(ExaByte)</p><p>1B = 8bits</p><p>1KB = 1024B</p><p>1MB = 1024KB</p><p>1GB = 1024MB</p><p>1TB = 1024GB</p><p>1PB = 1024 TB</p><p>1EB = 1024 PB</p><p>信息功能： 信息是存在的资源、信息是知识的源泉、信息是决策的依据、信息是控制的灵魂、信息是思维的材料、信息是实际的准绳、信息是管理的基础、信息是组织的保证</p><p>信息过程：信息获取、信息传递、信息加工、信息再生、信息施效 </p><p><strong>7.资源及其经济属性；狭义和广义信息资源的概念；信息资源的特性和分类</strong></p><p>资源 指在自然界和人类社会生活中一种可以用来创造物质财富和精神财富，并且拥有一定量积累的客观存在形式</p><p>经济属性：① 需求性 ② 稀缺性 ③ 可选择性</p><p>狭义信息资源：指人类社会经济活动中经过加工处理有序化并大量积累的有用信息集合</p><p>广义信息资源：包括信息及其生产者、信息技术的集合</p><p>信息资源特性：① 不可分性 ② 积累下或非消耗性 ③ 认知相对性 ④ 不同一性 ⑤ 驾驭性</p><p>信息资源分类：</p><p>（1）按社会组织划分：政府信息资源、企业信息资源和公共信息资源</p><p>（2）按增值状况划分：基础性信息资源 和 增值性信息资源</p><p>（3）按可利用范围不同划分：公有信息资源、专有信息资源、个人信息资源</p><h2 id="4-新增两个梦想储蓄罐"><a href="#4-新增两个梦想储蓄罐" class="headerlink" title="4.新增两个梦想储蓄罐"></a>4.新增两个梦想储蓄罐</h2><p>新增两个小梦想，一个是曼昆的《经济学原理》上下两册，一个是迈尔斯的《社会心理学》</p><div align=center><img src="https://i.loli.net/2020/06/07/WGJrtXjneh2imky.jpg" srcset="/img/loading.gif"/></div><p><img src="https://i.loli.net/2020/06/07/4CJNx5dmeQBigP3.jpg" srcset="/img/loading.gif" alt="dream3.jpg"></p><h2 id="5-Keep"><a href="#5-Keep" class="headerlink" title="5.Keep"></a>5.Keep</h2><p>这周做了两个课程，<strong>篮球弹跳</strong>和<strong>超级胸肌训练</strong>👇</p><p><img src="https://i.loli.net/2020/06/07/bxPyXuRohBL14G8.jpg" srcset="/img/loading.gif" alt="keep.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（三）</title>
    <link href="undefined2020/05/31/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-3/"/>
    <url>2020/05/31/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-3/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（三）"><a href="#成功日记（三）" class="headerlink" title="成功日记（三）"></a>成功日记（三）</h1><h2 id="1-梦想储蓄罐"><a href="#1-梦想储蓄罐" class="headerlink" title="1.梦想储蓄罐"></a>1.梦想储蓄罐</h2><p>周四的时候，我的<strong>梦想储蓄罐</strong>终于迎来了第一笔储蓄，虽然不多，但这第一笔储蓄意义重大，代表我拥有了<strong>钞能力</strong>（管理钱的能力）。</p><p>很庆幸因为梦想储蓄罐的存在，没有使自己变成所谓的<strong>精致穷</strong>，掉入资本主义的消费陷阱当中。</p><p>人可以有欲望，欲望是人类的本能，但我们要学会的是控制欲望，不能被欲望主导自己的行动，看到想看的东西就要买，看到想吃的东西就要吃，实在想买，也不要用花呗，借呗之类的贷款应用，透支自己未来，然后变成<strong>精致穷</strong>。可以开个梦想储蓄罐，然后自己存钱到梦想储蓄罐，钱够再买，就像自己给自己分期贷款一样，还不要付利息，自己成为自己债主，这种主宰自己的感觉不是很爽吗？</p><p>绝不当<strong>韭浪</strong>！！！</p><p><img src="https://i.loli.net/2020/05/30/Ii5HTA6ahjPdO8p.jpg" srcset="/img/loading.gif" alt="韭菜.jpg"></p><h2 id="2-购买基金"><a href="#2-购买基金" class="headerlink" title="2.购买基金"></a>2.购买基金</h2><p><strong>基金：</strong>你把钱投给某个基金机构，然后由这个机构的基金经理人来购买金融资产如股票、债券、外汇、期货等，众筹买资产，盈利了大家就分红。</p><p>购买基金的好处是什么呢？</p><p>假设你用<strong>1000￥</strong>以每股<strong>100￥</strong>的价格购买了<strong>10股</strong>腾讯的股票。但现在这只股票跌了40%，于是你不能再以每股100￥，而只能以每股<strong>60￥</strong>(60% x 100￥)卖出去，如果你把它全卖了，那么你就只剩下<strong>600￥</strong>了。</p><p>而股票型基金则至少会购买<strong>10种</strong>股票，还是以<strong>1000￥</strong>为例，假设现在用这些钱购买了10种不同的股票，除了腾讯还买了阿里，京东之类的，腾讯的股票跌了40%，而其他股票还保持原来的水平，那么我们还有<strong>960￥</strong>（1000￥ - 100￥ x 60%），这样你就只损失<strong>4%</strong>。而实际情况，可能会跌几只股票，但总体还是涨的。</p><blockquote><p>挑选基金时的注意事项:</p><p>1    基金至少有十年历史。假如它在这么长时间内一直有丰厚的盈利，那么我们认为，它在未来十年也将运作良好。</p><p>2    应该选择大型的跨国股票基金。这种基金在是世界各地购买股票，以此分散风险，所以十分安全。</p><p>3   对基金走势图进行比较，我们应该观察在过去10年间哪些基金获利最好。</p><p>  ————摘自《小狗钱钱》第十六章</p></blockquote><p>这三个规则不一定在中国内地完全适用，但可以作为参考。</p><p>如果你要买基金我推荐<strong>支付宝</strong>，里面可以看基金排行和基金机构的信息。</p><p>我就是以这三个原则为基础，去支付宝投了四只不同类型的基金，包括指数型，债券型，股票型和混合型。</p><p>希望股神保佑，让我赚点小钱🙏🙏🙏</p><p><img src="https://i.loli.net/2020/05/30/63R971QJpYnvVOU.jpg" srcset="/img/loading.gif" alt="Buffett.jpg"></p><h2 id="3-开始夜读"><a href="#3-开始夜读" class="headerlink" title="3.开始夜读"></a>3.开始夜读</h2><p>前不久刚刚关注了<strong>人民日报</strong>公众号，每天23：00都会给大家推送夜读推文，里面都是非常正能量的文章，关于交友，自律，人生等等。刚好我上次又买了些书，不看那不就浪费了吗? </p><p>于是我给自己也来个夜读，每天晚上1个小时，从22：00到23：00，顺便写写读书笔记，水一下成功日记，一举多得。</p><p>芜湖，起飞~</p><p><img src="https://i.loli.net/2020/05/30/hLKd9uyIiS6fQgb.jpg" srcset="/img/loading.gif" alt="book.jpg"></p><h2 id="4-《爱的博弈》阅读笔记"><a href="#4-《爱的博弈》阅读笔记" class="headerlink" title="4.《爱的博弈》阅读笔记"></a>4.《爱的博弈》阅读笔记</h2><p><strong>出轨是怎样产生的？</strong></p><p>1.忽略或轻视另一边的情绪</p><p>当生活发生重大变化时，比如父母去世，疾病或子女出现问题。此时，双方背景，理念和性格差异变得格外突出。如果一个人发出连接请求，却发现另一个人“不见了”，此时双方不能就这件事坐下来开诚布公的谈谈的话，那么失望孤独就会泛滥，造成双方信任水平降低，伴侣们为了不让情况变得更糟，就会尽量避免冲突，从而产生<strong>蔡格尼克效应</strong>(指人们对于尚未处理完的事情，比已处理完成的事情印象更加深刻)</p><p>2.消极对比（Negative COMP）</p><p>如果一个男人对他爱的妻子微笑，她也回应一个，他可能会想：“噢，笑的多美啊。她让我没办法再爱上别的女人。”但是过几天，她的微笑可能没有那么灿烂了，这就会使那个男人失望，这时他可能会想：“哼！我在调情，她都没反应！我打赌那边的辣妹一定比她有反应。”这种看起来无关紧要的消极对比并不会伤害感情，但这种想法次数多了，就会导致疏远，最终奔向背叛的深渊。</p><blockquote><p>伴侣出轨不是一夜之间的事，他们是在不知不觉种以一种缓慢到无法察觉的速度滑向这条不归之路的。从不再信任彼此，到找到新的知己，再到突破底线，婚恋关系本身才常常是导致外遇的原因。 ————摘自《爱的博弈》第三章</p></blockquote><p><strong>公众号 成长的青年 内回复：爱的博弈，即可获得PDF电子书</strong></p><h2 id="5-Keep"><a href="#5-Keep" class="headerlink" title="5.Keep"></a>5.Keep</h2><p>这周三个课程都给他做完咯👇</p><p><img src="https://i.loli.net/2020/05/31/dfjoiblZtV5LWqz.jpg" srcset="/img/loading.gif" alt="Keep.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（二）</title>
    <link href="undefined2020/05/24/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-2/"/>
    <url>2020/05/24/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（二）"><a href="#成功日记（二）" class="headerlink" title="成功日记（二）"></a>成功日记（二）</h1><h2 id="1-规划自己的理财计划"><a href="#1-规划自己的理财计划" class="headerlink" title="1.规划自己的理财计划"></a>1.规划自己的理财计划</h2><p>首先，收入的50%拿来养我的鹅，如果不知道鹅是什么，请参考我的<strong>成功日记(一)</strong>，</p><p>剩下的50%中<strong>减1200￥</strong>每月的生活开支，这还是没付房租的情况，如果自己租房起码还得再<strong>加1000￥</strong>，变成<strong>2200￥</strong></p><p>最后剩下的钱，放进<strong>梦想储蓄罐</strong>中</p><p>这里有的朋友可能就要问了那什么是<strong>梦想储蓄罐</strong>呢？</p><blockquote><p>“随便拿一个罐子，作为储蓄罐。然后在这个罐子上写上你的梦想。要为每一个梦想准备一个储蓄罐，一旦储蓄罐准备好，你就应当把省下的每一分钱放进去。”———摘自《小狗钱钱》第二章</p></blockquote><p>我不会真的傻傻的真拿瓶瓶罐罐来，我自己用微信收藏功能建了一篇笔记，用来当我的梦想储蓄罐，一篇笔记对应一个梦储蓄罐，并配上<strong>梦想相册</strong>(也是小狗钱钱里的概念)：</p><p><img src="https://i.loli.net/2020/05/24/IxSPyvBjtHJEAu4.jpg" srcset="/img/loading.gif" alt="note8.jpg"></p><h2 id="2-《爱的博弈》阅读分享"><a href="#2-《爱的博弈》阅读分享" class="headerlink" title="2.《爱的博弈》阅读分享"></a>2.《爱的博弈》阅读分享</h2><p><img src="https://i.loli.net/2020/05/23/Vsb6KOaQwp3dfLU.png" srcset="/img/loading.gif" alt="LoveBook.png"></p><p>这本书讲教你如何经营婚恋关系，以及处理婚姻问题。</p><p>（关注公众号“<strong>成长的青年</strong>”，回复：爱的博弈，即可获取电子书）</p><p>下面分享一些概念：</p><p><strong>滑动门时刻(sliding door moment)：</strong>当一个人表达出联结的需要时，另一个人的反应可以是拉开门走过去，也可以是关上门转身离开。这是发展亲密关系的关键时刻。</p><ul><li>“我看起来怎么样？” （注意听我说话）</li><li>“你站起来时能顺便帮我把调味酱拿过来吗？”（答应我的小请求）</li><li>“咱们现在去把珍妮哄上床吧”（帮助我，或者和我一起做）</li><li>“你觉得我做的怎么样”（对我的成就表现出兴趣和兴奋）</li><li>“你能帮我填这张表吗？”（回答我的问题，为我提供信息）</li><li>“我要和你说我妈打电话过来发生的事”（和我聊天）</li><li>“工作室有什么趣事/麻烦吗？”（与我分享你今天的经历）</li><li>“不知道我跟你说过没有？”（对我讲的趣事有所回应）</li><li>“我觉得我今天演讲搞砸了”（帮我减压）</li><li>“你觉得我应该怎么对付老板”（帮我解决问题）</li><li>“过来嘛，我想看书的时候被你抱着”（表现亲昵之情）</li><li>“咱们来玩大富翁吧”（陪我玩）</li><li>“咱们来学英语吧！”（跟我一起学习）</li></ul><p>以上都是一些滑动门时刻，处理好了就会达成“面向(turing towards)”伴侣，你们的感情会升温，更亲密，处理不好那就是“背向（turing away from）”伴侣，不重视这些婚恋关系中的小要求，经年累月下去就会使其中一方产生信任危机，最终结果就是这段关系掉入深渊。</p><p>该书的作者为<strong>约翰 戈特曼</strong>，他对人际关系、婚姻关系及家庭关系进行了长达40年的研究。被美国媒体誉为 <strong>“婚姻教皇”</strong>。</p><p>看这本书也就图一乐，真想学恋爱还得看我网恋教父-孙笑川</p><p><img src="https://i.loli.net/2020/05/23/YqfKElFMI26cXN1.png" srcset="/img/loading.gif" alt="SunDog.png"></p><h2 id="3-想要变富裕的十个理由"><a href="#3-想要变富裕的十个理由" class="headerlink" title="3.想要变富裕的十个理由"></a>3.想要变富裕的十个理由</h2><p>1.获得钞能力(掌控钱的能力)💴</p><p>2.买个小房子🏠</p><p>3.整台小车子🚗</p><p>4.恰饭，吃遍各种美食🍔</p><p>5.买自己喜欢的科技产品💻</p><p>6.发展自己的兴趣爱好🎮</p><p>7.买书📕</p><p>8.环游全世界🌏</p><p>9.找老婆👧</p><p>10.为国家做点微小的贡献🀄</p><p>子曰：富而可求也，虽执鞭之士，吾亦为之 ——论语 述而，这句话的意思是，如果是合乎道义的财富，虽然只是做个“执鞭之士”，我也会去做，这里的“执鞭之士”指的是 市场守门人，现代人称保安。</p><p>大圣人孔子都认为合义的财富是可以追求的，即使是做一个保安，那么你还有什么理由不变富呢？</p><p><img src="https://i.loli.net/2020/05/23/73OlavspNwCDzrI.png" srcset="/img/loading.gif" alt="Security.png"></p><h2 id="4-公众号被关注"><a href="#4-公众号被关注" class="headerlink" title="4.公众号被关注"></a>4.公众号被关注</h2><p>上周发了成功日记（一），本来是写给自己的看的，却胆儿肥<del>不要脸</del>的发到了朋友圈，丢给了别人看，还有好兄弟给我点了关注🙏</p><p>每次写东西的过程中我都蛮享受的，沉浸在自己的世界之中，写出想讲的话，表明想表的意，配出合理的图，图文并茂的文章比纯文字文章更给我一种有理有据的感觉。</p><p>写的不好被骂了，就当练习受挫能力，写的好，被夸了，那就继续加油！</p><p>无论怎样，我都不亏。</p><p><img src="https://i.loli.net/2020/05/24/Kf7OtvI8HAouSmq.jpg" srcset="/img/loading.gif" alt="DaSiMa.jpg"></p><h2 id="5-继续Keep"><a href="#5-继续Keep" class="headerlink" title="5.继续Keep"></a>5.继续Keep</h2><p>这周做了<strong>超级胸肌训练</strong>和<strong>腹肌塑造强化</strong>，国际惯例</p><p><img src="https://i.loli.net/2020/05/24/BhaRfnFbDLiMrUp.jpg" srcset="/img/loading.gif" alt="sports.jpg"></p><p>我练的这三个运动都是徒手的，为啥不买健身器材或去健身房呢？一个字，穷。看B站的时候刷到美国人街头健身，人家在街头都可以练出好看的肌肉，我难道不能自己在家徒手练吗？健身没有借口只有你想不想，是否坚持。</p><p>有位大佬，自己在家坚持健身，明明八十多岁了看起来却还像五十岁的小伙子似的，那就是钟南山院士，以院士为目标，希望等我到那个年纪能赶得上他一半</p><p><img src="https://i.loli.net/2020/05/24/veWgNBlTuUPtDEd.jpg" srcset="/img/loading.gif" alt="keep.jpg"></p><h2 id="6-签三方协议"><a href="#6-签三方协议" class="headerlink" title="6.签三方协议"></a>6.签三方协议</h2><p>我们学校规定每个学生去公司工作都要签三方协议，即学生，企业，学校的共同协议，该协议是为了保障学生权益，签完还可以领取深圳市社保局的<strong>就业补贴</strong>。</p><p>我们公司有点特殊，签的是第三方劳务派遣协议，劳务派遣公司不同意合同中的一条，所以没答应和我签</p><p>后来，我们公司人事直接去和系里领导沟通，弄了份新的三方协议。</p><p>我在第一层，而我把我公司想成了第二层，其实公司在第五层，老千层饼了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（一）</title>
    <link href="undefined2020/05/16/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-1/"/>
    <url>2020/05/16/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（一）"><a href="#成功日记（一）" class="headerlink" title="成功日记（一）"></a>成功日记（一）</h1><h2 id="1-阅读完《小狗钱钱》"><a href="#1-阅读完《小狗钱钱》" class="headerlink" title="1.阅读完《小狗钱钱》"></a>1.阅读完《小狗钱钱》</h2><p><del>这是本好书。</del></p><p><del>完。</del></p><p>开个小玩笑，下面我要开始BB了</p><p>这本书是欧美最畅销的<strong>财富启蒙书籍</strong>，归类为童话书籍，是给孩子看的，这本书要表达的观点也很简单，让你自己变的富有吧！</p><p>故事讲的是一个叫吉娅的小女孩，她有一条会说话的狗叫——钱钱，然后吉娅在钱钱的帮助下达到人生巅峰，变成了一个富婆！！！</p><p>总结起来就是这么简单。</p><p><img src="https://i.loli.net/2020/05/16/yGHN3DX8EsrecWY.jpg" srcset="/img/loading.gif" alt="rich woman.jpg"></p><p>从小到大我周围的人他们都告诉我，有钱人都是坏人。他们剥削劳动人民；他们爱装，喜欢炫富；他们欺骗消费者；他们还老是出轨（并没有针对强东的意思）；总之，他们无恶不作。每个人都在骂有钱人，但每个人又都想成为有钱人。</p><p>《小狗钱钱》这本书虽然只是一本童话书籍，但里面涉及到的概念却是成年人看了都受益匪浅。</p><ul><li><p><strong>正确的金钱观</strong></p><p><strong>钱是中性的，钱本身没有属性，它不会让一个人变得幸福，也不会带来不幸，但它会暴露一个人的本性。</strong></p><p>比如，小马哥和我，同时获得一个亿，且获得这一个亿是完全无代价的<del>不需要向富婆卖身</del>，我可能会用这一个亿去买豪宅、开豪车、把英雄联盟和王者荣耀全英雄全皮肤都给他买了、请个米其林厨师团伙专门做饭给我吃、还要去澳门赌场看美女荷官在线发牌、请美女女仆在家拖地，总之各种享受，然后等钱花完了就混吃等死。</p><p>人家小马哥却会拿这一个亿，让企鹅公司在招点游戏开发人才，开发好玩的游戏，让英雄联盟或王者多发布几个又好看又贵的皮肤，然后把我和其他人的钱都赚走。</p><p>看到了吗？这就是会用钱在不同人手里的结果。</p><p><img src="https://i.loli.net/2020/05/16/YCEUPx7MqitBrs2.jpg" srcset="/img/loading.gif" alt="mht1.jpg"></p></li><li><p><strong>养一只自己的鹅</strong>(会下金蛋的那种）</p><p>其中鹅是你的<strong>储蓄</strong>，金蛋就是<strong>利息</strong>，大多数人没有会下金蛋的鹅，是因为他们觉得需要很多钱，反正存不了那么多钱，不如破罐子破摔，花掉得了。</p><p>其实你需要的钱比你想象的要少的多，如果你有30万，而你能得到12%的利息，那你每年利息就是36000￥，每个月就是3000￥，而利息12%靠合理投资是可以实现的，看吧，没你想的那么难，假设你每个月工资5000￥，你一年就是6万，然后你每个月将一半的工资都存起来养你的鹅，那么十年后你就有30万了，存钱期间你还可以拿你存的钱去投资，所以不用十年30万就能到手，然后再拿这30万去投资，再等十年，能赚多少？60万？100万？</p><p>做着干嘛，还不去楞？</p></li></ul><h2 id="2-开始写成功日记"><a href="#2-开始写成功日记" class="headerlink" title="2.开始写成功日记"></a>2.开始写成功日记</h2><blockquote><p>“你拿一个空本子或者一本日记本，给它取个名字叫做 ‘成功日记‘ 。然后你就把所有做成功的事都记录进去。你最好每天都做这件事，每次至少写五条你个人的成果。任何小事都可以。开始的时候也许你觉得不太容易。也许你会问自己，这件或那件事情是否真的可以算作成果。在这种情况下，你永远应该做出肯定的回答。过于自信总好过没有自信“  ———摘自《小狗钱钱》第三章</p></blockquote><p>成功日记也是我从《小狗钱钱》里看到的，这个日记最大的作用就是可以帮你<strong>树立自信心</strong>。</p><p>其实现实中很多看似不可能的事，比如减肥，赚钱，别人可以做到，你也可以，你不成功的原因，可能只是少了一点点自信心而已。</p><p>我以后每个星期会将我的成功日记写出来，用我的键盘写，我的字太丑，太恶心，写出来的日记自己都不敢看。</p><p>每个人都是充满能量的炸药包，只不过缺乏一段引线，成功日记就可以做你的引线激发出你的潜能，如果你坚持的写它的话，一段时间后你就会变成一个充满自信的人。</p><p><img src="https://i.loli.net/2020/05/16/roewuIlMXUkVgWH.jpg" srcset="/img/loading.gif" alt="Thumbs.jpg"></p><h2 id="3-做完Keep中自己的课程"><a href="#3-做完Keep中自己的课程" class="headerlink" title="3.做完Keep中自己的课程"></a>3.做完Keep中自己的课程</h2><p>我的Keep中只参加了三个课程：</p><p><strong>腹肌塑造强化（K4）,</strong> <strong>超级胸肌训练-老韩霸气（K4）,</strong> <strong>篮球弹跳-稳定性（K3）</strong></p><p><img src="https://i.loli.net/2020/05/16/X1eZo5ykdULwlDs.jpg" srcset="/img/loading.gif" alt="Keep1.jpg"></p><p>我的课程很少，但有时候少即是多，之前我刚用Keep的时候收藏了很多课程，比如，人鱼线塑造，腹肌撕裂者等等，但最后都没练，只是把它放在那里，而且也没有那么多时间去练那些课程，健身的目的在于<strong>持之以恒，培养自律</strong>，而不是看你健身的课程的多少，所以我就把那些课程全部取消，只留下我觉得对我最有用的三个课程。</p><p>这三个课程我以九天为一个周期，比如1号做 腹肌塑造强化，做完休息两天(2号，3号)，然后4号做 超级胸肌训练，再休息两天(5号，6号)，接着7号做篮球弹跳，休息两天，又开始做 腹肌塑造，这是我的锻炼方式，并且我已经坚持一年了。大家也可以安排适合自己的锻炼方式，课程不一定要很多或者难度很高，但一定要<strong>坚持训练</strong>。</p><p><strong>加油，奥利给，更自律的人更自由！</strong></p><p><img src="https://i.loli.net/2020/05/16/pBHkI74oK8qWO3G.jpg" srcset="/img/loading.gif" alt="Ohligei.jpg"></p><h2 id="4-将公众号用起来"><a href="#4-将公众号用起来" class="headerlink" title="4.将公众号用起来"></a>4.将公众号用起来</h2><p>我的公众号2019年就申请了，本来是想用来做微信开发的，结果发现微信开发要商业用户，也就是要有个自己的公司才能进行开发，于是后面我又打算拿它来做写技术文章，但我用微信公众号的编辑页面，用的不顺手，和简书，知乎一比，不够方便，然后就没有然后了，其实自己懒也算一个原因。</p><p>想写公众号主要是受到B站一个up主的影响—— <strong>半佛仙人</strong>。一个有趣的大胖子，很皮，喜欢说一些无厘头的话，入坑是看他讲 <strong>瑞辛咖啡如何暴打资本主义</strong>，如何噶资本主义韭菜，建议没看过的童鞋的可以安排一下真的很有意思，保证你会喜欢上这个爱<strong>叫观众老公</strong>的男人(被别人叫我老公会感觉有一点点羞耻呢)。</p><p>反正我的公众号闲着也是闲着，不如就把我的成功日记丢里面给人看好了，就算没人看，自己在网络上有一块属于自己的小天地，我可以在这里疯狂造作也不失为一种乐趣不是吗？</p><p><strong>现实中我唯唯诺诺，网络上我重拳出击！！！</strong></p><p>键盘侠的快乐往往都是这么的朴实无华且枯燥。</p><p><img src="https://i.loli.net/2020/05/16/ktbMNDCSWIrmJ3g.png" srcset="/img/loading.gif" alt="KeyboardMan.png"></p><h2 id="5-给看完的读者大人们分享资源"><a href="#5-给看完的读者大人们分享资源" class="headerlink" title="5.给看完的读者大人们分享资源"></a>5.给看完的读者大人们分享资源</h2><p><strong>《小狗钱钱》PDF电子书：</strong><br>链接：<a href="https://pan.baidu.com/s/1KX3IgWaNt2_agFkaDODFzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1KX3IgWaNt2_agFkaDODFzw</a><br>提取码：xdkc</p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop(二):Hadoop单节点环境搭建</title>
    <link href="undefined2020/04/19/Hadoop-2-Hadoop%E5%8D%95%E8%8A%82%E7%82%B9%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>2020/04/19/Hadoop-2-Hadoop%E5%8D%95%E8%8A%82%E7%82%B9%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Hadoopd单节点环境搭建"><a href="#Hadoopd单节点环境搭建" class="headerlink" title="Hadoopd单节点环境搭建"></a>Hadoopd单节点环境搭建</h1><h2 id="Hadoop运行环境"><a href="#Hadoop运行环境" class="headerlink" title="Hadoop运行环境"></a>Hadoop运行环境</h2><ul><li>操作系统：Linux(CentOS 7) </li><li>Java环境：jdk1.8+</li><li>Hadoop环境：CDH5.x.x</li><li>SSH</li></ul><p>如果你没服务器，可以自己用<strong>VMware</strong>搭一个<strong>Linux CentOS 7</strong>系统环境</p><p>虽然，Hadoop是一个分布式框架，但是我们学习的时候没必要一上来就一定要搭个集群，这样到时候还没开始学，搭集群环境的报错就先让你放弃了，可谓，从入门到放弃，这里建议，先学单节点(一台服务器)的Hadoop，等你学会了之后，你再去搭集群操作，就会发现原来也不是很难，千万不要一口吃成大肥仔🐷</p><h2 id="安装JAVA环境"><a href="#安装JAVA环境" class="headerlink" title="安装JAVA环境"></a>安装JAVA环境</h2><p><a href="https://growthlj.github.io/2020/03/04/Linux-4-安装JAVA环境/" target="_blank" rel="noopener"><strong>请参考这篇文章：Linux安装JAVA环境(jdk1.8)</strong></a></p><h2 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h2><p><a href="https://growthlj.github.io/2020/03/09/Linux-5-安装SSH/" target="_blank" rel="noopener"><strong>请参考这篇文章：SSH免密登录</strong></a></p><p>这里要注意的是，因为配置的是单机版的Hadoop，所以你要免密登录本机</p><pre><code class="bash">$ ssh localhost</code></pre><h2 id="安装CDH"><a href="#安装CDH" class="headerlink" title="安装CDH"></a>安装CDH</h2><p>这里有的小朋友可能就要问了，这个<strong>CDH</strong>是个什么东西？</p><p>众所周知Hadoop是一个开源软件，而<strong>CDH</strong>是<strong>Cloudera公司</strong>在原有的Hadoop基础上，加了一些东西，使它比原有的Apache Hadoop更稳定，更好用的版本，你可以把<strong>CDH</strong>简单的理解为<strong>企业级Hadoop</strong>，就类似<strong>IDEA</strong>一样，分为<strong>社区级</strong>和<strong>企业级</strong>。</p><h3 id="一-下载CDH"><a href="#一-下载CDH" class="headerlink" title="一.下载CDH"></a>一.下载CDH</h3><p><a href="https://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">CDH下载地址</a></p><p>这里我使用的是<strong>CDH5.15.1</strong>版本，图中箭头指的那个就是</p><p>下完后把它，传到你的服务器，建议用<strong>WinSCP</strong>，这里不详细介绍WinSCP用法了，别问问就是<strong>自己百度</strong></p><p><img src="https://i.loli.net/2020/03/03/4JU9fMN7BWq6kSC.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">$ lltotal 740364-rwxrwxr-x 1 hadoop hadoop 434029516 Oct 15  2018 hadoop-2.6.0-cdh5.15.1.tar.gz</code></pre><p>我这里已经传到了我的~/software目录下</p><h3 id="二-解压"><a href="#二-解压" class="headerlink" title="二.解压"></a>二.解压</h3><pre><code class="bash">$ tar -zxvf hadoop-2.6.0-cdh5.15.1.tar.gz -C ~/app/</code></pre><p>将hadoop解压到我的app目录下，确认解压成功</p><pre><code class="bash">$ lltotal 0drwxr-xr-x 14 hadoop hadoop 241 Aug 10  2018 hadoop-2.6.0-cdh5.15.1</code></pre><h3 id="三-修改Hadoop配置"><a href="#三-修改Hadoop配置" class="headerlink" title="三.修改Hadoop配置"></a>三.修改Hadoop配置</h3><p>编辑解压后的hadoop，<strong>etc/hadoop/hadoop-env.sh</strong>文件</p><pre><code class="bash">$ vim etc/hadoop/hadoop-env.sh# The java implementation to use.# export JAVA_HOME=${JAVA_HOME}export JAVA_HOME=/home/hadoop/app/jdk1.8.0_241 </code></pre><p>编辑<strong>etc/hadoop/core-site.xml</strong></p><pre><code class="bash">$ vim etc/hadoop/core-site.xml&lt;configuration&gt;# fs为FileSystem，配置默认文件系统位置    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://hadoop8:8020&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>value的值为文件系统指向的主机名以及端口号，也可以使用官方默认的9000端口</p><p>编辑<strong>etc/hadoop/hdfs-site.xml</strong></p><pre><code class="bash">$ vim etc/hadoop/hdfs-site.xml&lt;configuration&gt;# 副本节点个数    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;# hadoop.tmp.dir默认为系统的tmp目录，重启会被清空，所以我们这自己建一个tmp目录存放Hadoop缓存的文件    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/home/hadoop/app/tmp&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>编辑<strong>etc/hadoop/slaves</strong></p><p>Hadoop使用的是<strong>Master/Slave</strong>结构，即<strong>主从结构</strong>，这个slaves文件就是从节点地址，我们配置的是单节点，所以直接可以用默认localhost，也可以修改为你的主机名</p><pre><code class="bash">$ vim etc/hadoop/slaves#修改为你自己主机的主机名hadoop8</code></pre><h3 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h3><h2 id="悄悄告诉你🤐"><a href="#悄悄告诉你🤐" class="headerlink" title="悄悄告诉你🤐"></a>悄悄告诉你🤐</h2><p>我这里有一个已经搭建好<strong>Hadoop环境</strong>的镜像，下载下来用<strong>VMware</strong>打开就行</p><p><a href="https://pan.baidu.com/s/1O-aKM9Nnxppa_K1A19rDxA" target="_blank" rel="noopener"><strong>点我有惊喜(提取码：qbc2)</strong></a></p><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">Hadoop单节点配置官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(五)：SSH免密登录</title>
    <link href="undefined2020/03/09/Linux-5-%E5%AE%89%E8%A3%85SSH/"/>
    <url>2020/03/09/Linux-5-%E5%AE%89%E8%A3%85SSH/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h1><p><strong>SSH(Secure Shell)</strong>是一种<strong>网络协议</strong>，用于计算机之间的<strong>加密登录</strong>。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p><p>想进一步了解的话可以，参考阮一峰老师的<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">博客</a></p><h2 id="一-配置Hosts"><a href="#一-配置Hosts" class="headerlink" title="一.配置Hosts"></a>一.配置Hosts</h2><p>配置你的hosts，不配置会导致ssh登录无效</p><pre><code class="bash">$ sudo vim /etc/hosts</code></pre><p>添加服务器所对应的IP和主机名</p><p><img src="https://i.loli.net/2020/03/09/6zhtRGrVs2laPAT.png" srcset="/img/loading.gif" alt="ssh-hosts.png"></p><h2 id="二-生成密钥"><a href="#二-生成密钥" class="headerlink" title="二.生成密钥"></a>二.生成密钥</h2><p>在<strong>hadoop000</strong>用命令生成<strong>SSH密钥</strong>，接着，按三下回车就好</p><pre><code class="bash">$ ssh-keygen -t rsa</code></pre><p><img src="https://i.loli.net/2020/03/06/lGMkCYLPdoV8yni.png" srcset="/img/loading.gif" alt="ssh-keygen"></p><p>然后，进入<strong>.ssh</strong>文件夹，查看目录，会发现多了两个文件，<strong>id_rsa(私钥)</strong>和<strong>id_rsa.pub(公钥)</strong></p><p><img src="https://i.loli.net/2020/03/06/rl7G81CyxpAumYg.png" srcset="/img/loading.gif" alt=""></p><h2 id="三-公钥登录"><a href="#三-公钥登录" class="headerlink" title="三.公钥登录"></a>三.公钥登录</h2><p>用<strong>ssh-copy-id</strong>命令，将<strong>hadoop000</strong>生成的公钥传到<strong>hadoop8</strong>，@前面是目标用户名，@后面为目标服务器IP，如果用户名不同，还是要密码登录</p><pre><code class="bash">$ ssh-copy-id hadoop@192.168.1.8</code></pre><p><strong>hadoop8</strong>的<strong>.ssh</strong>目录会多出来一个<strong>authorized_keys</strong>的文件，然后设置一下权限</p><pre><code class="bash">$ chmod 600 authorized_keys #如果不设置，可能会因为权限问题不能免密登录</code></pre><p>用<strong>hadoop000</strong>ssh登录<strong>hadoop8</strong>，登录的时候不用输入密码了，<strong>SSH配置成功</strong></p><p><img src="https://i.loli.net/2020/03/09/ZSRxlpLfwJuk8Kt.png" srcset="/img/loading.gif" alt="ssh-success.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(四):安装JAVA环境(jdk1.8)</title>
    <link href="undefined2020/03/04/Linux-4-%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/"/>
    <url>2020/03/04/Linux-4-%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-JAVA环境-jdk1-8"><a href="#安装-JAVA环境-jdk1-8" class="headerlink" title="安装 JAVA环境(jdk1.8)"></a>安装 JAVA环境(jdk1.8)</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p><strong>下载jdk1.8</strong></p><p>进入Oracle官网下载页面</p><p><img src="https://i.loli.net/2020/03/04/SIwEvHBJ56gzUtr.png" srcset="/img/loading.gif" alt=""></p><p>如果你下的很慢的话，我给你贴心的准备好了我下好了的    <a href="https://pan.baidu.com/s/1_toI_omzKLYwinFo60BpRA" target="_blank" rel="noopener">点我(提取码：guk0)</a></p><p>下好后可以用<strong>WinScp</strong>或<strong>XFTP</strong>自行上传到自己的服务器目录，如果不会的话，我建议你<strong>百度</strong></p><p>我这里将JDK传到了我的<strong>~/software</strong>目录，我建议你们也可以自己建个software目录专门存放要安装的软件包</p><p><img src="https://i.loli.net/2020/03/04/Twra1WCDXcSZkoN.png" srcset="/img/loading.gif" alt="linux"></p><p>这里可以看到我的<strong>software</strong>目录已经有我上传的jdk了</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p><strong>解压</strong>已经传到服务器的jdk文件</p><p>使用<strong>tar</strong>命令将software目录下的jdk解压到app目录</p><pre><code class="bash">tar -zvxf jdk-8u241-linux-x64.tar.gz  -C ~/app</code></pre><p>解压完进入查看一下</p><pre><code class="bash">[hadoop@hadoop000 ~]$ lsapp   Desktop    Downloads  maven_resp  Pictures  README.txt  software   t.txtdata  Documents  lib        Music       Public    shell       Templates  Videos[hadoop@hadoop000 ~]$ cd app[hadoop@hadoop000 app]$ lshadoop-2.6.0-cdh5.15.1  hive-1.1.0-cdh5.15.1  jdk1.8.0_241  tmp[hadoop@hadoop000 app]$ cd jdk1.8.0_241/[hadoop@hadoop000 jdk1.8.0_241]$ pwd/home/hadoop/app/jdk1.8.0_241</code></pre><p>可以看到我的jdk已经解压到app目录了，路径是<strong>/home/hadoop/app/jdk1.8.0_241</strong></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p><strong>配置环境变量</strong></p><p>编辑环境变量文件</p><pre><code class="bash">vim ~/.bash_profile</code></pre><p>找个地方，添加下面这段</p><pre><code class="bash">export JAVA_HOME=/home/hadoop/app/jdk1.8.0_241export PATH=$JAVA_HOME/bin:$PATH</code></pre><p><img src="https://i.loli.net/2020/03/04/FZrAkKRNPIL71XT.png" srcset="/img/loading.gif" alt=""></p><p>使环境变量生效</p><pre><code class="bash"> source ~/.bash_profile</code></pre><p>使用java命令，验证生效情况</p><pre><code class="bash">java</code></pre><p><img src="https://i.loli.net/2020/03/04/P3ncaNAEDtiUqrb.png" srcset="/img/loading.gif" alt=""></p><p>出现，如图所示情况，安装成功😀</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在配置环境变量的时候，一般网上都是</p><pre><code class="bash">vim /etc/profile</code></pre><p>而我的是<strong>.bash_profile</strong>，这两者的区别再去</p><p><strong>/etc/profile：</strong>这个配置文件是对<strong>所有系统用户</strong>生效</p><p><strong>.bash_profile：</strong>这个配置文件是对<strong>当前登录</strong>生效</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弹钢琴吗？用键盘的那种(一):The Game is On</title>
    <link href="undefined2020/02/28/Pinao-1-TheGameIsOn/"/>
    <url>2020/02/28/Pinao-1-TheGameIsOn/</url>
    
    <content type="html"><![CDATA[<h1 id="The-game-is-on钢琴曲谱"><a href="#The-game-is-on钢琴曲谱" class="headerlink" title="The game is on钢琴曲谱"></a>The game is on钢琴曲谱</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> <strong>本曲用于在<a href="https://www.autopiano.cn/" target="_blank" rel="noopener">自由钢琴</a>弹奏，帮助同志们在闲暇之余，接受艺术的洗礼，陶冶自己的情操，升华自己的灵魂😀</strong></p><p><img src="https://i.loli.net/2020/02/28/v54Pb8eZOM21NCf.png" srcset="/img/loading.gif" alt="AutoPiano.png"></p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><div><table>        <thead>            <tr>                <th >描述</th>                <th >语法</th>            </tr>        </thead>        <tbody>            <tr>                <td>白键</td>                <td >0-9 a-z (小写字母)</td>            </tr>            <tr>                <td>黑键，需要按住<strong>Shift键</strong></td>                <td ><strong>!@$%^*(</strong> 和 A-Z (大写字母)</td>            </tr>            <tr>                <td><strong>同时</strong>按下abc三个键</td>                <td >[abc]</td>            </tr>            <tr>                <td>以一定间隔按下a b c 三个键</td>                <td >a b c</td>            </tr>            <tr>                <td>延音 ~</td>                <td >a~ 或 a~~</td>            </tr>        </tbody>    </table></div><p><strong>t   o   o   I   o   O   o   t   s   t   s   s   a   s   d   s   D</strong></p><p><strong>h   s   s   d   D   d   D   d   s   g   s   s   d   D   D   g   d   d   D   s   s   d   a   O   o   s</strong></p><p><strong>v   l   l   z   Z   z   Z   z   l   c   l   l   z   Z   Z   c   z   z   Z   l   l   z   k   H   h   l</strong></p><h2 id="音名"><a href="#音名" class="headerlink" title="音名"></a>音名</h2><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1177649593,2842240244&fm=173&app=25&f=JPEG?w=640&h=167&s=A7947C22C8A8C50142D565DE0000C0B2" srcset="/img/loading.gif" alt=""></p><p><strong>^：</strong>代表黑键</p><p><strong>C4    G4    G4    F4^    G4    G4^    G4    C4    C5    C4    C5    C5    B4    C5    D5    C5    D5^</strong></p><p><strong>G5    C5    C5    D5    D5^    D5    D5^    D5    C5    F5    C5    C5    D5    D5^    D5^    F5    D5    D5    D5^    C5    C5    D5    B4    G4^    G4    C5</strong></p><p><strong>G6    C6    C6    D6    D6^    D6    D6^    D6    C6    F6    C6    C6    D6    D6^    D6^    F6    D6    D6    D6^    C6    C6    D6    B5    G5^    G5    C6</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>钢琴</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop(一):初识Hadoop</title>
    <link href="undefined2020/02/26/Hadoop-1-%E5%88%9D%E5%A7%8BHadoop/"/>
    <url>2020/02/26/Hadoop-1-%E5%88%9D%E5%A7%8BHadoop/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Hadoop"><a href="#初识Hadoop" class="headerlink" title="初识Hadoop"></a>初识Hadoop</h1><h2 id="Hadoop名字怎么来的？"><a href="#Hadoop名字怎么来的？" class="headerlink" title="Hadoop名字怎么来的？"></a>Hadoop名字怎么来的？</h2><p>Hadoop之父的名字叫<strong>Doug Cutting</strong>，就是下图那位儒雅随和的男人，他不仅仅是Hadoop的创始人，同时也是<strong>nutch(一个开源Java实现的搜索引擎)</strong>的创始人，而Hadoop这个名字<strong>其实是他孩子一个玩具的名字</strong>，就是下图那个那个小黄象，这个玩具也是<strong>Hadoop的Logo</strong>，小朋友们起名字确实很厉害，类似的还有大名鼎鼎<strong>Google</strong>这个名字就是<strong>由美国数学家 Edward Kasner 九岁的侄子 Milton Sirotta 发明的</strong></p><p><img src="https://i.loli.net/2020/02/26/76KYFDEqloJRUmV.jpg" srcset="/img/loading.gif" alt="hadoopFather"></p><h2 id="Hadoop是干什么的？"><a href="#Hadoop是干什么的？" class="headerlink" title="Hadoop是干什么的？"></a>Hadoop是干什么的？</h2><p><img src="https://i.loli.net/2020/02/26/mwleA3x86Pdc7bY.png" srcset="/img/loading.gif" alt="Hadoop-introduce.png"></p><p>这是Hadoop的官网(<a href="https://hadoop.apache.org/" target="_blank" rel="noopener">https://hadoop.apache.org/</a>) 的介绍，简单来说，Hadoop就是一个开源的，可靠的，可扩展的分布式计算框架，它用来对海量数据进行<strong>分布式存储和计算</strong>，就是传说中的<strong>大数据</strong>。</p><h2 id="Hadoop有几个模块"><a href="#Hadoop有几个模块" class="headerlink" title="Hadoop有几个模块?"></a>Hadoop有几个模块?</h2><p><img src="https://i.loli.net/2020/02/26/AqvmgxCGbW81RSi.png" srcset="/img/loading.gif" alt="hadoop-modules.png"></p><ul><li><p><strong>Hadoop Common：</strong> 公共的模块，用来给其他模块调用</p></li><li><p><strong>Hadoop分布式存储系统(HDFS)：</strong>提供对应用程序数据的<strong>高吞吐量</strong>访问的分布式文件系统</p></li><li><p><strong>Hadoop YARN：</strong>一个用来作业调度和群集资源管理的<strong>框架</strong>。</p></li><li><p><strong>Hadoop MapReduce：</strong>基于<strong>YARN</strong>可在很多机器上进行<strong>分布式并行计算</strong></p></li><li><p><strong>Hadoop Ozone：</strong>Hadoop的对象存储</p></li><li><p><strong>Hadoop Submarine：</strong>一个Hadoop的<strong>机器学习</strong>框架</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node安装与配置</title>
    <link href="undefined2020/01/23/Node%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>2020/01/23/Node%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Node环境搭建"><a href="#Node环境搭建" class="headerlink" title="Node环境搭建"></a>Node环境搭建</h1><p>简单的说，node就是一个前端程序员看后端不爽，用<strong>JavaScript</strong>写出来的后端。</p><p><strong>下载地址：</strong></p><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a></p><p><img src="https://i.loli.net/2020/01/29/4iNUcfwOZk7qVxQ.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-20-25.png"></p><p>选择自己系统对应的版本下载，然后一键安装，小白看教程：</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></p><p>打开<strong>CMD</strong>，输入<strong>node -v</strong>和<strong>npm -v</strong>，如果显示了版本，则安装完成</p><p><img src="https://i.loli.net/2020/01/29/GU8cF6YdOTePqiL.png" srcset="/img/loading.gif" alt="Photo_2020-01-21_18-50-27.png"></p><h2 id="Node配置"><a href="#Node配置" class="headerlink" title="Node配置"></a>Node配置</h2><p>这里node的配置主要是配置<strong>npm</strong>，简单来说<strong>npm</strong>就相当于<strong>Java中的Maven</strong>，或者说它就是前端开发中的Maven</p><h3 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>node也和Maven一样有着默认镜像，默认镜像访问速度较慢，下面是它原本的镜像</p><pre><code class="bash">npm get registry //获取镜像</code></pre><p><img src="http://ww1.sinaimg.cn/large/007SzKTZgy1gb6amm6wulj30d6065jr9.jpg" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-37-07.png"></p><p>我们要将默认镜像切换为淘宝镜像</p><pre><code class="bash">npm config set registry https://registry.npm.taobao.org        //设置镜像</code></pre><p><img src="https://i.loli.net/2020/01/29/iGoHaKL9YCnPFBM.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-40-17.png"></p><p>上面已经切换成淘宝镜像了，如果想国内镜像和国外镜像一起使用的也可以，通过<strong>cnpm</strong></p><pre><code class="bash">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>这样以后使用，<strong>cnpm i <model_name></strong>就是使用国内镜像，<strong>npm i <model_name></strong>就是使用默认镜像</p><h3 id="npm仓库地址"><a href="#npm仓库地址" class="headerlink" title="npm仓库地址"></a>npm仓库地址</h3><p>npm库拉到本地后，会默认存在你的<strong>C盘</strong>，占C盘空间</p><h4 id="1-新建node-global和node-cache"><a href="#1-新建node-global和node-cache" class="headerlink" title="1.新建node_global和node_cache"></a>1.新建node_global和node_cache</h4><ul><li><strong>node_globa</strong>为npm的全局安装路径，类似maven仓库地址</li><li><strong>node_cache</strong>为缓存路径</li></ul><p>一般我习惯在我的nodejs安装目录下新建，如果你想放别的地方也可以</p><p><img src="https://i.loli.net/2020/01/29/mzUkENQTleAZpu3.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-53-07.png"></p><h4 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h4><p>打开<strong>此电脑=&gt;属性=&gt;高级系统设置=&gt;环境变量</strong></p><p><img src="https://i.loli.net/2020/01/29/FKaE7kC2lp6UxRz.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-59-38.png"></p><p>新建系统变量<strong>NODE_PATH</strong>，填写新建的<strong>node_global</strong>的路径</p><p><img src="https://i.loli.net/2020/01/29/e1gQ7RcKPo3SYfE.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-04-54.png"></p><p>然后配置<strong>用户变量-&gt;Path</strong>，加入<strong>%NODE_PATH%</strong></p><p><img src="https://i.loli.net/2020/01/29/ET2BuDXCVY8Oh5S.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-10-35.png"></p><h4 id="3-设置全局"><a href="#3-设置全局" class="headerlink" title="3.设置全局"></a>3.设置全局</h4><p>打开cmd，输入命令：</p><pre><code class="bash">npm config set prefix &quot;F:\Node\node_global&quot;npm config set cache &quot;F:\Node\node_cache&quot;</code></pre><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><p>我们全局安装一下常用的<strong>express</strong>模块试一下</p><pre><code class="bash">npm install express -g</code></pre><p><img src="https://i.loli.net/2020/01/29/muvyVU29Jz5HjOA.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-17-10.png"></p><p>可以看到在node_global文件夹出现了express，配置完成😀</p>]]></content>
    
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA压力测试:Jmeter初体验</title>
    <link href="undefined2019/12/19/JAVA%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-1/"/>
    <url>2019/12/19/JAVA%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmeter初体验"><a href="#Jmeter初体验" class="headerlink" title="Jmeter初体验"></a>Jmeter初体验</h1><p>校园博客的项目需要上线，所以要进行压力测试，于是就开始了测试初体验</p><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/</a></p><p><img src="https://i.loli.net/2019/12/19/OYQVBDkJ3idjo6m.png" srcset="/img/loading.gif" alt=""></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="1-配置JMETER-HOME"><a href="#1-配置JMETER-HOME" class="headerlink" title="1.配置JMETER_HOME"></a>1.配置JMETER_HOME</h4><p>打开系统变量新建变量<strong>JMETER_HOME</strong>,然后，填写你的jmeter安装目录</p><p><img src="https://i.loli.net/2019/12/19/j5RmbN3ey4KQVud.png" srcset="/img/loading.gif" alt=""></p><h4 id="2-配置path"><a href="#2-配置path" class="headerlink" title="2.配置path"></a>2.配置path</h4><p>在path变量加入 <strong>%JMETER_HOME%\bin</strong></p><h3 id="确认安装"><a href="#确认安装" class="headerlink" title="确认安装"></a>确认安装</h3><p>随便找个地方，打开cmd，输入 <strong>jmeter</strong>能打开jmeter就算配置完成</p><p><img src="https://i.loli.net/2019/12/19/V8kNMaqAKmZyUYb.png" srcset="/img/loading.gif" alt=""></p><h2 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h2><p>进入jmeter的bin目录下,打开 jmeter.bat文件</p><p><img src="https://i.loli.net/2019/12/19/ctOTD7Y4BpvxVLF.png" srcset="/img/loading.gif" alt=""></p><p>打开<strong>Options</strong>，选择<strong>Choose Language</strong>中的<strong>Chinese(Simplified)</strong>可以切换成简体中文</p><p><img src="https://i.loli.net/2019/12/19/cQ1MkaDhzIrmufl.png" srcset="/img/loading.gif" alt=""></p><p>右键一个test plan 点击 添加 线程 线程组</p><p><img src="https://i.loli.net/2019/12/19/S8c1LB5ZpjWVeFR.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2019/12/19/UGqAbLdYHrzmOha.png" srcset="/img/loading.gif" alt=""></p><p><strong>线程数：</strong>虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个线程数。</p><p><strong>Ramp-Up Period(in seconds)准备时长：</strong>设置的虚拟用户数需要多长时间全部启动。如果线程数为10，准备时长为2，那么需要2秒钟启动10个线程，也就是每秒钟启动5个线程。</p><p><strong>循环次数：</strong>每个线程发送请求的次数。如果线程数为10，循环次数为100，那么每个线程发送100次请求。总请求数为10*100=1000 。如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。</p><p>将要测试的接口的信息填上，这里我的接口是：<strong><a href="http://localhsot:10002/api/post" target="_blank" rel="noopener">http://localhsot:10002/api/post</a></strong></p><p><img src="https://i.loli.net/2019/12/19/QD1mWkcZn6lBX3N.png" srcset="/img/loading.gif" alt=""></p><p>随后，将测试计划保存到一个目录</p><p><img src="https://i.loli.net/2019/12/19/gue35fmwZFjTvHt.png" srcset="/img/loading.gif" alt=""></p><p>接着到执行计划保存目录，用命令执行测试计划</p><p>非GUI并生成html报告：</p><p>jmeter -n -t <test JMX file> -l <test log file> -e -o <Path to output folder></p><p>非GUI并生成html报告：</p><pre><code class="bash">E:\apache-jmeter\TestPlan&gt;jmeter -n -t &quot;post all.jmx&quot; -l read.jtl -e -o E:\apache-jmeter\TestPlan\Report</code></pre><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110258.png" srcset="/img/loading.gif" alt=""></p><p>然后就会jmeter会帮你生成报告文件</p><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110444.png" srcset="/img/loading.gif" alt=""></p><p>随后打开Repost下index.html查看结果</p><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110541.png" srcset="/img/loading.gif" alt=""></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>由于我是在pc上测的，内存和cpu都比不上服务器，这样的测试结果不准确</p></li><li><p>命令生成报告的时候，比如我的是Report目录，如果这个目录<strong>不为空</strong>，JMeter就会报错</p></li><li><p>重新打开JMeter，它的设置会恢复默认，重新变成英文的了¿¿¿  </p></li><li><p>重新打开JMeter执行计划也不见了，可以导入之前的执行计划。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>压力测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点(二):集合</title>
    <link href="undefined2019/12/04/JAVA%E5%9F%BA%E7%A1%80-2-%E9%9B%86%E5%90%88/"/>
    <url>2019/12/04/JAVA%E5%9F%BA%E7%A1%80-2-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-集合"><a href="#JAVA-集合" class="headerlink" title="JAVA 集合"></a>JAVA 集合</h1><p>JAVA的集合类被定义在Java.util包中，主要有4种集合，分别为<strong>List、Queue、Set、Map</strong>，每种集合的具体分类如图：</p><p><img src="https://i.loli.net/2019/12/04/XAyEQ4fDdN35sCz.png" srcset="/img/loading.gif" alt=""></p><h2 id="List：加强版数组"><a href="#List：加强版数组" class="headerlink" title="List：加强版数组"></a>List：加强版数组</h2><h3 id="1-ArrayList：基于数组实现，增删慢，查询快，线程不安全"><a href="#1-ArrayList：基于数组实现，增删慢，查询快，线程不安全" class="headerlink" title="1.ArrayList：基于数组实现，增删慢，查询快，线程不安全"></a>1.ArrayList：基于数组实现，增删慢，查询快，线程不安全</h3><p>因为是基于数组实现，所以当需要<strong>插入</strong>或<strong>删除</strong>一个节点时，需要移动其他所有节点，代价较高，因此，ArrayList不适合更新操作。</p><p>ArrayList不需要定义数组长度，在默认长度（默认长度为10）不够时，ArrayList会创建一个新的更大数组并将已有的数据复制到新数组中，通过调用一个native方法<strong>System.arraycopy</strong>实现</p><h3 id="2-Vector-基于数组实现，增删慢，查询快，线程安全"><a href="#2-Vector-基于数组实现，增删慢，查询快，线程安全" class="headerlink" title="2.Vector: 基于数组实现，增删慢，查询快，线程安全"></a>2.Vector: 基于数组实现，增删慢，查询快，线程安全</h3><p>Vector的数据结构与ArrayList一样，都是基于数组实现，不同的是Vector支持线程同步，以保证多线程环境下数据的一致性，但由于频繁的加锁和释放锁操作，Vector整体独写效率比ArrayList低。</p><h3 id="3-LinkedList-基于双向链表实现，增删快，查询慢，线程不安全"><a href="#3-LinkedList-基于双向链表实现，增删快，查询慢，线程不安全" class="headerlink" title="3.LinkedList: 基于双向链表实现，增删快，查询慢，线程不安全"></a>3.LinkedList: 基于双向链表实现，增删快，查询慢，线程不安全</h3><p>LinkedList采用双向链表结构存储元素，在对LinkedList插入和删除时，只需要将上一个节点的指针指向要操作的节点即可，数据改动较小，因此更新效率高。但对LinkedList进行访问时，需要从链表头部一直遍历到需要访问的节点，因此查询的效率很慢。除此之外，LinkedList还定义了用于<strong>操作链表头和尾部</strong>的元素，因此有时可以当作堆栈、队列和双向队列使用。</p><h2 id="Map-键值对"><a href="#Map-键值对" class="headerlink" title="Map: 键值对"></a>Map: 键值对</h2><h3 id="1-HashMap：数组-链表实现，线程不安全"><a href="#1-HashMap：数组-链表实现，线程不安全" class="headerlink" title="1.HashMap：数组 + 链表实现，线程不安全"></a>1.HashMap：数组 + 链表实现，线程不安全</h3><p>HashMap基于键的HashCode值唯一标识一条数据，同时<strong>基于HashCode进行数据的存取</strong>，因此可以快速更新和查找数据，但遍历顺序不保证一样，HashMap的key和valu允许为null.</p><p>HashMap不是线程安全的，如果同一时刻多个线程操作HashMap会导致数据不一致，使HashMap造成环形链表。如果需要线程安全可以使用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或使用ConcurrentHashMap.</p><p>HashMap的结构如图所示，</p><p><img src="https://i.loli.net/2019/12/10/aEwPsmeXMQuCp2y.png" srcset="/img/loading.gif" alt=""></p><p>其内部是一个<strong>数组</strong>，数组中的<strong>每个元素都是一个单向链表</strong>，链表中的每个元素都是Node类实例，Node类包含4个属性：<strong>key、value、hash和用于指向下一个元素的next</strong></p><pre><code class="JAVA">    /**     * 初始化数组容量，默认为16，可以扩容，扩容后数组大小为当前的两倍，该值使用为2^n次方     */    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16    transient Node&lt;K,V&gt;[] table;    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;    }</code></pre><p>HashMap在查找数据时，根据HashMap的Hash值可以快速定位到数组下标，但是我们在找到数组下标后需要对链表进行遍历直到找到需要的数据，时间复杂度为O(n).</p><p>为了减小俩表遍历的开销，Java8对HashMap进行了优化，将数据结构修改为<strong>数组+链表或红黑树</strong>。在链表中元素<strong>超过8</strong>后，HashMap会将链表转为红黑树结构以提高查询效率，因此其时间复杂度为O(logN)。如图</p><p><img src="https://i.loli.net/2019/12/10/voKyxMumfpiF6zt.png" srcset="/img/loading.gif" alt=""></p><pre><code class="JAVA">    /**     * 使用树的阈值，如果链表长度超过此值，则链表转为红黑树     */    static final int TREEIFY_THRESHOLD = 8;    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {        TreeNode&lt;K,V&gt; parent;          TreeNode&lt;K,V&gt; left;        TreeNode&lt;K,V&gt; right;        TreeNode&lt;K,V&gt; prev;        boolean red;    }</code></pre><h3 id="2-ConcurrentHashMap：分段锁实现，线程安全"><a href="#2-ConcurrentHashMap：分段锁实现，线程安全" class="headerlink" title="2.ConcurrentHashMap：分段锁实现，线程安全"></a>2.ConcurrentHashMap：分段锁实现，线程安全</h3><p>在<strong>JDK1.7</strong>中，ConcurrentHashMap采用<strong>分段锁</strong>的思想实现并发操作，因此是线程安全的。ConcurrentHashMap由多个Segment组成（Segment的数量也是锁的并发度），每个Segment都继承自<strong>ReentrantLock</strong>并单独加锁，所以每次进行加锁操作时锁住的都是一个Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。如图，所示：</p><p><img src="https://i.loli.net/2019/12/11/JrMAnaPEy461kmj.png" srcset="/img/loading.gif" alt=""></p><p>在<strong>JDK1.8</strong>中，抛弃了Segment分段锁机制，利用<strong>CAS+Synchronized</strong>，数据结构采用<strong>数组 + 链表 + 红黑树</strong></p><h3 id="3-HashTable：线程安全"><a href="#3-HashTable：线程安全" class="headerlink" title="3.HashTable：线程安全"></a>3.HashTable：线程安全</h3><p>HashTable是遗留类，很多映射的常用功能都与HashMap类似，不同的是它继承自<strong>Dictionary</strong>类，并且是线程安全的，同一时刻只能有一个线程能写HashTable，并发性不如ConcurrentHashMap。</p><h3 id="4-TreeMap：基于二叉树数据结构"><a href="#4-TreeMap：基于二叉树数据结构" class="headerlink" title="4.TreeMap：基于二叉树数据结构"></a>4.TreeMap：基于二叉树数据结构</h3><p>TreeMap基于二叉树数据结构存储数据，同时实现了<strong>SortedMap</strong>接口，以保障元素的顺序存储，默认按键值的升序排序，也可以自定义排序比较器。</p><p>TreeMap常用于实现排序的映射列表。在使用TreeMap时其key必须实现Comparable接口或采用自定义比较器，否则会抛出java.lang.ClassCastException异常</p><h3 id="5-LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序"><a href="#5-LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序" class="headerlink" title="5.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序"></a>5.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序</h3><p>LinkedHashMap是HashMap的子类，其内部使用链表保存元素的插入顺序，在通过Iterator遍历LinkedHashMap时，会按照元素的插入顺序访问元素。</p><h2 id="Set：不可重复"><a href="#Set：不可重复" class="headerlink" title="Set：不可重复"></a>Set：不可重复</h2><p>Set的核心是<strong>独一无二</strong>的性质，适用于存储无序且值不相等的元素。</p><h3 id="1-HashSet：HashMap实现，无序"><a href="#1-HashSet：HashMap实现，无序" class="headerlink" title="1.HashSet：HashMap实现，无序"></a>1.HashSet：HashMap实现，无序</h3><p><strong>HashSet是基于HashMap实现的</strong>，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个<strong>private static final Object PRESENT = new Object();。</strong>HashSet跟HashMap一样，都是存放链表的数组。</p><pre><code class="java">public class HashSet&lt;E&gt;    extends AbstractSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable{    static final long serialVersionUID = -5024744406713321676L;    private transient HashMap&lt;E,Object&gt; map;    private static final Object PRESENT = new Object();    public HashSet() {        map = new HashMap&lt;&gt;();    }    public boolean add(E e) {        return map.put(e, PRESENT)==null;    }    ....}</code></pre><h3 id="2-TreeSet：二叉树实现"><a href="#2-TreeSet：二叉树实现" class="headerlink" title="2.TreeSet：二叉树实现"></a>2.TreeSet：二叉树实现</h3><p><strong>TreeSet是基于TreeMap实现</strong>，和HashSet类似</p><pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{    private transient NavigableMap&lt;E,Object&gt; m;    private static final Object PRESENT = new Object();    public TreeSet() {        this(new TreeMap&lt;E,Object&gt;());    }    public boolean add(E e) {        return m.put(e, PRESENT)==null;    }}</code></pre><p>可以自定义排序方法</p><pre><code class="java">Set&lt;String&gt; treeSet = new TreeSet(Comparator.comparing(String::length));</code></pre><p>如果是自定义数据类型，必须<strong>实现Comparable接口</strong>。并<strong>覆写compareTo函数</strong>。</p><h3 id="3-LinkedHashSet：数据插入顺序和遍历数据一样"><a href="#3-LinkedHashSet：数据插入顺序和遍历数据一样" class="headerlink" title="3.LinkedHashSet：数据插入顺序和遍历数据一样"></a>3.LinkedHashSet：数据插入顺序和遍历数据一样</h3><p> <strong>LinkedHashSet继承了HashSet</strong>，所有的操作都与HashSet一样，底层使用<strong>LinkedHashMap存储元素</strong></p><pre><code class="java">public class LinkedHashSet&lt;E&gt;    extends HashSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {     public LinkedHashSet(int initialCapacity, float loadFactor) {        super(initialCapacity, loadFactor, true);    }     public LinkedHashSet(int initialCapacity) {        super(initialCapacity, .75f, true);    }     public LinkedHashSet() {        super(16, .75f, true);    }}</code></pre><p>这里神奇的是，LinkedHashSet创建对象却是在HashSet里</p><pre><code class="java">    HashSet(int initialCapacity, float loadFactor, boolean dummy) {        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);    }</code></pre><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>用的不是很多，所以不详细说明</p><ul><li><p><strong>ArrayBlockingQueue：</strong>基于数组数据结构实现的有界阻塞队列</p></li><li><p><strong>LinkedBlockingQueue：</strong>基于链表数据结构实现的有界阻塞队列</p></li><li><p><strong>PriorityBlockingQueue：</strong>支持优先级排序的无界队列</p></li><li><p><strong>DelayQueue：</strong>支持延迟操作的无界阻塞队列</p></li><li><p><strong>SynchronousQueue：</strong>用于线程同步的阻塞队列</p></li><li><p><strong>LinkedTransferQueue：</strong>基于链表数据结构实现的无界阻塞队列</p></li><li><p><strong>LinkedBlockingDeque：</strong>基于链表数据结构实现的双向阻塞队列</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点(一):JVM</title>
    <link href="undefined2019/12/02/JAVA%E5%9F%BA%E7%A1%80-1-JVM/"/>
    <url>2019/12/02/JAVA%E5%9F%BA%E7%A1%80-1-JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><strong>JVM(Java Virtual Machine)</strong>是用于运行Java字节码的虚拟机包括一个<strong>类加载器子系统（Class Loader SubSystem）</strong>、<strong>运行时数据区（Runtime Data Area）</strong>、执行引擎和<strong>本地接口库（Native Interface Library）</strong>。本地接口库通过调用<strong>本地方法库（Native Method Library）</strong>与操作系统交互，如图：</p><p><img src="https://i.loli.net/2019/12/02/ikFsOqoJ98NbCKe.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>Java堆（Heap）：</strong>是Java虚拟机所管理的内存最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的<strong>唯一目的就是存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</li><li><strong>方法区（Method Area）：</strong>与java堆一样，是各个线程共享的内存区域，它用于<strong>存储</strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li><strong>程序计数器（Program Counter Register）：</strong>是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li><li><strong>JVM栈（JVM Stacks）：</strong>与程序计数器一样，<strong>java虚拟机栈（Java Virtual Machine Stacks）</strong>也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被创建的时候都会创建一个<strong>栈帧(Stack Frame)</strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。</li><li><strong>本地方法栈（Native Method Stacks）：</strong>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行JAVA方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题(一)</title>
    <link href="undefined2019/11/17/%E9%9D%A2%E8%AF%95-1/"/>
    <url>2019/11/17/%E9%9D%A2%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>我一个好朋友，在BOSS上投简历收到了面试邀请，这是他面试回来说的面试题，我整理了一下并查了答案，以免自己去面试的时候不会</p><p>下面是面试问题：</p><blockquote><p>1.JAVA数据类型以及所占字节</p><p>2.手写三个单例模式</p><p>3.ArrayList与LinkList区别</p><p>4.HashSet原理</p><p>5.常用的Linux命令</p><p>6.JAVA反射机制</p><p>7.手画一个线程状态图</p><p>8.手写三个线程交替打印ABC</p><p>9.什么是TCP三次握手，为什么四次挥手断开连接，为什么</p><p>10.手写一个冒泡算法</p><p>11.SpringMVC是怎么运行的？</p><p>12.索引类型及作用</p></blockquote><p>下面面试答案：</p><h2 id="1-JAVA数据类型及所占字节"><a href="#1-JAVA数据类型及所占字节" class="headerlink" title="1.JAVA数据类型及所占字节"></a>1.JAVA数据类型及所占字节</h2><pre><code class="java">整型:  byte--1字节    short--2字节    int--4字节    long--8字节浮点型:  float--4字节    double--8字节字符型:  char--2字节布尔型:  boolean--1字节</code></pre><h2 id="2-单例模式的三种实现"><a href="#2-单例模式的三种实现" class="headerlink" title="2.单例模式的三种实现"></a>2.单例模式的三种实现</h2><pre><code class="JAVA">/*** 1.懒汉式,默认不实例化，什么时候用什么时候创建对象* 优点：懒加载启动快，资源占用小，使用时才实例化，无锁。* 缺点：非线程安全。*/public class Singleton{    private static Singleton instance;    private Singleton(){}    public static synchronized Singleton getInstance(){        if(instance == null){            instance = new Singleton();        }        return instance;    }}/** 2.饿汉式，类加载的时候就实例化* 优点：饿汉模式天生是线程安全的，使用时没有延迟。* 缺点：启动时即创建实例，启动慢，有可能造成资源浪费。*/public class Singleton{    private Singleton(){}    private static final Singleton singleton = new Singleton();    public static Singleton getInstance(){        return singleton;    }}/** 3.静态内部类* 优点：将懒加载和线程安全完美结合的一种方式（无锁）。（推荐）*/public class Singleton{    private Singleton(){}    public static final Singleton getInstance(){        return SingletonHolder.INSTANCE;    }    private static class SingletonHolder{        private static final Singleton INSTANCE = new Singleton();    }}</code></pre><h2 id="3-ArrayList和LinkList的区别"><a href="#3-ArrayList和LinkList的区别" class="headerlink" title="3.ArrayList和LinkList的区别"></a>3.ArrayList和LinkList的区别</h2><pre><code class="JAVA">ArrayList是基于数组实现的，查询快，更新慢。LinkList是基于链表实现的，插入，删除快，查询慢</code></pre><h2 id="4-HashSet原理"><a href="#4-HashSet原理" class="headerlink" title="4.HashSet原理"></a>4.HashSet原理</h2><pre><code class="JAVA">HashSet实现Set接口，由一个HashMap实例支持。不保证set的迭代顺序;不保证舒徐恒久不变。此类允许使用nullprivate transient HashMap&lt;E,Object&gt; map;  //map集合，HashSet存放元素的容器private static final Object PRESENT = new Object(); //map，中键对应的value值</code></pre><h2 id="5-常用的Linux命令"><a href="#5-常用的Linux命令" class="headerlink" title="5.常用的Linux命令"></a>5.常用的Linux命令</h2><pre><code class="bash">ll ls cd pwd mkdir touch rm -rf grep less</code></pre><h2 id="6-JAVA反射机制"><a href="#6-JAVA反射机制" class="headerlink" title="6.JAVA反射机制"></a>6.JAVA反射机制</h2><pre><code class="java">java反射机制是指在运行时，对任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取对象信息及动态调用方法的功能称为JAVA反射机制。通过Class.forName(包名.类名)获得类对象Class，通过操作Class对象达到运行时操作类</code></pre><h2 id="7-手画一个线程状态图"><a href="#7-手画一个线程状态图" class="headerlink" title="7.手画一个线程状态图"></a>7.手画一个线程状态图</h2><pre><code class="java">线程有五个状态：新建态(new)、就绪态(runnable)、运行态(running)、阻塞态(blocked)、死亡态(dead)</code></pre><p><img src="https://images2017.cnblogs.com/blog/432513/201712/432513-20171214160438717-1661848063.png" srcset="/img/loading.gif" alt=""></p><h2 id="8-手写三个线程交替打印ABC"><a href="#8-手写三个线程交替打印ABC" class="headerlink" title="8.手写三个线程交替打印ABC"></a>8.手写三个线程交替打印ABC</h2><pre><code class="java">/*** 主要考察的使是线程间的同步唤醒操作，线程的逻辑执行步骤为ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA.......* 要控制线程的执行顺序,就要确定唤醒和等待的顺序,一种解题思路是一个线程持有两个对象锁.一个对象锁是pret即前* * 一个对象所持有的锁,还有一个是自身锁.*/public class SysaAbcThread implements Runnable{    private Object pret;     //上一个锁    private Object self;     //自身锁    private String sout;     //要输出的内容    public SysaAbcThread(Object pret, Object self, String sout) {        super();        this.pret = pret;        this.self = self;        this.sout = sout;    }    @Override    public void run() {        while(true){            synchronized (pret) {     //获取 pret锁                synchronized (self) { //获取 self锁                    System.out.println(sout);                    self.notifyAll();  //释放self锁，唤醒其他线程竞争self锁                }                try {                    pret.wait();      //释放pret锁，休眠等待唤醒                } catch (InterruptedException e) {}            }        }    }    public static void main(String[] args) throws InterruptedException {        Object a = new Object();        Object b = new Object();        Object c = new Object();        SysaAbcThread aThread = new SysaAbcThread(c, a, &quot;A&quot;);        SysaAbcThread bThread = new SysaAbcThread(a, b, &quot;B&quot;);        SysaAbcThread cThread = new SysaAbcThread(b, c, &quot;C&quot;);        /**         * 如果不sleep，则启动顺序会乱         */        new Thread(aThread).start();        Thread.sleep(100);        new Thread(bThread).start();        Thread.sleep(100);        new Thread(cThread).start();        Thread.sleep(100);    }}</code></pre><h2 id="9-什么是TCP三次握手，为什么四次挥手断开连接"><a href="#9-什么是TCP三次握手，为什么四次挥手断开连接" class="headerlink" title="9.什么是TCP三次握手，为什么四次挥手断开连接"></a>9.什么是TCP三次握手，为什么四次挥手断开连接</h2><p><strong>三此握手(Three-way Handshake)是指建立一个TCP连接时</strong>，需要客户端和服务端总共发送三个包。</p><p>三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><ul><li><p>第一次握手(SYN=1,seq=x):   <strong>客户端=&gt;服务端</strong></p><p>客户端发送一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口，以及初始序号X，保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕客户端进入<strong>SYN_SEND</strong>状态。</p></li></ul><ul><li><p>第二次握手(SYN=1,ACK=1,seq=y,ACKnum=x+1):  <strong>服务端=&gt;客户端</strong></p><p>服务器发回确认包(ACK)应答。即SYN标志和ACK标志位均为1。服务器端选择自己的ISN序列号，放到Seq域里，同时将确认序号(Acknowledgement Number)设置为客户端的ISN加1，即X+1。发送完毕后，服务器端进入<strong>SYN_RCVD</strong>状态。</p></li></ul><ul><li><p>第三次握手(ACK=1,ACKnum=y+1)：<strong>客户端=&gt;服务端</strong></p><p>客户端再次发回确认包(ACK)，SYN标志位为0，ACK标志为1，并把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写INS的+1</p><p>发送完毕后，客户端进入<strong>ESTABLISHED</strong>状态，当服务器端接收到这个包时，也进入<strong>ESTABLISHED</strong>状态，TCP握手结束。</p></li></ul><p><strong>四次挥手(Four-Way Wavehand)是指断开一个TCP连接时</strong>，需要客户端和服务端发送四个包确认连接断开。客户端或服务端均可主动发起挥手动作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<strong>FIN_WAIT_1</strong>状态</p></li></ul><ul><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端发送的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<strong>CLOSE_WAIT</strong>状态，客户端接收到这个确认包之后，进入<strong>FIN_WAIT_2</strong>状态，等待服务器关闭连接。</p></li></ul><ul><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN设置为1.</p><p>发送完毕后，服务端进入<strong>LAST_ACK</strong>状态，等待来自客户端的最后一个ACK。</p></li></ul><ul><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收来自服务器端的关闭请求，发送一个确认包，并进入<strong>TIME_WAIT</strong>状态，等待可能出现的要求重传的ACK包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入<strong>CLOSED</strong>状态。</p><p>客户端等待了某个固定时间（两个最大生命周期，2MSL，2 Maximum Segment Lifetime）之后，没收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<strong>CLOSED</strong>状态</p></li></ul><h2 id="10-手写一个冒泡算法"><a href="#10-手写一个冒泡算法" class="headerlink" title="10.手写一个冒泡算法"></a>10.手写一个冒泡算法</h2><pre><code class="java">    public int[] sort(int[] arr){        int length = arr.length;        for(int i=0;i&lt;length;i++){            for(int j=i;j&lt;length;j++){                if(arr[i] &gt; arr[j]){                    int temp = arr[j];                    arr[j] = arr[i];                    arr[i] = temp;                }            }        }        return arr;    }   </code></pre><h2 id="11-SpringMVC是怎么运行的？"><a href="#11-SpringMVC是怎么运行的？" class="headerlink" title="11.SpringMVC是怎么运行的？"></a>11.SpringMVC是怎么运行的？</h2><p>（1）用户发送请求至前端控制器<strong>DispatcherServlet</strong></p><p>（2）<strong>DispatcherServlet</strong>收到请求后，调用<strong>HandlerMapping</strong>处理映射器，请求获取Handle;</p><p>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有就生成)，一并返回给<strong>DispatcherServlet</strong></p><p>（4）<strong>DispatcherServlet</strong>调用<strong>HandlerAdapter</strong>处理适配器</p><p>（5）<strong>HandlerAdapter</strong>经过适配调用具体处理器(Handler，也叫后端控制器)；</p><p>（6）<strong>Handler</strong>执行完成返回<strong>ModelAndView</strong>；</p><p>（7）<strong>HandlerAdapter</strong>将Handler执行结果<strong>ModelAndView</strong>返回给<strong>DispatcherServlet</strong></p><p>（8）<strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>传给<strong>ViewResolver</strong>视图解析器进行解析</p><p>（9）<strong>ViewResolver</strong>解析后返回具体的<strong>view</strong></p><p>（10）<strong>DispatcherServlet</strong>对<strong>View</strong>进行渲染试图</p><p>（11）<strong>DispatcherServlet</strong>响应用户</p><p><img src="https://img-blog.csdn.net/20180708224853769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt=""></p><h2 id="12-索引类型及作用"><a href="#12-索引类型及作用" class="headerlink" title="12.索引类型及作用"></a>12.索引类型及作用</h2><ol><li><strong>主键索引：</strong>数据记录里面不能有null，数据内容不能重复，在一张表里不能有多个主键索引</li><li><strong>普通索引：</strong>使用字段关键字建立索引，提高查询质量</li><li><strong>唯一索引：</strong>字段数据是唯一的，可以为null，在一张表里，是可以添加多个唯一索引</li><li><strong>全文索引：</strong>对文本内容进行分词，进行搜索</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(三):实用指令</title>
    <link href="undefined2019/11/02/Linux-3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>2019/11/02/Linux-3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h3 id="Linux系统的运行级别"><a href="#Linux系统的运行级别" class="headerlink" title="Linux系统的运行级别"></a>Linux系统的运行级别</h3><pre><code class="bash">0:关机  1:单用户(找回丢失密码)2:多用户无网络服务3:多用户有网络服务4:保留5:图形界面6:重启命令 init [0||num]系统运行级别配置文件： /etc/inittab</code></pre><p><img src="https://i.loli.net/2019/10/09/R9DjLcyuoXtGkFI.png" srcset="/img/loading.gif" alt=""></p><h5 id="如何修改已经忘记密码"><a href="#如何修改已经忘记密码" class="headerlink" title="如何修改已经忘记密码"></a>如何修改已经忘记密码</h5><p><img src="https://i.loli.net/2019/10/09/rcNa2gMqbYtGkLe.png" srcset="/img/loading.gif" alt=""></p><p>首先，在进入启动页面的时候按<strong>e</strong>键，然后会进入下面这个页面</p><p><img src="https://i.loli.net/2019/10/09/g4j2GNFevKImaQn.png" srcset="/img/loading.gif" alt=""></p><p>将光标移动到下图那一行</p><p><img src="https://i.loli.net/2019/10/09/8k4sZdrAvRgEVno.png" srcset="/img/loading.gif" alt=""></p><p>在行尾添加 <strong>init=/bin/sh</strong>,</p><p><img src="https://i.loli.net/2019/10/09/LhdHGqYpItZvMAK.png" srcset="/img/loading.gif" alt=""></p><p>添加完，按<strong>Ctrl + X</strong>执行，即可进入单用户模式</p><p><img src="https://i.loli.net/2019/10/09/JBKHTxbWS5dGYIy.png" srcset="/img/loading.gif" alt=""></p><p>然后，就可以<strong>修改密码</strong>了</p><p><img src="https://i.loli.net/2019/10/09/4wbFxDeHrJGKBm8.png" srcset="/img/loading.gif" alt=""></p><p>这里可以看见会字符不可见，你需要输入<strong>LANG=en</strong>，才能让字符可见</p><p><img src="https://i.loli.net/2019/10/09/trswoihHCvd7JGu.png" srcset="/img/loading.gif" alt=""></p><p>最后,执行<strong>exec /sbin/init</strong>即可退出单用户模式</p><p><img src="https://i.loli.net/2019/10/09/gvKOq5eVhc3FwXd.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当你对某个指令不收悉的时候，就可以使用帮助指令</p><h4 id="获得帮助信息"><a href="#获得帮助信息" class="headerlink" title="获得帮助信息"></a>获得帮助信息</h4><ul><li><p>语法</p><pre><code class="bash">man [命令||配置文件]</code></pre></li><li><p>命令演示</p><pre><code class="bash">[root@localhost ~]# man ls</code></pre><p>输入命令按<strong>回车</strong>,</p><p><img src="https://i.loli.net/2019/10/10/AnB285ODQH9RKLf.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>ls加-a可以<strong>显示隐藏文件</strong></p><p><img src="https://i.loli.net/2019/10/10/mNfp1tGsEaX38D9.png" srcset="/img/loading.gif" alt=""></p><p>ls加-l可以以<strong>另外的列表形式显示</strong></p><p><img src="https://i.loli.net/2019/10/10/eOT45wiHoPu6gys.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">[root@localhost home]# ls -a.  ..  crg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><p>命令选项不光可以单个用，也可以连用，</p><pre><code class="bash">[root@localhost home]# ls -la总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy</code></pre><h4 id="help-命令"><a href="#help-命令" class="headerlink" title="help 命令"></a>help 命令</h4><ul><li><p>基本语法</p><pre><code class="bash">help 命令</code></pre></li><li><p>实例演示</p><pre><code class="bash">[root@localhost home]# help cdcd: cd [-L|[-P [-e]]] [dir]    Change the shell working directory.    Change the current directory to DIR.  The default DIR is the value of the    HOME shell variable.    The variable CDPATH defines the search path for the directory containing    DIR.  Alternative directory names in CDPATH are separated by a colon (:).    A null directory name is the same as the current directory.  If DIR begins    with a slash (/), then CDPATH is not used.    If the directory is not found, and the shell option `cdable_vars&#39; is set,    the word is assumed to be  a variable name.  If that variable has a value,    its value is used for DIR.    Options:        -L      force symbolic links to be followed        -P      use the physical directory structure without following symbolic        links        -e      if the -P option is supplied, and the current working directory        cannot be determined successfully, exit with a non-zero status    The default is to follow symbolic links, as if `-L&#39; were specified.    Exit Status:    Returns 0 if the directory is changed, and if $PWD is set successfully when    -P is used; non-zero otherwise.[root@localhost home]# </code></pre></li></ul><hr><h3 id="查看目录类命令"><a href="#查看目录类命令" class="headerlink" title="查看目录类命令"></a>查看目录类命令</h3><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p><strong>这个命令用来显示当前工作的绝对路径</strong></p><pre><code class="bash">[root@localhost ~]# pwd/root[root@localhost ~]# </code></pre><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p><strong>该命令用来查看当前目录的所有内容</strong></p><pre><code class="bash">ls [选项] [目录||文件]</code></pre><pre><code class="bash">[root@localhost home]# lscrg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# ls -al总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p><strong>用于切换目录</strong></p><pre><code class="bash">cd [参数](指定目录)</code></pre><pre><code class="bash">[root@localhost /]# ll总用量 16lrwxrwxrwx.   1 root root    7 9月   4 20:33 bin -&gt; usr/bindr-xr-xr-x.   5 root root 4096 9月   4 20:37 bootdrwxr-xr-x.  20 root root 3220 10月 10 09:01 devdrwxr-xr-x.  75 root root 8192 10月 10 09:01 etcdrwxr-xr-x.   4 root root   27 9月  29 09:45 homelrwxrwxrwx.   1 root root    7 9月   4 20:33 lib -&gt; usr/liblrwxrwxrwx.   1 root root    9 9月   4 20:33 lib64 -&gt; usr/lib64drwxr-xr-x.   2 root root    6 4月  11 2018 mediadrwxr-xr-x.   2 root root    6 4月  11 2018 mntdrwxr-xr-x.   2 root root    6 4月  11 2018 optdr-xr-xr-x. 135 root root    0 10月 10 09:01 procdr-xr-x---.   2 root root  151 10月  9 14:26 rootdrwxr-xr-x.  24 root root  720 10月 10 09:01 runlrwxrwxrwx.   1 root root    8 9月   4 20:33 sbin -&gt; usr/sbindrwxr-xr-x.   2 root root    6 4月  11 2018 srvdr-xr-xr-x.  13 root root    0 10月 10 09:01 sysdrwxrwxrwt.  12 root root  265 10月 10 10:09 tmpdrwxr-xr-x.  13 root root  144 9月  28 15:29 usrdrwxr-xr-x.  19 root root  267 9月   4 20:37 var[root@localhost /]# cd /home[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><hr><h3 id="操作文件类命令"><a href="#操作文件类命令" class="headerlink" title="操作文件类命令"></a>操作文件类命令</h3><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p><strong>用于创建目录</strong></p><pre><code class="bash">mkdir [选项] 要创建的目录-p : 创建多级目录</code></pre><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# mkdir dog[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mkdir /home/animal/catmkdir: 无法创建目录&quot;/home/animal/cat&quot;: 没有那个文件或目录[root@localhost home]# mkdir -p /home/animal/cat[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:46 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost animal]# cd animal[root@localhost animal]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 10 13:46 cat</code></pre><h4 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h4><p><strong>rmdir命令用于删除空目录</strong></p><pre><code class="bash">rmdir [目录]</code></pre><p>删除dog目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir dog[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir animalrmdir: 删除 &quot;animal&quot; 失败: 目录非空</code></pre><p>如果要删除一个<strong>非空的目录</strong>需要用<strong>rm -rf</strong>命令</p><pre><code class="bash">[root@localhost home]# rm -rf animal[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p><strong>创建一个空的文件</strong></p><p>接下来，创建一个Hello.txt</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# touch hello.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:14 hello.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# </code></pre><p><strong>touch</strong>也可以创建多个文件</p><pre><code class="bash">[root@localhost home]# touch sb.txt dl.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:15 dl.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy-rw-r--r--. 1 root root  0 10月 10 15:15 sb.txt[root@localhost home]# </code></pre><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p><strong>拷贝文件到指定目录</strong></p><pre><code class="bash">cp [选项] [待拷贝文件] [拷贝目标]-r: 拷贝整个文件夹</code></pre><p>接下来,将a.txt<strong>拷贝到</strong>aaa目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:23 aaa-rw-r--r--. 1 root root  0 10月 10 15:23 a.txtdrwxr-xr-x. 2 root root  6 10月 10 15:25 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# cp a.txt aaa[root@localhost home]# cd aaa[root@localhost aaa]# ll总用量 0-rw-r--r--. 1 root root 0 10月 10 15:23 a.txt[root@localhost aaa]# </code></pre><p>如果，要将aaa目录拷贝到bbb目录下，</p><pre><code class="bash">[root@localhost home]# cp aaa bbbcp: 略过目录&quot;aaa&quot;[root@localhost home]# </code></pre><p>会提示一个错误，略过目录”aaa”，这个时候就需要加入选项<strong>-r</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbb[root@localhost home]# cd bbb[root@localhost bbb]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:29 aaa[root@localhost bbb]# </code></pre><p>如果，再复制一次，会提示要不要覆盖，如果默认要覆盖可以使用<strong>\cp</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbbcp：是否覆盖&quot;bbb/aaa/a.txt&quot;？ y[root@localhost home]# /cp -r aaa bbb-bash: /cp: 没有那个文件或目录[root@localhost home]# \cp -r aaa bbb[root@localhost home]# </code></pre><p>这里注意是<strong>\cp</strong>，不仔细的话容易弄反</p><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p><strong>用于移除文件或目录</strong></p><pre><code class="bash">rm [文件||目录]-r : 递归删除整个文件夹-f : 强制删除不提示</code></pre><p>删除<strong>/home/a.txt</strong>，</p><pre><code class="bash">[root@localhost home]# rm a.txtrm：是否删除普通空文件 &quot;a.txt&quot;？y[root@localhost home]# </code></pre><p>删除<strong>/home/aaa</strong></p><pre><code class="bash">[root@localhost aaa]# rm /home/aaarm: 无法删除&quot;/home/aaa&quot;: 是一个目录[root@localhost aaa]# rm -r /home/aaarm：是否进入目录&quot;/home/aaa&quot;? yrm：是否删除普通空文件 &quot;/home/aaa/a.txt&quot;？yrm：是否删除目录 &quot;/home/aaa&quot;？y[root@localhost aaa]# </code></pre><p>这里可以看出如果要删除目录，要对目录下所有文件确认是否删除，非常麻烦，所以，如果不想提示，加上<strong>-f</strong>命令强制删除<strong>/home/bbb</strong>，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 15:29 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rm -rf /home/bbb/[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p><strong>mv指令用于移动文件或重命名</strong></p><pre><code class="bash">重命名 ： mv oldNameFile newNameFile移动 ： mv /oldPath /newPath</code></pre><p>接下来，我们将<strong>/home/aaa.txt</strong>重命名为<strong>sz.txt</strong></p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root  6 10月 11 09:26 aaa.txtdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mv aaa.txt sz.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# </code></pre><p>然后，将sz.txt移动到<strong>crg</strong>目录里面，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# mv /home/sz.txt/ /home/crg/[root@localhost home]# ll总用量 0drwx------. 3 crg dw 76 10月 11 09:34 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# cd crg[root@localhost crg]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 11 09:26 sz.txt[root@localhost crg]# </code></pre><hr><h3 id="查看文件类命令"><a href="#查看文件类命令" class="headerlink" title="查看文件类命令"></a>查看文件类命令</h3><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p><strong>用来查看文件内容，以只读的方式</strong></p><pre><code class="bash">cat [选项] [目标文件]</code></pre><p>用cat的方式查看<strong>/etc/profile</strong></p><pre><code class="bash">[root@localhost ~]# cat /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091155.png" srcset="/img/loading.gif" alt=""></p><p>这里可以查看，但没有行号，我们给他设定一个行号,加上选项<strong>-n</strong></p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091429.png" srcset="/img/loading.gif" alt=""></p><p>但是，cat命令每次都会直接跑到文件末尾，让你看不清，所以，一般还会给和<strong>| more</strong>连用，</p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile | more</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091759.png" srcset="/img/loading.gif" alt=""></p><p><strong>| more</strong>用来<strong>分页显示</strong>，按<strong>空格</strong>看下一页</p><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p><strong>more命令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件内容</strong></p><p>用<strong>more命令</strong>查看文件,</p><pre><code class="bash">[root@localhost ~]# more /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095423.png" srcset="/img/loading.gif" alt=""></p><p>快捷键,</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095608.png" srcset="/img/loading.gif" alt=""></p><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><p><strong>less命令和more命令类似，但它功能更强大，不会将整个文件加载完后再显示，比more效率更高，一般用于查看大型文件</strong></p><p>接下来，用less命令查看<strong>/etc/services</strong></p><pre><code class="bash">[root@localhost etc]# less /etc/services</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/1570846827372.png" srcset="/img/loading.gif" alt=""></p><p>可以看出，它只加载了这么多就不往下显示了，</p><p><strong>less快捷键：</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012102549.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(二):用户管理</title>
    <link href="undefined2019/11/02/Linux-2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>2019/11/02/Linux-2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h3 id="Linux用户基本介绍"><a href="#Linux用户基本介绍" class="headerlink" title="Linux用户基本介绍"></a>Linux用户基本介绍</h3><blockquote><p> Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 </p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录</p></blockquote><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927160228.png" srcset="/img/loading.gif" alt=""></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code class="bash">useradd [选项] 用户名</code></pre><p>接下来，添加一个用户 dl</p><pre><code class="bash">[root@localhost ~]# useradd dl</code></pre><p>可能界面看不出什么效果，其实系统已经创建了一个叫<strong>dl的用户</strong>并创建了同名的<strong>组</strong>和 <strong>/home/dl目录</strong></p><pre><code class="bash">[root@localhost /]# cd /home/[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 lj lj 83 9月   5 09:02 lj</code></pre><p>如果你不想创建在<strong>home目录</strong>下，你还可以将<strong>用户</strong>创建在其他目录，这里我想将用户创建在<strong>/home/sb/#</strong></p><pre><code class="bash">[root@localhost home]# mkdir sb[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwxr-xr-x. 2 root root  6 9月  28 08:54 sb</code></pre><p>此时目录已经创建完毕，接着输入命令：</p><pre><code class="bash">[root@localhost home]# useradd -d /home/sb/ qyuseradd：警告：此主目录已经存在。不从 skel 目录里向其中复制任何文件。正在创建信箱文件: 文件已存在</code></pre><p>然后，给用户<strong>dl</strong>和<strong>qy</strong>设置密码:</p><pre><code class="bash">[root@localhost home]# passwd dl更改用户 dl 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@localhost home]# passwd qy更改用户 qy 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。</code></pre><p>这里我两个用户密码都设置为：<strong>12345678</strong>,就算系统提示为通过字典检查，只要你无视它，接着输入<strong>密码</strong>，还是会设置成功，然后我使用<strong>SmarTTY</strong> 登录用户 <strong>dl</strong>和<strong>qy</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928094858.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928102011.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><h5 id="1-删除用户，但保留目录"><a href="#1-删除用户，但保留目录" class="headerlink" title="1.删除用户，但保留目录"></a>1.删除用户，但保留目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 qy qy 62 9月  28 13:48 qy[root@localhost home]# userdel qy //执行删除[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwx------. 2 1002 1002 62 9月  28 13:48 qy</code></pre><h5 id="2-删除用户和目录"><a href="#2-删除用户和目录" class="headerlink" title="2.删除用户和目录"></a>2.删除用户和目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  28 14:19 dldrwx------. 2 qy qy 62 9月  28 14:19 qy[root@localhost home]# userdel -r dl  //执行删除[root@localhost home]# ll总用量 0drwx------. 2 qy qy 62 9月  28 14:19 qy</code></pre><hr><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><pre><code>id  [用户名]</code></pre><pre><code class="bash">[root@localhost home]# id rootuid=0(root) gid=0(root) 组=0(root)[root@localhost home]# id qyuid=1001(qy) gid=1001(qy) 组=1001(qy)[root@localhost home]# </code></pre><hr><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre><code>su [用户名]</code></pre><pre><code class="bash">[root@localhost ~]# su qy[qy@localhost root]$ su root密码：[root@localhost ~]# </code></pre><p>这是一种从<strong>低权限用户</strong>切换到<strong>高权限用户</strong>的方法，</p><p>还有一种</p><pre><code class="bash">[qy@localhost /]$ exitexit[root@localhost ~]# </code></pre><p>直接<strong>exit</strong>，这样就避免了输密码</p><hr><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h5 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h5><pre><code class="bash">groupadd [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupadd dang[root@localhost ~]# </code></pre><h5 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h5><pre><code class="bash">groupdel [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupdel dang[root@localhost ~]# </code></pre><h5 id="增加用户直接加上组"><a href="#增加用户直接加上组" class="headerlink" title="增加用户直接加上组"></a>增加用户直接加上组</h5><pre><code class="bash">useradd -g [组] [用户名]</code></pre><p>增加一个用户crg，分组到zf</p><pre><code class="bash">[root@localhost ~]# useradd -g zf crguseradd：“zf”组不存在[root@localhost ~]# groupadd zf[root@localhost ~]# useradd -g zf crg[root@localhost ~]# id crguid=1002(crg) gid=1002(zf) 组=1002(zf)</code></pre><p>这里我原本以为直接用命令，系统会自动帮我建组，看来我想多了😭，必须你自己建个组，然后再分组</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg zf 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><pre><code class="bash">usermod -g [用户组] [用户名]</code></pre><pre><code class="bash">[root@localhost home]# groupadd dw[root@localhost home]# usermod -g dw crg[root@localhost home]# id crguid=1002(crg) gid=1003(dw) 组=1003(dw)</code></pre><p>这样我们就把<strong>crg</strong>从<strong>zf组</strong>调到<strong>dw组</strong></p><hr><h3 id="用户的配置文件"><a href="#用户的配置文件" class="headerlink" title="用户的配置文件"></a>用户的配置文件</h3><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190929105530.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009095520.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">crg: 用户名x: 加密的密码 真正的密码在 shadow文件里1002: 用户id1003: 组id/home/crg: 用户所在home目录/bin/bash：对应的shell</code></pre><h5 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009100032.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009140544.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">dw: 组名1003: 组id</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(一):vim与vi</title>
    <link href="undefined2019/11/02/Linux-1-vim%E4%B8%8Evi/"/>
    <url>2019/11/02/Linux-1-vim%E4%B8%8Evi/</url>
    
    <content type="html"><![CDATA[<h1 id="vim与vi"><a href="#vim与vi" class="headerlink" title="vim与vi"></a>vim与vi</h1><h3 id="什么是vim？"><a href="#什么是vim？" class="headerlink" title="什么是vim？"></a>什么是vim？</h3><blockquote><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p></blockquote><h3 id="vi和vim的三种模式转化图如下"><a href="#vi和vim的三种模式转化图如下" class="headerlink" title="vi和vim的三种模式转化图如下:"></a>vi和vim的三种模式转化图如下:</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtbszrfgj30ik0a4whj.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><pre><code class="linux">[root@localhost ~]# ll总用量 4-rw-------. 1 root root 1416 9月   4 20:36 anaconda-ks.cfg[root@localhost ~]# </code></pre><p>可以看出我没有Hello.java文件</p><p>使用命令</p><pre><code class="linux">[root@localhost ~]# vim Hello.java</code></pre><p>随后进入一般模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1dy0j2nj30lf0tb3yo.jpg" srcset="/img/loading.gif" alt=""></p><p>此时还不能编辑，如果要编辑 需要按  <strong>Insert</strong> 或 按 <strong>i</strong> ，进入编辑模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1gyfv0bj30ho0a5q2v.jpg" srcset="/img/loading.gif" alt=""></p><p>当左下角出现<strong>插入</strong>的时候才能开始编辑，如图</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1jlvw60j30ib04i3ys.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，如果要保存</p><blockquote><p><strong>Shift + ; + wq</strong>(wq是 写入(wirte)并退出(queit))</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1mqs047j303p03gmwz.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>:q!</strong>是不保存退出</p><h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtnweqdbj30q90f0gr2.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="1-拷贝"><a href="#1-拷贝" class="headerlink" title="1. 拷贝"></a>1. 拷贝</h5><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dubycqkbj307105zt8s.jpg" srcset="/img/loading.gif" alt=""></p><p>首先插入一些字符,随后按<strong>ESC</strong>进入<strong>命令模式</strong>，选定一行按<strong>yy</strong>，之后按<strong>p</strong>，按一次<strong>P</strong>，粘贴一次</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7duf1mpdzj3063071dft.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，将<strong>光标</strong>移动到第一行，并按<strong>5yy</strong>（Linux的所有数字都是大键盘上的，小键盘的数字会产生其他效果）,随后按<strong>P</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dulepza4j308b02g744.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dumcpa0bj30530bajrl.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h5><p>和拷贝语法类似，我们用<strong>5dd</strong>删除五行</p><p>效果如下:</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dusx4k7gj304406gdfu.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h5><p>进入<strong>命令模式</strong>，输入<strong>/ + [关键字] + 回车</strong>即可查询,按<strong>N</strong>查找下一个</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv1j36y1j303w01ft8h.jpg" srcset="/img/loading.gif" alt=""></p><p>这里要注意Linux的查找字符是<strong>严格区分大小写</strong>的，我这里小写的sbdl就没匹配到😭</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv20n1r3j305u0ag74k.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="4-设置行号"><a href="#4-设置行号" class="headerlink" title="4.设置行号"></a>4.设置行号</h5><p>例行进入<strong>命令模式</strong>，输入 <strong>:set nu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvy3a60vj304o02e3yc.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvygdj6ej307008xq37.jpg" srcset="/img/loading.gif" alt=""></p><p>取消，行号<strong>:set nonu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzjksdfj305r023t8i.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzwzaktj3049081jrj.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="5-行尾和行首"><a href="#5-行尾和行首" class="headerlink" title="5.行尾和行首"></a>5.行尾和行首</h5><pre><code>[root@localhost ~]# vim /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>Shift + g</strong>，进入行尾</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145504.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>gg</strong>回到行首</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><h5 id="6-撤消"><a href="#6-撤消" class="headerlink" title="6.撤消"></a>6.撤消</h5><p>在<strong>编辑模式</strong>下乱输字符</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145915.png" srcset="/img/loading.gif" alt=""></p><p>随后,按<strong>ESC</strong>进入<strong>正常模式</strong>按<strong>u</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927150026.png" srcset="/img/loading.gif" alt=""></p><h5 id="7-移动光标"><a href="#7-移动光标" class="headerlink" title="7.移动光标"></a>7.移动光标</h5><p>第一步：进入<strong>编辑模式</strong>，设置行号， <strong>:set nu</strong></p><p>第二步：进入<strong>正常模式</strong>，输入你要去的行数  10 + <strong>Shift + g</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927153646.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/10/30/hello-world/"/>
    <url>2019/10/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>