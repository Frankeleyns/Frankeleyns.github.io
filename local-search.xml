<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>成功日记（三）</title>
    <link href="undefined2020/05/30/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-3/"/>
    <url>2020/05/30/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-3/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（三）"><a href="#成功日记（三）" class="headerlink" title="成功日记（三）"></a>成功日记（三）</h1><h2 id="1-梦想储蓄罐"><a href="#1-梦想储蓄罐" class="headerlink" title="1.梦想储蓄罐"></a>1.梦想储蓄罐</h2><p>周四的时候，我的<strong>梦想储蓄罐</strong>终于迎来了第一笔储蓄，虽然不多，但这第一笔储蓄意义重大，代表我拥有了<strong>钞能力</strong>（管理钱的能力）。</p><p>很庆幸因为梦想储蓄罐的存在，没有使自己变成所谓的<strong>精致穷</strong>，掉入资本主义的消费陷阱当中。</p><p>人可以有欲望，欲望是人类的本能，但我们要学会的是控制欲望，不能被欲望主导自己的行动，看到想看的东西就要买，看到想吃的东西就要吃，实在想买，也不要用花呗，借呗之类的贷款应用，透支自己未来，然后变成<strong>精致穷</strong>。可以开个梦想储蓄罐，然后自己存钱到梦想储蓄罐，钱够再买，就像自己给自己分期贷款一样，还不要付利息，自己成为自己债主，这种主宰自己的感觉不是很爽吗？</p><p>绝不当<strong>韭浪</strong>！！！</p><p><img src="https://i.loli.net/2020/05/30/Ii5HTA6ahjPdO8p.jpg" srcset="/img/loading.gif" alt="韭菜.jpg"></p><h2 id="2-购买基金"><a href="#2-购买基金" class="headerlink" title="2.购买基金"></a>2.购买基金</h2><p><strong>基金：</strong>你把钱投给某个基金机构，然后由这个机构的基金经理人来购买金融资产如股票、债券、外汇、期货等，众筹买资产，盈利了大家就分红。</p><p>购买基金的好处是什么呢？</p><p>假设你用<strong>1000￥</strong>以每股<strong>100￥</strong>的价格购买了<strong>10股</strong>腾讯的股票。但现在这只股票跌了40%，于是你不能再以每股100￥，而只能以每股<strong>60￥</strong>(60% x 100￥)卖出去，如果你把它全卖了，那么你就只剩下<strong>600￥</strong>了。</p><p>而股票型基金则至少会购买<strong>10种</strong>股票，还是以<strong>1000￥</strong>为例，假设现在用这些钱购买了10种不同的股票，除了腾讯还买了阿里，京东之类的，腾讯的股票跌了40%，而其他股票还保持原来的水平，那么我们还有<strong>960￥</strong>（1000￥ - 100￥ x 60%），这样你就只损失<strong>4%</strong>。而实际情况，可能会跌几只股票，但总体还是涨的。</p><blockquote><p>挑选基金时的注意事项:</p><p>1    基金至少有十年历史。假如它在这么长时间内一直有丰厚的盈利，那么我们认为，它在未来十年也将运作良好。</p><p>2    应该选择大型的跨国股票基金。这种基金在是世界各地购买股票，以此分散风险，所以十分安全。</p><p>3   对基金走势图进行比较，我们应该观察在过去10年间哪些基金获利最好。</p><p>  ————摘自《小狗钱钱》第十六章</p></blockquote><p>这三个规则不一定在中国内地完全适用，但可以作为参考。</p><p>如果你要买基金我推荐<strong>支付宝</strong>，里面可以看基金排行和基金机构的信息。</p><p>我就是以这三个原则为基础，去支付宝投了四只不同类型的基金，包括指数型，债券型，股票型和混合型。</p><p>希望股神保佑，让我赚点小钱🙏🙏🙏</p><p><img src="https://i.loli.net/2020/05/30/63R971QJpYnvVOU.jpg" srcset="/img/loading.gif" alt="Buffett.jpg"></p><h2 id="3-开始夜读"><a href="#3-开始夜读" class="headerlink" title="3.开始夜读"></a>3.开始夜读</h2><p>前不久刚刚关注了<strong>人民日报</strong>公众号，每天23：00都会给大家推送夜读推文，里面都是非常正能量的文章，关于交友，自律，人生等等。刚好我上次又买了些书，不看那不就浪费了吗? </p><p>于是我给自己也来个夜读，每天晚上1个小时，从22：00到23：00，顺便写写读书笔记，水一下成功日记，一举多得。</p><p>芜湖，起飞~</p><p><img src="https://i.loli.net/2020/05/30/hLKd9uyIiS6fQgb.jpg" srcset="/img/loading.gif" alt="book.jpg"></p><h2 id="4-《爱的博弈》阅读笔记"><a href="#4-《爱的博弈》阅读笔记" class="headerlink" title="4.《爱的博弈》阅读笔记"></a>4.《爱的博弈》阅读笔记</h2><p><strong>出轨是怎样产生的？</strong></p><p>1.忽略或轻视另一边的情绪</p><p>当生活发生重大变化时，比如父母去世，疾病或子女出现问题。此时，双方背景，理念和性格差异变得格外突出。如果一个人发出连接请求，却发现另一个人“不见了”，此时双方不能就这件事坐下来开诚布公的谈谈的话，那么失望孤独就会泛滥，造成双方信任水平降低，伴侣们为了不让情况变得更糟，就会尽量避免冲突，从而产生<strong>蔡格尼克效应</strong>(指人们对于尚未处理完的事情，比已处理完成的事情印象更加深刻)</p><p>2.消极对比（Negative COMP）</p><p>如果一个男人对他爱的妻子微笑，她也回应一个，他可能会想：“噢，笑的多美啊。她让我没办法再爱上别的女人。”但是过几天，她的微笑可能没有那么灿烂了，这就会使那个男人失望，这时他可能会想：“哼！我在调情，她都没反应！我打赌那边的辣妹一定比她有反应。”这种看起来无关紧要的消极对比并不会伤害感情，但这种想法次数多了，就会导致疏远，最终奔向背叛的深渊。</p><blockquote><p>伴侣出轨不是一夜之间的事，他们是在不知不觉种以一种缓慢到无法察觉的速度滑向这条不归之路的。从不再信任彼此，到找到新的知己，再到突破底线，婚恋关系本身才常常是导致外遇的原因。 ————摘自《爱的博弈》第三章</p></blockquote><p><strong>公众号 成长的青年 内回复：爱的博弈，即可获得PDF电子书</strong></p><h2 id="5-Keep"><a href="#5-Keep" class="headerlink" title="5.Keep"></a>5.Keep</h2><p>这周三个课程都给他做完咯👇</p><p><img src="https://i.loli.net/2020/05/31/dfjoiblZtV5LWqz.jpg" srcset="/img/loading.gif" alt="Keep.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（二）</title>
    <link href="undefined2020/05/24/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-2/"/>
    <url>2020/05/24/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（二）"><a href="#成功日记（二）" class="headerlink" title="成功日记（二）"></a>成功日记（二）</h1><h2 id="1-规划自己的理财计划"><a href="#1-规划自己的理财计划" class="headerlink" title="1.规划自己的理财计划"></a>1.规划自己的理财计划</h2><p>首先，收入的50%拿来养我的鹅，如果不知道鹅是什么，请参考我的<strong>成功日记(一)</strong>，</p><p>剩下的50%中<strong>减1200￥</strong>每月的生活开支，这还是没付房租的情况，如果自己租房起码还得再<strong>加1000￥</strong>，变成<strong>2200￥</strong></p><p>最后剩下的钱，放进<strong>梦想储蓄罐</strong>中</p><p>这里有的朋友可能就要问了那什么是<strong>梦想储蓄罐</strong>呢？</p><blockquote><p>“随便拿一个罐子，作为储蓄罐。然后在这个罐子上写上你的梦想。要为每一个梦想准备一个储蓄罐，一旦储蓄罐准备好，你就应当把省下的每一分钱放进去。”———摘自《小狗钱钱》第二章</p></blockquote><p>我不会真的傻傻的真拿瓶瓶罐罐来，我自己用微信收藏功能建了一篇笔记，用来当我的梦想储蓄罐，一篇笔记对应一个梦储蓄罐，并配上<strong>梦想相册</strong>(也是小狗钱钱里的概念)：</p><p><img src="https://i.loli.net/2020/05/24/IxSPyvBjtHJEAu4.jpg" srcset="/img/loading.gif" alt="note8.jpg"></p><h2 id="2-《爱的博弈》阅读分享"><a href="#2-《爱的博弈》阅读分享" class="headerlink" title="2.《爱的博弈》阅读分享"></a>2.《爱的博弈》阅读分享</h2><p><img src="https://i.loli.net/2020/05/23/Vsb6KOaQwp3dfLU.png" srcset="/img/loading.gif" alt="LoveBook.png"></p><p>这本书讲教你如何经营婚恋关系，以及处理婚姻问题。</p><p>（关注公众号“<strong>成长的青年</strong>”，回复：爱的博弈，即可获取电子书）</p><p>下面分享一些概念：</p><p><strong>滑动门时刻(sliding door moment)：</strong>当一个人表达出联结的需要时，另一个人的反应可以是拉开门走过去，也可以是关上门转身离开。这是发展亲密关系的关键时刻。</p><ul><li>“我看起来怎么样？” （注意听我说话）</li><li>“你站起来时能顺便帮我把调味酱拿过来吗？”（答应我的小请求）</li><li>“咱们现在去把珍妮哄上床吧”（帮助我，或者和我一起做）</li><li>“你觉得我做的怎么样”（对我的成就表现出兴趣和兴奋）</li><li>“你能帮我填这张表吗？”（回答我的问题，为我提供信息）</li><li>“我要和你说我妈打电话过来发生的事”（和我聊天）</li><li>“工作室有什么趣事/麻烦吗？”（与我分享你今天的经历）</li><li>“不知道我跟你说过没有？”（对我讲的趣事有所回应）</li><li>“我觉得我今天演讲搞砸了”（帮我减压）</li><li>“你觉得我应该怎么对付老板”（帮我解决问题）</li><li>“过来嘛，我想看书的时候被你抱着”（表现亲昵之情）</li><li>“咱们来玩大富翁吧”（陪我玩）</li><li>“咱们来学英语吧！”（跟我一起学习）</li></ul><p>以上都是一些滑动门时刻，处理好了就会达成“面向(turing towards)”伴侣，你们的感情会升温，更亲密，处理不好那就是“背向（turing away from）”伴侣，不重视这些婚恋关系中的小要求，经年累月下去就会使其中一方产生信任危机，最终结果就是这段关系掉入深渊。</p><p>该书的作者为<strong>约翰 戈特曼</strong>，他对人际关系、婚姻关系及家庭关系进行了长达40年的研究。被美国媒体誉为 <strong>“婚姻教皇”</strong>。</p><p>看这本书也就图一乐，真想学恋爱还得看我网恋教父-孙笑川</p><p><img src="https://i.loli.net/2020/05/23/YqfKElFMI26cXN1.png" srcset="/img/loading.gif" alt="SunDog.png"></p><h2 id="3-想要变富裕的十个理由"><a href="#3-想要变富裕的十个理由" class="headerlink" title="3.想要变富裕的十个理由"></a>3.想要变富裕的十个理由</h2><p>1.获得钞能力(掌控钱的能力)💴</p><p>2.买个小房子🏠</p><p>3.整台小车子🚗</p><p>4.恰饭，吃遍各种美食🍔</p><p>5.买自己喜欢的科技产品💻</p><p>6.发展自己的兴趣爱好🎮</p><p>7.买书📕</p><p>8.环游全世界🌏</p><p>9.找老婆👧</p><p>10.为国家做点微小的贡献🀄</p><p>子曰：富而可求也，虽执鞭之士，吾亦为之 ——论语 述而，这句话的意思是，如果是合乎道义的财富，虽然只是做个“执鞭之士”，我也会去做，这里的“执鞭之士”指的是 市场守门人，现代人称保安。</p><p>大圣人孔子都认为合义的财富是可以追求的，即使是做一个保安，那么你还有什么理由不变富呢？</p><p><img src="https://i.loli.net/2020/05/23/73OlavspNwCDzrI.png" srcset="/img/loading.gif" alt="Security.png"></p><h2 id="4-公众号被关注"><a href="#4-公众号被关注" class="headerlink" title="4.公众号被关注"></a>4.公众号被关注</h2><p>上周发了成功日记（一），本来是写给自己的看的，却胆儿肥<del>不要脸</del>的发到了朋友圈，丢给了别人看，还有好兄弟给我点了关注🙏</p><p>每次写东西的过程中我都蛮享受的，沉浸在自己的世界之中，写出想讲的话，表明想表的意，配出合理的图，图文并茂的文章比纯文字文章更给我一种有理有据的感觉。</p><p>写的不好被骂了，就当练习受挫能力，写的好，被夸了，那就继续加油！</p><p>无论怎样，我都不亏。</p><p><img src="https://i.loli.net/2020/05/24/Kf7OtvI8HAouSmq.jpg" srcset="/img/loading.gif" alt="DaSiMa.jpg"></p><h2 id="5-继续Keep"><a href="#5-继续Keep" class="headerlink" title="5.继续Keep"></a>5.继续Keep</h2><p>这周做了<strong>超级胸肌训练</strong>和<strong>腹肌塑造强化</strong>，国际惯例</p><p><img src="https://i.loli.net/2020/05/24/BhaRfnFbDLiMrUp.jpg" srcset="/img/loading.gif" alt="sports.jpg"></p><p>我练的这三个运动都是徒手的，为啥不买健身器材或去健身房呢？一个字，穷。看B站的时候刷到美国人街头健身，人家在街头都可以练出好看的肌肉，我难道不能自己在家徒手练吗？健身没有借口只有你想不想，是否坚持。</p><p>有位大佬，自己在家坚持健身，明明八十多岁了看起来却还像五十岁的小伙子似的，那就是钟南山院士，以院士为目标，希望等我到那个年纪能赶得上他一半</p><p><img src="https://i.loli.net/2020/05/24/veWgNBlTuUPtDEd.jpg" srcset="/img/loading.gif" alt="keep.jpg"></p><h2 id="6-签三方协议"><a href="#6-签三方协议" class="headerlink" title="6.签三方协议"></a>6.签三方协议</h2><p>我们学校规定每个学生去公司工作都要签三方协议，即学生，企业，学校的共同协议，该协议是为了保障学生权益，签完还可以领取深圳市社保局的<strong>就业补贴</strong>。</p><p>我们公司有点特殊，签的是第三方劳务派遣协议，劳务派遣公司不同意合同中的一条，所以没答应和我签</p><p>后来，我们公司人事直接去和系里领导沟通，弄了份新的三方协议。</p><p>我在第一层，而我把我公司想成了第二层，其实公司在第五层，老千层饼了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成功日记（一）</title>
    <link href="undefined2020/05/16/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-1/"/>
    <url>2020/05/16/%E6%88%90%E5%8A%9F%E6%97%A5%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<h1 id="成功日记（一）"><a href="#成功日记（一）" class="headerlink" title="成功日记（一）"></a>成功日记（一）</h1><h2 id="1-阅读完《小狗钱钱》"><a href="#1-阅读完《小狗钱钱》" class="headerlink" title="1.阅读完《小狗钱钱》"></a>1.阅读完《小狗钱钱》</h2><p><del>这是本好书。</del></p><p><del>完。</del></p><p>开个小玩笑，下面我要开始BB了</p><p>这本书是欧美最畅销的<strong>财富启蒙书籍</strong>，归类为童话书籍，是给孩子看的，这本书要表达的观点也很简单，让你自己变的富有吧！</p><p>故事讲的是一个叫吉娅的小女孩，她有一条会说话的狗叫——钱钱，然后吉娅在钱钱的帮助下达到人生巅峰，变成了一个富婆！！！</p><p>总结起来就是这么简单。</p><p><img src="https://i.loli.net/2020/05/16/yGHN3DX8EsrecWY.jpg" srcset="/img/loading.gif" alt="rich woman.jpg"></p><p>从小到大我周围的人他们都告诉我，有钱人都是坏人。他们剥削劳动人民；他们爱装，喜欢炫富；他们欺骗消费者；他们还老是出轨（并没有针对强东的意思）；总之，他们无恶不作。每个人都在骂有钱人，但每个人又都想成为有钱人。</p><p>《小狗钱钱》这本书虽然只是一本童话书籍，但里面涉及到的概念却是成年人看了都受益匪浅。</p><ul><li><p><strong>正确的金钱观</strong></p><p><strong>钱是中性的，钱本身没有属性，它不会让一个人变得幸福，也不会带来不幸，但它会暴露一个人的本性。</strong></p><p>比如，小马哥和我，同时获得一个亿，且获得这一个亿是完全无代价的<del>不需要向富婆卖身</del>，我可能会用这一个亿去买豪宅、开豪车、把英雄联盟和王者荣耀全英雄全皮肤都给他买了、请个米其林厨师团伙专门做饭给我吃、还要去澳门赌场看美女荷官在线发牌、请美女女仆在家拖地，总之各种享受，然后等钱花完了就混吃等死。</p><p>人家小马哥却会拿这一个亿，让企鹅公司在招点游戏开发人才，开发好玩的游戏，让英雄联盟或王者多发布几个又好看又贵的皮肤，然后把我和其他人的钱都赚走。</p><p>看到了吗？这就是会用钱在不同人手里的结果。</p><p><img src="https://i.loli.net/2020/05/16/YCEUPx7MqitBrs2.jpg" srcset="/img/loading.gif" alt="mht1.jpg"></p></li><li><p><strong>养一只自己的鹅</strong>(会下金蛋的那种）</p><p>其中鹅是你的<strong>储蓄</strong>，金蛋就是<strong>利息</strong>，大多数人没有会下金蛋的鹅，是因为他们觉得需要很多钱，反正存不了那么多钱，不如破罐子破摔，花掉得了。</p><p>其实你需要的钱比你想象的要少的多，如果你有30万，而你能得到12%的利息，那你每年利息就是36000￥，每个月就是3000￥，而利息12%靠合理投资是可以实现的，看吧，没你想的那么难，假设你每个月工资5000￥，你一年就是6万，然后你每个月将一半的工资都存起来养你的鹅，那么十年后你就有30万了，存钱期间你还可以拿你存的钱去投资，所以不用十年30万就能到手，然后再拿这30万去投资，再等十年，能赚多少？60万？100万？</p><p>做着干嘛，还不去楞？</p></li></ul><h2 id="2-开始写成功日记"><a href="#2-开始写成功日记" class="headerlink" title="2.开始写成功日记"></a>2.开始写成功日记</h2><blockquote><p>“你拿一个空本子或者一本日记本，给它取个名字叫做 ‘成功日记‘ 。然后你就把所有做成功的事都记录进去。你最好每天都做这件事，每次至少写五条你个人的成果。任何小事都可以。开始的时候也许你觉得不太容易。也许你会问自己，这件或那件事情是否真的可以算作成果。在这种情况下，你永远应该做出肯定的回答。过于自信总好过没有自信“  ———摘自《小狗钱钱》第三章</p></blockquote><p>成功日记也是我从《小狗钱钱》里看到的，这个日记最大的作用就是可以帮你<strong>树立自信心</strong>。</p><p>其实现实中很多看似不可能的事，比如减肥，赚钱，别人可以做到，你也可以，你不成功的原因，可能只是少了一点点自信心而已。</p><p>我以后每个星期会将我的成功日记写出来，用我的键盘写，我的字太丑，太恶心，写出来的日记自己都不敢看。</p><p>每个人都是充满能量的炸药包，只不过缺乏一段引线，成功日记就可以做你的引线激发出你的潜能，如果你坚持的写它的话，一段时间后你就会变成一个充满自信的人。</p><p><img src="https://i.loli.net/2020/05/16/roewuIlMXUkVgWH.jpg" srcset="/img/loading.gif" alt="Thumbs.jpg"></p><h2 id="3-做完Keep中自己的课程"><a href="#3-做完Keep中自己的课程" class="headerlink" title="3.做完Keep中自己的课程"></a>3.做完Keep中自己的课程</h2><p>我的Keep中只参加了三个课程：</p><p><strong>腹肌塑造强化（K4）,</strong> <strong>超级胸肌训练-老韩霸气（K4）,</strong> <strong>篮球弹跳-稳定性（K3）</strong></p><p><img src="https://i.loli.net/2020/05/16/X1eZo5ykdULwlDs.jpg" srcset="/img/loading.gif" alt="Keep1.jpg"></p><p>我的课程很少，但有时候少即是多，之前我刚用Keep的时候收藏了很多课程，比如，人鱼线塑造，腹肌撕裂者等等，但最后都没练，只是把它放在那里，而且也没有那么多时间去练那些课程，健身的目的在于<strong>持之以恒，培养自律</strong>，而不是看你健身的课程的多少，所以我就把那些课程全部取消，只留下我觉得对我最有用的三个课程。</p><p>这三个课程我以九天为一个周期，比如1号做 腹肌塑造强化，做完休息两天(2号，3号)，然后4号做 超级胸肌训练，再休息两天(5号，6号)，接着7号做篮球弹跳，休息两天，又开始做 腹肌塑造，这是我的锻炼方式，并且我已经坚持一年了。大家也可以安排适合自己的锻炼方式，课程不一定要很多或者难度很高，但一定要<strong>坚持训练</strong>。</p><p><strong>加油，奥利给，更自律的人更自由！</strong></p><p><img src="https://i.loli.net/2020/05/16/pBHkI74oK8qWO3G.jpg" srcset="/img/loading.gif" alt="Ohligei.jpg"></p><h2 id="4-将公众号用起来"><a href="#4-将公众号用起来" class="headerlink" title="4.将公众号用起来"></a>4.将公众号用起来</h2><p>我的公众号2019年就申请了，本来是想用来做微信开发的，结果发现微信开发要商业用户，也就是要有个自己的公司才能进行开发，于是后面我又打算拿它来做写技术文章，但我用微信公众号的编辑页面，用的不顺手，和简书，知乎一比，不够方便，然后就没有然后了，其实自己懒也算一个原因。</p><p>想写公众号主要是受到B站一个up主的影响—— <strong>半佛仙人</strong>。一个有趣的大胖子，很皮，喜欢说一些无厘头的话，入坑是看他讲 <strong>瑞辛咖啡如何暴打资本主义</strong>，如何噶资本主义韭菜，建议没看过的童鞋的可以安排一下真的很有意思，保证你会喜欢上这个爱<strong>叫观众老公</strong>的男人(被别人叫我老公会感觉有一点点羞耻呢)。</p><p>反正我的公众号闲着也是闲着，不如就把我的成功日记丢里面给人看好了，就算没人看，自己在网络上有一块属于自己的小天地，我可以在这里疯狂造作也不失为一种乐趣不是吗？</p><p><strong>现实中我唯唯诺诺，网络上我重拳出击！！！</strong></p><p>键盘侠的快乐往往都是这么的朴实无华且枯燥。</p><p><img src="https://i.loli.net/2020/05/16/ktbMNDCSWIrmJ3g.png" srcset="/img/loading.gif" alt="KeyboardMan.png"></p><h2 id="5-给看完的读者大人们分享资源"><a href="#5-给看完的读者大人们分享资源" class="headerlink" title="5.给看完的读者大人们分享资源"></a>5.给看完的读者大人们分享资源</h2><p><strong>《小狗钱钱》PDF电子书：</strong><br>链接：<a href="https://pan.baidu.com/s/1KX3IgWaNt2_agFkaDODFzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1KX3IgWaNt2_agFkaDODFzw</a><br>提取码：xdkc</p>]]></content>
    
    
    
    <tags>
      
      <tag>成功日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop(二):Hadoop单节点环境搭建</title>
    <link href="undefined2020/04/19/Hadoop-2-Hadoop%E5%8D%95%E8%8A%82%E7%82%B9%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>2020/04/19/Hadoop-2-Hadoop%E5%8D%95%E8%8A%82%E7%82%B9%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Hadoopd单节点环境搭建"><a href="#Hadoopd单节点环境搭建" class="headerlink" title="Hadoopd单节点环境搭建"></a>Hadoopd单节点环境搭建</h1><h2 id="Hadoop运行环境"><a href="#Hadoop运行环境" class="headerlink" title="Hadoop运行环境"></a>Hadoop运行环境</h2><ul><li>操作系统：Linux(CentOS 7) </li><li>Java环境：jdk1.8+</li><li>Hadoop环境：CDH5.x.x</li><li>SSH</li></ul><p>如果你没服务器，可以自己用<strong>VMware</strong>搭一个<strong>Linux CentOS 7</strong>系统环境</p><p>虽然，Hadoop是一个分布式框架，但是我们学习的时候没必要一上来就一定要搭个集群，这样到时候还没开始学，搭集群环境的报错就先让你放弃了，可谓，从入门到放弃，这里建议，先学单节点(一台服务器)的Hadoop，等你学会了之后，你再去搭集群操作，就会发现原来也不是很难，千万不要一口吃成大肥仔🐷</p><h2 id="安装JAVA环境"><a href="#安装JAVA环境" class="headerlink" title="安装JAVA环境"></a>安装JAVA环境</h2><p><a href="https://growthlj.github.io/2020/03/04/Linux-4-安装JAVA环境/" target="_blank" rel="noopener"><strong>请参考这篇文章：Linux安装JAVA环境(jdk1.8)</strong></a></p><h2 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h2><p><a href="https://growthlj.github.io/2020/03/09/Linux-5-安装SSH/" target="_blank" rel="noopener"><strong>请参考这篇文章：SSH免密登录</strong></a></p><p>这里要注意的是，因为配置的是单机版的Hadoop，所以你要免密登录本机</p><pre><code class="bash">$ ssh localhost</code></pre><h2 id="安装CDH"><a href="#安装CDH" class="headerlink" title="安装CDH"></a>安装CDH</h2><p>这里有的小朋友可能就要问了，这个<strong>CDH</strong>是个什么东西？</p><p>众所周知Hadoop是一个开源软件，而<strong>CDH</strong>是<strong>Cloudera公司</strong>在原有的Hadoop基础上，加了一些东西，使它比原有的Apache Hadoop更稳定，更好用的版本，你可以把<strong>CDH</strong>简单的理解为<strong>企业级Hadoop</strong>，就类似<strong>IDEA</strong>一样，分为<strong>社区级</strong>和<strong>企业级</strong>。</p><h3 id="一-下载CDH"><a href="#一-下载CDH" class="headerlink" title="一.下载CDH"></a>一.下载CDH</h3><p><a href="https://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">CDH下载地址</a></p><p>这里我使用的是<strong>CDH5.15.1</strong>版本，图中箭头指的那个就是</p><p>下完后把它，传到你的服务器，建议用<strong>WinSCP</strong>，这里不详细介绍WinSCP用法了，别问问就是<strong>自己百度</strong></p><p><img src="https://i.loli.net/2020/03/03/4JU9fMN7BWq6kSC.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">$ lltotal 740364-rwxrwxr-x 1 hadoop hadoop 434029516 Oct 15  2018 hadoop-2.6.0-cdh5.15.1.tar.gz</code></pre><p>我这里已经传到了我的~/software目录下</p><h3 id="二-解压"><a href="#二-解压" class="headerlink" title="二.解压"></a>二.解压</h3><pre><code class="bash">$ tar -zxvf hadoop-2.6.0-cdh5.15.1.tar.gz -C ~/app/</code></pre><p>将hadoop解压到我的app目录下，确认解压成功</p><pre><code class="bash">$ lltotal 0drwxr-xr-x 14 hadoop hadoop 241 Aug 10  2018 hadoop-2.6.0-cdh5.15.1</code></pre><h3 id="三-修改Hadoop配置"><a href="#三-修改Hadoop配置" class="headerlink" title="三.修改Hadoop配置"></a>三.修改Hadoop配置</h3><p>编辑解压后的hadoop，<strong>etc/hadoop/hadoop-env.sh</strong>文件</p><pre><code class="bash">$ vim etc/hadoop/hadoop-env.sh# The java implementation to use.# export JAVA_HOME=${JAVA_HOME}export JAVA_HOME=/home/hadoop/app/jdk1.8.0_241 </code></pre><p>编辑<strong>etc/hadoop/core-site.xml</strong></p><pre><code class="bash">$ vim etc/hadoop/core-site.xml&lt;configuration&gt;# fs为FileSystem，配置默认文件系统位置    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://hadoop8:8020&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>value的值为文件系统指向的主机名以及端口号，也可以使用官方默认的9000端口</p><p>编辑<strong>etc/hadoop/hdfs-site.xml</strong></p><pre><code class="bash">$ vim etc/hadoop/hdfs-site.xml&lt;configuration&gt;# 副本节点个数    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;# hadoop.tmp.dir默认为系统的tmp目录，重启会被清空，所以我们这自己建一个tmp目录存放Hadoop缓存的文件    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/home/hadoop/app/tmp&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>编辑<strong>etc/hadoop/slaves</strong></p><p>Hadoop使用的是<strong>Master/Slave</strong>结构，即<strong>主从结构</strong>，这个slaves文件就是从节点地址，我们配置的是单节点，所以直接可以用默认localhost，也可以修改为你的主机名</p><pre><code class="bash">$ vim etc/hadoop/slaves#修改为你自己主机的主机名hadoop8</code></pre><h3 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h3><h2 id="悄悄告诉你🤐"><a href="#悄悄告诉你🤐" class="headerlink" title="悄悄告诉你🤐"></a>悄悄告诉你🤐</h2><p>我这里有一个已经搭建好<strong>Hadoop环境</strong>的镜像，下载下来用<strong>VMware</strong>打开就行</p><p><a href="https://pan.baidu.com/s/1O-aKM9Nnxppa_K1A19rDxA" target="_blank" rel="noopener"><strong>点我有惊喜(提取码：qbc2)</strong></a></p><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">Hadoop单节点配置官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(五)：SSH免密登录</title>
    <link href="undefined2020/03/09/Linux-5-%E5%AE%89%E8%A3%85SSH/"/>
    <url>2020/03/09/Linux-5-%E5%AE%89%E8%A3%85SSH/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h1><p><strong>SSH(Secure Shell)</strong>是一种<strong>网络协议</strong>，用于计算机之间的<strong>加密登录</strong>。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p><p>想进一步了解的话可以，参考阮一峰老师的<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">博客</a></p><h2 id="一-配置Hosts"><a href="#一-配置Hosts" class="headerlink" title="一.配置Hosts"></a>一.配置Hosts</h2><p>配置你的hosts，不配置会导致ssh登录无效</p><pre><code class="bash">$ sudo vim /etc/hosts</code></pre><p>添加服务器所对应的IP和主机名</p><p><img src="https://i.loli.net/2020/03/09/6zhtRGrVs2laPAT.png" srcset="/img/loading.gif" alt="ssh-hosts.png"></p><h2 id="二-生成密钥"><a href="#二-生成密钥" class="headerlink" title="二.生成密钥"></a>二.生成密钥</h2><p>在<strong>hadoop000</strong>用命令生成<strong>SSH密钥</strong>，接着，按三下回车就好</p><pre><code class="bash">$ ssh-keygen -t rsa</code></pre><p><img src="https://i.loli.net/2020/03/06/lGMkCYLPdoV8yni.png" srcset="/img/loading.gif" alt="ssh-keygen"></p><p>然后，进入<strong>.ssh</strong>文件夹，查看目录，会发现多了两个文件，<strong>id_rsa(私钥)</strong>和<strong>id_rsa.pub(公钥)</strong></p><p><img src="https://i.loli.net/2020/03/06/rl7G81CyxpAumYg.png" srcset="/img/loading.gif" alt=""></p><h2 id="三-公钥登录"><a href="#三-公钥登录" class="headerlink" title="三.公钥登录"></a>三.公钥登录</h2><p>用<strong>ssh-copy-id</strong>命令，将<strong>hadoop000</strong>生成的公钥传到<strong>hadoop8</strong>，@前面是目标用户名，@后面为目标服务器IP，如果用户名不同，还是要密码登录</p><pre><code class="bash">$ ssh-copy-id hadoop@192.168.1.8</code></pre><p><strong>hadoop8</strong>的<strong>.ssh</strong>目录会多出来一个<strong>authorized_keys</strong>的文件，然后设置一下权限</p><pre><code class="bash">$ chmod 600 authorized_keys #如果不设置，可能会因为权限问题不能免密登录</code></pre><p>用<strong>hadoop000</strong>ssh登录<strong>hadoop8</strong>，登录的时候不用输入密码了，<strong>SSH配置成功</strong></p><p><img src="https://i.loli.net/2020/03/09/ZSRxlpLfwJuk8Kt.png" srcset="/img/loading.gif" alt="ssh-success.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(四):安装JAVA环境(jdk1.8)</title>
    <link href="undefined2020/03/04/Linux-4-%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/"/>
    <url>2020/03/04/Linux-4-%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-JAVA环境-jdk1-8"><a href="#安装-JAVA环境-jdk1-8" class="headerlink" title="安装 JAVA环境(jdk1.8)"></a>安装 JAVA环境(jdk1.8)</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p><strong>下载jdk1.8</strong></p><p>进入Oracle官网下载页面</p><p><img src="https://i.loli.net/2020/03/04/SIwEvHBJ56gzUtr.png" srcset="/img/loading.gif" alt=""></p><p>如果你下的很慢的话，我给你贴心的准备好了我下好了的    <a href="https://pan.baidu.com/s/1_toI_omzKLYwinFo60BpRA" target="_blank" rel="noopener">点我(提取码：guk0)</a></p><p>下好后可以用<strong>WinScp</strong>或<strong>XFTP</strong>自行上传到自己的服务器目录，如果不会的话，我建议你<strong>百度</strong></p><p>我这里将JDK传到了我的<strong>~/software</strong>目录，我建议你们也可以自己建个software目录专门存放要安装的软件包</p><p><img src="https://i.loli.net/2020/03/04/Twra1WCDXcSZkoN.png" srcset="/img/loading.gif" alt="linux"></p><p>这里可以看到我的<strong>software</strong>目录已经有我上传的jdk了</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p><strong>解压</strong>已经传到服务器的jdk文件</p><p>使用<strong>tar</strong>命令将software目录下的jdk解压到app目录</p><pre><code class="bash">tar -zvxf jdk-8u241-linux-x64.tar.gz  -C ~/app</code></pre><p>解压完进入查看一下</p><pre><code class="bash">[hadoop@hadoop000 ~]$ lsapp   Desktop    Downloads  maven_resp  Pictures  README.txt  software   t.txtdata  Documents  lib        Music       Public    shell       Templates  Videos[hadoop@hadoop000 ~]$ cd app[hadoop@hadoop000 app]$ lshadoop-2.6.0-cdh5.15.1  hive-1.1.0-cdh5.15.1  jdk1.8.0_241  tmp[hadoop@hadoop000 app]$ cd jdk1.8.0_241/[hadoop@hadoop000 jdk1.8.0_241]$ pwd/home/hadoop/app/jdk1.8.0_241</code></pre><p>可以看到我的jdk已经解压到app目录了，路径是<strong>/home/hadoop/app/jdk1.8.0_241</strong></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p><strong>配置环境变量</strong></p><p>编辑环境变量文件</p><pre><code class="bash">vim ~/.bash_profile</code></pre><p>找个地方，添加下面这段</p><pre><code class="bash">export JAVA_HOME=/home/hadoop/app/jdk1.8.0_241export PATH=$JAVA_HOME/bin:$PATH</code></pre><p><img src="https://i.loli.net/2020/03/04/FZrAkKRNPIL71XT.png" srcset="/img/loading.gif" alt=""></p><p>使环境变量生效</p><pre><code class="bash"> source ~/.bash_profile</code></pre><p>使用java命令，验证生效情况</p><pre><code class="bash">java</code></pre><p><img src="https://i.loli.net/2020/03/04/P3ncaNAEDtiUqrb.png" srcset="/img/loading.gif" alt=""></p><p>出现，如图所示情况，安装成功😀</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在配置环境变量的时候，一般网上都是</p><pre><code class="bash">vim /etc/profile</code></pre><p>而我的是<strong>.bash_profile</strong>，这两者的区别再去</p><p><strong>/etc/profile：</strong>这个配置文件是对<strong>所有系统用户</strong>生效</p><p><strong>.bash_profile：</strong>这个配置文件是对<strong>当前登录</strong>生效</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弹钢琴吗？用键盘的那种(一):The Game is On</title>
    <link href="undefined2020/02/28/Pinao-1-TheGameIsOn/"/>
    <url>2020/02/28/Pinao-1-TheGameIsOn/</url>
    
    <content type="html"><![CDATA[<h1 id="The-game-is-on钢琴曲谱"><a href="#The-game-is-on钢琴曲谱" class="headerlink" title="The game is on钢琴曲谱"></a>The game is on钢琴曲谱</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> <strong>本曲用于在<a href="https://www.autopiano.cn/" target="_blank" rel="noopener">自由钢琴</a>弹奏，帮助同志们在闲暇之余，接受艺术的洗礼，陶冶自己的情操，升华自己的灵魂😀</strong></p><p><img src="https://i.loli.net/2020/02/28/v54Pb8eZOM21NCf.png" srcset="/img/loading.gif" alt="AutoPiano.png"></p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><div><table>        <thead>            <tr>                <th >描述</th>                <th >语法</th>            </tr>        </thead>        <tbody>            <tr>                <td>白键</td>                <td >0-9 a-z (小写字母)</td>            </tr>            <tr>                <td>黑键，需要按住<strong>Shift键</strong></td>                <td ><strong>!@$%^*(</strong> 和 A-Z (大写字母)</td>            </tr>            <tr>                <td><strong>同时</strong>按下abc三个键</td>                <td >[abc]</td>            </tr>            <tr>                <td>以一定间隔按下a b c 三个键</td>                <td >a b c</td>            </tr>            <tr>                <td>延音 ~</td>                <td >a~ 或 a~~</td>            </tr>        </tbody>    </table></div><p><strong>t   o   o   I   o   O   o   t   s   t   s   s   a   s   d   s   D</strong></p><p><strong>h   s   s   d   D   d   D   d   s   g   s   s   d   D   D   g   d   d   D   s   s   d   a   O   o   s</strong></p><p><strong>v   l   l   z   Z   z   Z   z   l   c   l   l   z   Z   Z   c   z   z   Z   l   l   z   k   H   h   l</strong></p><h2 id="音名"><a href="#音名" class="headerlink" title="音名"></a>音名</h2><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1177649593,2842240244&fm=173&app=25&f=JPEG?w=640&h=167&s=A7947C22C8A8C50142D565DE0000C0B2" srcset="/img/loading.gif" alt=""></p><p><strong>^：</strong>代表黑键</p><p><strong>C4    G4    G4    F4^    G4    G4^    G4    C4    C5    C4    C5    C5    B4    C5    D5    C5    D5^</strong></p><p><strong>G5    C5    C5    D5    D5^    D5    D5^    D5    C5    F5    C5    C5    D5    D5^    D5^    F5    D5    D5    D5^    C5    C5    D5    B4    G4^    G4    C5</strong></p><p><strong>G6    C6    C6    D6    D6^    D6    D6^    D6    C6    F6    C6    C6    D6    D6^    D6^    F6    D6    D6    D6^    C6    C6    D6    B5    G5^    G5    C6</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>钢琴</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop(一):初识Hadoop</title>
    <link href="undefined2020/02/26/Hadoop-1-%E5%88%9D%E5%A7%8BHadoop/"/>
    <url>2020/02/26/Hadoop-1-%E5%88%9D%E5%A7%8BHadoop/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Hadoop"><a href="#初识Hadoop" class="headerlink" title="初识Hadoop"></a>初识Hadoop</h1><h2 id="Hadoop名字怎么来的？"><a href="#Hadoop名字怎么来的？" class="headerlink" title="Hadoop名字怎么来的？"></a>Hadoop名字怎么来的？</h2><p>Hadoop之父的名字叫<strong>Doug Cutting</strong>，就是下图那位儒雅随和的男人，他不仅仅是Hadoop的创始人，同时也是<strong>nutch(一个开源Java实现的搜索引擎)</strong>的创始人，而Hadoop这个名字<strong>其实是他孩子一个玩具的名字</strong>，就是下图那个那个小黄象，这个玩具也是<strong>Hadoop的Logo</strong>，小朋友们起名字确实很厉害，类似的还有大名鼎鼎<strong>Google</strong>这个名字就是<strong>由美国数学家 Edward Kasner 九岁的侄子 Milton Sirotta 发明的</strong></p><p><img src="https://i.loli.net/2020/02/26/76KYFDEqloJRUmV.jpg" srcset="/img/loading.gif" alt="hadoopFather"></p><h2 id="Hadoop是干什么的？"><a href="#Hadoop是干什么的？" class="headerlink" title="Hadoop是干什么的？"></a>Hadoop是干什么的？</h2><p><img src="https://i.loli.net/2020/02/26/mwleA3x86Pdc7bY.png" srcset="/img/loading.gif" alt="Hadoop-introduce.png"></p><p>这是Hadoop的官网(<a href="https://hadoop.apache.org/" target="_blank" rel="noopener">https://hadoop.apache.org/</a>) 的介绍，简单来说，Hadoop就是一个开源的，可靠的，可扩展的分布式计算框架，它用来对海量数据进行<strong>分布式存储和计算</strong>，就是传说中的<strong>大数据</strong>。</p><h2 id="Hadoop有几个模块"><a href="#Hadoop有几个模块" class="headerlink" title="Hadoop有几个模块?"></a>Hadoop有几个模块?</h2><p><img src="https://i.loli.net/2020/02/26/AqvmgxCGbW81RSi.png" srcset="/img/loading.gif" alt="hadoop-modules.png"></p><ul><li><p><strong>Hadoop Common：</strong> 公共的模块，用来给其他模块调用</p></li><li><p><strong>Hadoop分布式存储系统(HDFS)：</strong>提供对应用程序数据的<strong>高吞吐量</strong>访问的分布式文件系统</p></li><li><p><strong>Hadoop YARN：</strong>一个用来作业调度和群集资源管理的<strong>框架</strong>。</p></li><li><p><strong>Hadoop MapReduce：</strong>基于<strong>YARN</strong>可在很多机器上进行<strong>分布式并行计算</strong></p></li><li><p><strong>Hadoop Ozone：</strong>Hadoop的对象存储</p></li><li><p><strong>Hadoop Submarine：</strong>一个Hadoop的<strong>机器学习</strong>框架</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node安装与配置</title>
    <link href="undefined2020/01/23/Node%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>2020/01/23/Node%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Node环境搭建"><a href="#Node环境搭建" class="headerlink" title="Node环境搭建"></a>Node环境搭建</h1><p>简单的说，node就是一个前端程序员看后端不爽，用<strong>JavaScript</strong>写出来的后端。</p><p><strong>下载地址：</strong></p><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a></p><p><img src="https://i.loli.net/2020/01/29/4iNUcfwOZk7qVxQ.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-20-25.png"></p><p>选择自己系统对应的版本下载，然后一键安装，小白看教程：</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></p><p>打开<strong>CMD</strong>，输入<strong>node -v</strong>和<strong>npm -v</strong>，如果显示了版本，则安装完成</p><p><img src="https://i.loli.net/2020/01/29/GU8cF6YdOTePqiL.png" srcset="/img/loading.gif" alt="Photo_2020-01-21_18-50-27.png"></p><h2 id="Node配置"><a href="#Node配置" class="headerlink" title="Node配置"></a>Node配置</h2><p>这里node的配置主要是配置<strong>npm</strong>，简单来说<strong>npm</strong>就相当于<strong>Java中的Maven</strong>，或者说它就是前端开发中的Maven</p><h3 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>node也和Maven一样有着默认镜像，默认镜像访问速度较慢，下面是它原本的镜像</p><pre><code class="bash">npm get registry //获取镜像</code></pre><p><img src="http://ww1.sinaimg.cn/large/007SzKTZgy1gb6amm6wulj30d6065jr9.jpg" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-37-07.png"></p><p>我们要将默认镜像切换为淘宝镜像</p><pre><code class="bash">npm config set registry https://registry.npm.taobao.org        //设置镜像</code></pre><p><img src="https://i.loli.net/2020/01/29/iGoHaKL9YCnPFBM.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-40-17.png"></p><p>上面已经切换成淘宝镜像了，如果想国内镜像和国外镜像一起使用的也可以，通过<strong>cnpm</strong></p><pre><code class="bash">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>这样以后使用，<strong>cnpm i <model_name></strong>就是使用国内镜像，<strong>npm i <model_name></strong>就是使用默认镜像</p><h3 id="npm仓库地址"><a href="#npm仓库地址" class="headerlink" title="npm仓库地址"></a>npm仓库地址</h3><p>npm库拉到本地后，会默认存在你的<strong>C盘</strong>，占C盘空间</p><h4 id="1-新建node-global和node-cache"><a href="#1-新建node-global和node-cache" class="headerlink" title="1.新建node_global和node_cache"></a>1.新建node_global和node_cache</h4><ul><li><strong>node_globa</strong>为npm的全局安装路径，类似maven仓库地址</li><li><strong>node_cache</strong>为缓存路径</li></ul><p>一般我习惯在我的nodejs安装目录下新建，如果你想放别的地方也可以</p><p><img src="https://i.loli.net/2020/01/29/mzUkENQTleAZpu3.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-53-07.png"></p><h4 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h4><p>打开<strong>此电脑=&gt;属性=&gt;高级系统设置=&gt;环境变量</strong></p><p><img src="https://i.loli.net/2020/01/29/FKaE7kC2lp6UxRz.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-59-38.png"></p><p>新建系统变量<strong>NODE_PATH</strong>，填写新建的<strong>node_global</strong>的路径</p><p><img src="https://i.loli.net/2020/01/29/e1gQ7RcKPo3SYfE.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-04-54.png"></p><p>然后配置<strong>用户变量-&gt;Path</strong>，加入<strong>%NODE_PATH%</strong></p><p><img src="https://i.loli.net/2020/01/29/ET2BuDXCVY8Oh5S.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-10-35.png"></p><h4 id="3-设置全局"><a href="#3-设置全局" class="headerlink" title="3.设置全局"></a>3.设置全局</h4><p>打开cmd，输入命令：</p><pre><code class="bash">npm config set prefix &quot;F:\Node\node_global&quot;npm config set cache &quot;F:\Node\node_cache&quot;</code></pre><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><p>我们全局安装一下常用的<strong>express</strong>模块试一下</p><pre><code class="bash">npm install express -g</code></pre><p><img src="https://i.loli.net/2020/01/29/muvyVU29Jz5HjOA.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-17-10.png"></p><p>可以看到在node_global文件夹出现了express，配置完成😀</p>]]></content>
    
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA压力测试:Jmeter初体验</title>
    <link href="undefined2019/12/19/JAVA%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-1/"/>
    <url>2019/12/19/JAVA%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmeter初体验"><a href="#Jmeter初体验" class="headerlink" title="Jmeter初体验"></a>Jmeter初体验</h1><p>校园博客的项目需要上线，所以要进行压力测试，于是就开始了测试初体验</p><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/</a></p><p><img src="https://i.loli.net/2019/12/19/OYQVBDkJ3idjo6m.png" srcset="/img/loading.gif" alt=""></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="1-配置JMETER-HOME"><a href="#1-配置JMETER-HOME" class="headerlink" title="1.配置JMETER_HOME"></a>1.配置JMETER_HOME</h4><p>打开系统变量新建变量<strong>JMETER_HOME</strong>,然后，填写你的jmeter安装目录</p><p><img src="https://i.loli.net/2019/12/19/j5RmbN3ey4KQVud.png" srcset="/img/loading.gif" alt=""></p><h4 id="2-配置path"><a href="#2-配置path" class="headerlink" title="2.配置path"></a>2.配置path</h4><p>在path变量加入 <strong>%JMETER_HOME%\bin</strong></p><h3 id="确认安装"><a href="#确认安装" class="headerlink" title="确认安装"></a>确认安装</h3><p>随便找个地方，打开cmd，输入 <strong>jmeter</strong>能打开jmeter就算配置完成</p><p><img src="https://i.loli.net/2019/12/19/V8kNMaqAKmZyUYb.png" srcset="/img/loading.gif" alt=""></p><h2 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h2><p>进入jmeter的bin目录下,打开 jmeter.bat文件</p><p><img src="https://i.loli.net/2019/12/19/ctOTD7Y4BpvxVLF.png" srcset="/img/loading.gif" alt=""></p><p>打开<strong>Options</strong>，选择<strong>Choose Language</strong>中的<strong>Chinese(Simplified)</strong>可以切换成简体中文</p><p><img src="https://i.loli.net/2019/12/19/cQ1MkaDhzIrmufl.png" srcset="/img/loading.gif" alt=""></p><p>右键一个test plan 点击 添加 线程 线程组</p><p><img src="https://i.loli.net/2019/12/19/S8c1LB5ZpjWVeFR.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2019/12/19/UGqAbLdYHrzmOha.png" srcset="/img/loading.gif" alt=""></p><p><strong>线程数：</strong>虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个线程数。</p><p><strong>Ramp-Up Period(in seconds)准备时长：</strong>设置的虚拟用户数需要多长时间全部启动。如果线程数为10，准备时长为2，那么需要2秒钟启动10个线程，也就是每秒钟启动5个线程。</p><p><strong>循环次数：</strong>每个线程发送请求的次数。如果线程数为10，循环次数为100，那么每个线程发送100次请求。总请求数为10*100=1000 。如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。</p><p>将要测试的接口的信息填上，这里我的接口是：<strong><a href="http://localhsot:10002/api/post" target="_blank" rel="noopener">http://localhsot:10002/api/post</a></strong></p><p><img src="https://i.loli.net/2019/12/19/QD1mWkcZn6lBX3N.png" srcset="/img/loading.gif" alt=""></p><p>随后，将测试计划保存到一个目录</p><p><img src="https://i.loli.net/2019/12/19/gue35fmwZFjTvHt.png" srcset="/img/loading.gif" alt=""></p><p>接着到执行计划保存目录，用命令执行测试计划</p><p>非GUI并生成html报告：</p><p>jmeter -n -t <test JMX file> -l <test log file> -e -o <Path to output folder></p><p>非GUI并生成html报告：</p><pre><code class="bash">E:\apache-jmeter\TestPlan&gt;jmeter -n -t &quot;post all.jmx&quot; -l read.jtl -e -o E:\apache-jmeter\TestPlan\Report</code></pre><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110258.png" srcset="/img/loading.gif" alt=""></p><p>然后就会jmeter会帮你生成报告文件</p><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110444.png" srcset="/img/loading.gif" alt=""></p><p>随后打开Repost下index.html查看结果</p><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110541.png" srcset="/img/loading.gif" alt=""></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>由于我是在pc上测的，内存和cpu都比不上服务器，这样的测试结果不准确</p></li><li><p>命令生成报告的时候，比如我的是Report目录，如果这个目录<strong>不为空</strong>，JMeter就会报错</p></li><li><p>重新打开JMeter，它的设置会恢复默认，重新变成英文的了¿¿¿  </p></li><li><p>重新打开JMeter执行计划也不见了，可以导入之前的执行计划。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>压力测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点(二):集合</title>
    <link href="undefined2019/12/04/JAVA%E5%9F%BA%E7%A1%80-2-%E9%9B%86%E5%90%88/"/>
    <url>2019/12/04/JAVA%E5%9F%BA%E7%A1%80-2-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-集合"><a href="#JAVA-集合" class="headerlink" title="JAVA 集合"></a>JAVA 集合</h1><p>JAVA的集合类被定义在Java.util包中，主要有4种集合，分别为<strong>List、Queue、Set、Map</strong>，每种集合的具体分类如图：</p><p><img src="https://i.loli.net/2019/12/04/XAyEQ4fDdN35sCz.png" srcset="/img/loading.gif" alt=""></p><h2 id="List：加强版数组"><a href="#List：加强版数组" class="headerlink" title="List：加强版数组"></a>List：加强版数组</h2><h3 id="1-ArrayList：基于数组实现，增删慢，查询快，线程不安全"><a href="#1-ArrayList：基于数组实现，增删慢，查询快，线程不安全" class="headerlink" title="1.ArrayList：基于数组实现，增删慢，查询快，线程不安全"></a>1.ArrayList：基于数组实现，增删慢，查询快，线程不安全</h3><p>因为是基于数组实现，所以当需要<strong>插入</strong>或<strong>删除</strong>一个节点时，需要移动其他所有节点，代价较高，因此，ArrayList不适合更新操作。</p><p>ArrayList不需要定义数组长度，在默认长度（默认长度为10）不够时，ArrayList会创建一个新的更大数组并将已有的数据复制到新数组中，通过调用一个native方法<strong>System.arraycopy</strong>实现</p><h3 id="2-Vector-基于数组实现，增删慢，查询快，线程安全"><a href="#2-Vector-基于数组实现，增删慢，查询快，线程安全" class="headerlink" title="2.Vector: 基于数组实现，增删慢，查询快，线程安全"></a>2.Vector: 基于数组实现，增删慢，查询快，线程安全</h3><p>Vector的数据结构与ArrayList一样，都是基于数组实现，不同的是Vector支持线程同步，以保证多线程环境下数据的一致性，但由于频繁的加锁和释放锁操作，Vector整体独写效率比ArrayList低。</p><h3 id="3-LinkedList-基于双向链表实现，增删快，查询慢，线程不安全"><a href="#3-LinkedList-基于双向链表实现，增删快，查询慢，线程不安全" class="headerlink" title="3.LinkedList: 基于双向链表实现，增删快，查询慢，线程不安全"></a>3.LinkedList: 基于双向链表实现，增删快，查询慢，线程不安全</h3><p>LinkedList采用双向链表结构存储元素，在对LinkedList插入和删除时，只需要将上一个节点的指针指向要操作的节点即可，数据改动较小，因此更新效率高。但对LinkedList进行访问时，需要从链表头部一直遍历到需要访问的节点，因此查询的效率很慢。除此之外，LinkedList还定义了用于<strong>操作链表头和尾部</strong>的元素，因此有时可以当作堆栈、队列和双向队列使用。</p><h2 id="Map-键值对"><a href="#Map-键值对" class="headerlink" title="Map: 键值对"></a>Map: 键值对</h2><h3 id="1-HashMap：数组-链表实现，线程不安全"><a href="#1-HashMap：数组-链表实现，线程不安全" class="headerlink" title="1.HashMap：数组 + 链表实现，线程不安全"></a>1.HashMap：数组 + 链表实现，线程不安全</h3><p>HashMap基于键的HashCode值唯一标识一条数据，同时<strong>基于HashCode进行数据的存取</strong>，因此可以快速更新和查找数据，但遍历顺序不保证一样，HashMap的key和valu允许为null.</p><p>HashMap不是线程安全的，如果同一时刻多个线程操作HashMap会导致数据不一致，使HashMap造成环形链表。如果需要线程安全可以使用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或使用ConcurrentHashMap.</p><p>HashMap的结构如图所示，</p><p><img src="https://i.loli.net/2019/12/10/aEwPsmeXMQuCp2y.png" srcset="/img/loading.gif" alt=""></p><p>其内部是一个<strong>数组</strong>，数组中的<strong>每个元素都是一个单向链表</strong>，链表中的每个元素都是Node类实例，Node类包含4个属性：<strong>key、value、hash和用于指向下一个元素的next</strong></p><pre><code class="JAVA">    /**     * 初始化数组容量，默认为16，可以扩容，扩容后数组大小为当前的两倍，该值使用为2^n次方     */    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16    transient Node&lt;K,V&gt;[] table;    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;    }</code></pre><p>HashMap在查找数据时，根据HashMap的Hash值可以快速定位到数组下标，但是我们在找到数组下标后需要对链表进行遍历直到找到需要的数据，时间复杂度为O(n).</p><p>为了减小俩表遍历的开销，Java8对HashMap进行了优化，将数据结构修改为<strong>数组+链表或红黑树</strong>。在链表中元素<strong>超过8</strong>后，HashMap会将链表转为红黑树结构以提高查询效率，因此其时间复杂度为O(logN)。如图</p><p><img src="https://i.loli.net/2019/12/10/voKyxMumfpiF6zt.png" srcset="/img/loading.gif" alt=""></p><pre><code class="JAVA">    /**     * 使用树的阈值，如果链表长度超过此值，则链表转为红黑树     */    static final int TREEIFY_THRESHOLD = 8;    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {        TreeNode&lt;K,V&gt; parent;          TreeNode&lt;K,V&gt; left;        TreeNode&lt;K,V&gt; right;        TreeNode&lt;K,V&gt; prev;        boolean red;    }</code></pre><h3 id="2-ConcurrentHashMap：分段锁实现，线程安全"><a href="#2-ConcurrentHashMap：分段锁实现，线程安全" class="headerlink" title="2.ConcurrentHashMap：分段锁实现，线程安全"></a>2.ConcurrentHashMap：分段锁实现，线程安全</h3><p>在<strong>JDK1.7</strong>中，ConcurrentHashMap采用<strong>分段锁</strong>的思想实现并发操作，因此是线程安全的。ConcurrentHashMap由多个Segment组成（Segment的数量也是锁的并发度），每个Segment都继承自<strong>ReentrantLock</strong>并单独加锁，所以每次进行加锁操作时锁住的都是一个Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。如图，所示：</p><p><img src="https://i.loli.net/2019/12/11/JrMAnaPEy461kmj.png" srcset="/img/loading.gif" alt=""></p><p>在<strong>JDK1.8</strong>中，抛弃了Segment分段锁机制，利用<strong>CAS+Synchronized</strong>，数据结构采用<strong>数组 + 链表 + 红黑树</strong></p><h3 id="3-HashTable：线程安全"><a href="#3-HashTable：线程安全" class="headerlink" title="3.HashTable：线程安全"></a>3.HashTable：线程安全</h3><p>HashTable是遗留类，很多映射的常用功能都与HashMap类似，不同的是它继承自<strong>Dictionary</strong>类，并且是线程安全的，同一时刻只能有一个线程能写HashTable，并发性不如ConcurrentHashMap。</p><h3 id="4-TreeMap：基于二叉树数据结构"><a href="#4-TreeMap：基于二叉树数据结构" class="headerlink" title="4.TreeMap：基于二叉树数据结构"></a>4.TreeMap：基于二叉树数据结构</h3><p>TreeMap基于二叉树数据结构存储数据，同时实现了<strong>SortedMap</strong>接口，以保障元素的顺序存储，默认按键值的升序排序，也可以自定义排序比较器。</p><p>TreeMap常用于实现排序的映射列表。在使用TreeMap时其key必须实现Comparable接口或采用自定义比较器，否则会抛出java.lang.ClassCastException异常</p><h3 id="5-LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序"><a href="#5-LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序" class="headerlink" title="5.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序"></a>5.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序</h3><p>LinkedHashMap是HashMap的子类，其内部使用链表保存元素的插入顺序，在通过Iterator遍历LinkedHashMap时，会按照元素的插入顺序访问元素。</p><h2 id="Set：不可重复"><a href="#Set：不可重复" class="headerlink" title="Set：不可重复"></a>Set：不可重复</h2><p>Set的核心是<strong>独一无二</strong>的性质，适用于存储无序且值不相等的元素。</p><h3 id="1-HashSet：HashMap实现，无序"><a href="#1-HashSet：HashMap实现，无序" class="headerlink" title="1.HashSet：HashMap实现，无序"></a>1.HashSet：HashMap实现，无序</h3><p><strong>HashSet是基于HashMap实现的</strong>，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个<strong>private static final Object PRESENT = new Object();。</strong>HashSet跟HashMap一样，都是存放链表的数组。</p><pre><code class="java">public class HashSet&lt;E&gt;    extends AbstractSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable{    static final long serialVersionUID = -5024744406713321676L;    private transient HashMap&lt;E,Object&gt; map;    private static final Object PRESENT = new Object();    public HashSet() {        map = new HashMap&lt;&gt;();    }    public boolean add(E e) {        return map.put(e, PRESENT)==null;    }    ....}</code></pre><h3 id="2-TreeSet：二叉树实现"><a href="#2-TreeSet：二叉树实现" class="headerlink" title="2.TreeSet：二叉树实现"></a>2.TreeSet：二叉树实现</h3><p><strong>TreeSet是基于TreeMap实现</strong>，和HashSet类似</p><pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{    private transient NavigableMap&lt;E,Object&gt; m;    private static final Object PRESENT = new Object();    public TreeSet() {        this(new TreeMap&lt;E,Object&gt;());    }    public boolean add(E e) {        return m.put(e, PRESENT)==null;    }}</code></pre><p>可以自定义排序方法</p><pre><code class="java">Set&lt;String&gt; treeSet = new TreeSet(Comparator.comparing(String::length));</code></pre><p>如果是自定义数据类型，必须<strong>实现Comparable接口</strong>。并<strong>覆写compareTo函数</strong>。</p><h3 id="3-LinkedHashSet：数据插入顺序和遍历数据一样"><a href="#3-LinkedHashSet：数据插入顺序和遍历数据一样" class="headerlink" title="3.LinkedHashSet：数据插入顺序和遍历数据一样"></a>3.LinkedHashSet：数据插入顺序和遍历数据一样</h3><p> <strong>LinkedHashSet继承了HashSet</strong>，所有的操作都与HashSet一样，底层使用<strong>LinkedHashMap存储元素</strong></p><pre><code class="java">public class LinkedHashSet&lt;E&gt;    extends HashSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {     public LinkedHashSet(int initialCapacity, float loadFactor) {        super(initialCapacity, loadFactor, true);    }     public LinkedHashSet(int initialCapacity) {        super(initialCapacity, .75f, true);    }     public LinkedHashSet() {        super(16, .75f, true);    }}</code></pre><p>这里神奇的是，LinkedHashSet创建对象却是在HashSet里</p><pre><code class="java">    HashSet(int initialCapacity, float loadFactor, boolean dummy) {        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);    }</code></pre><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>用的不是很多，所以不详细说明</p><ul><li><p><strong>ArrayBlockingQueue：</strong>基于数组数据结构实现的有界阻塞队列</p></li><li><p><strong>LinkedBlockingQueue：</strong>基于链表数据结构实现的有界阻塞队列</p></li><li><p><strong>PriorityBlockingQueue：</strong>支持优先级排序的无界队列</p></li><li><p><strong>DelayQueue：</strong>支持延迟操作的无界阻塞队列</p></li><li><p><strong>SynchronousQueue：</strong>用于线程同步的阻塞队列</p></li><li><p><strong>LinkedTransferQueue：</strong>基于链表数据结构实现的无界阻塞队列</p></li><li><p><strong>LinkedBlockingDeque：</strong>基于链表数据结构实现的双向阻塞队列</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点(一):JVM</title>
    <link href="undefined2019/12/02/JAVA%E5%9F%BA%E7%A1%80-1-JVM/"/>
    <url>2019/12/02/JAVA%E5%9F%BA%E7%A1%80-1-JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><strong>JVM(Java Virtual Machine)</strong>是用于运行Java字节码的虚拟机包括一个<strong>类加载器子系统（Class Loader SubSystem）</strong>、<strong>运行时数据区（Runtime Data Area）</strong>、执行引擎和<strong>本地接口库（Native Interface Library）</strong>。本地接口库通过调用<strong>本地方法库（Native Method Library）</strong>与操作系统交互，如图：</p><p><img src="https://i.loli.net/2019/12/02/ikFsOqoJ98NbCKe.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>Java堆（Heap）：</strong>是Java虚拟机所管理的内存最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的<strong>唯一目的就是存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</li><li><strong>方法区（Method Area）：</strong>与java堆一样，是各个线程共享的内存区域，它用于<strong>存储</strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li><strong>程序计数器（Program Counter Register）：</strong>是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li><li><strong>JVM栈（JVM Stacks）：</strong>与程序计数器一样，<strong>java虚拟机栈（Java Virtual Machine Stacks）</strong>也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被创建的时候都会创建一个<strong>栈帧(Stack Frame)</strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。</li><li><strong>本地方法栈（Native Method Stacks）：</strong>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行JAVA方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题(一)</title>
    <link href="undefined2019/11/17/%E9%9D%A2%E8%AF%95-1/"/>
    <url>2019/11/17/%E9%9D%A2%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>我一个好朋友，在BOSS上投简历收到了面试邀请，这是他面试回来说的面试题，我整理了一下并查了答案，以免自己去面试的时候不会</p><p>下面是面试问题：</p><blockquote><p>1.JAVA数据类型以及所占字节</p><p>2.手写三个单例模式</p><p>3.ArrayList与LinkList区别</p><p>4.HashSet原理</p><p>5.常用的Linux命令</p><p>6.JAVA反射机制</p><p>7.手画一个线程状态图</p><p>8.手写三个线程交替打印ABC</p><p>9.什么是TCP三次握手，为什么四次挥手断开连接，为什么</p><p>10.手写一个冒泡算法</p><p>11.SpringMVC是怎么运行的？</p><p>12.索引类型及作用</p></blockquote><p>下面面试答案：</p><h2 id="1-JAVA数据类型及所占字节"><a href="#1-JAVA数据类型及所占字节" class="headerlink" title="1.JAVA数据类型及所占字节"></a>1.JAVA数据类型及所占字节</h2><pre><code class="java">整型:  byte--1字节    short--2字节    int--4字节    long--8字节浮点型:  float--4字节    double--8字节字符型:  char--2字节布尔型:  boolean--1字节</code></pre><h2 id="2-单例模式的三种实现"><a href="#2-单例模式的三种实现" class="headerlink" title="2.单例模式的三种实现"></a>2.单例模式的三种实现</h2><pre><code class="JAVA">/*** 1.懒汉式,默认不实例化，什么时候用什么时候创建对象* 优点：懒加载启动快，资源占用小，使用时才实例化，无锁。* 缺点：非线程安全。*/public class Singleton{    private static Singleton instance;    private Singleton(){}    public static synchronized Singleton getInstance(){        if(instance == null){            instance = new Singleton();        }        return instance;    }}/** 2.饿汉式，类加载的时候就实例化* 优点：饿汉模式天生是线程安全的，使用时没有延迟。* 缺点：启动时即创建实例，启动慢，有可能造成资源浪费。*/public class Singleton{    private Singleton(){}    private static final Singleton singleton = new Singleton();    public static Singleton getInstance(){        return singleton;    }}/** 3.静态内部类* 优点：将懒加载和线程安全完美结合的一种方式（无锁）。（推荐）*/public class Singleton{    private Singleton(){}    public static final Singleton getInstance(){        return SingletonHolder.INSTANCE;    }    private static class SingletonHolder{        private static final Singleton INSTANCE = new Singleton();    }}</code></pre><h2 id="3-ArrayList和LinkList的区别"><a href="#3-ArrayList和LinkList的区别" class="headerlink" title="3.ArrayList和LinkList的区别"></a>3.ArrayList和LinkList的区别</h2><pre><code class="JAVA">ArrayList是基于数组实现的，查询快，更新慢。LinkList是基于链表实现的，插入，删除快，查询慢</code></pre><h2 id="4-HashSet原理"><a href="#4-HashSet原理" class="headerlink" title="4.HashSet原理"></a>4.HashSet原理</h2><pre><code class="JAVA">HashSet实现Set接口，由一个HashMap实例支持。不保证set的迭代顺序;不保证舒徐恒久不变。此类允许使用nullprivate transient HashMap&lt;E,Object&gt; map;  //map集合，HashSet存放元素的容器private static final Object PRESENT = new Object(); //map，中键对应的value值</code></pre><h2 id="5-常用的Linux命令"><a href="#5-常用的Linux命令" class="headerlink" title="5.常用的Linux命令"></a>5.常用的Linux命令</h2><pre><code class="bash">ll ls cd pwd mkdir touch rm -rf grep less</code></pre><h2 id="6-JAVA反射机制"><a href="#6-JAVA反射机制" class="headerlink" title="6.JAVA反射机制"></a>6.JAVA反射机制</h2><pre><code class="java">java反射机制是指在运行时，对任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取对象信息及动态调用方法的功能称为JAVA反射机制。通过Class.forName(包名.类名)获得类对象Class，通过操作Class对象达到运行时操作类</code></pre><h2 id="7-手画一个线程状态图"><a href="#7-手画一个线程状态图" class="headerlink" title="7.手画一个线程状态图"></a>7.手画一个线程状态图</h2><pre><code class="java">线程有五个状态：新建态(new)、就绪态(runnable)、运行态(running)、阻塞态(blocked)、死亡态(dead)</code></pre><p><img src="https://images2017.cnblogs.com/blog/432513/201712/432513-20171214160438717-1661848063.png" srcset="/img/loading.gif" alt=""></p><h2 id="8-手写三个线程交替打印ABC"><a href="#8-手写三个线程交替打印ABC" class="headerlink" title="8.手写三个线程交替打印ABC"></a>8.手写三个线程交替打印ABC</h2><pre><code class="java">/*** 主要考察的使是线程间的同步唤醒操作，线程的逻辑执行步骤为ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA.......* 要控制线程的执行顺序,就要确定唤醒和等待的顺序,一种解题思路是一个线程持有两个对象锁.一个对象锁是pret即前* * 一个对象所持有的锁,还有一个是自身锁.*/public class SysaAbcThread implements Runnable{    private Object pret;     //上一个锁    private Object self;     //自身锁    private String sout;     //要输出的内容    public SysaAbcThread(Object pret, Object self, String sout) {        super();        this.pret = pret;        this.self = self;        this.sout = sout;    }    @Override    public void run() {        while(true){            synchronized (pret) {     //获取 pret锁                synchronized (self) { //获取 self锁                    System.out.println(sout);                    self.notifyAll();  //释放self锁，唤醒其他线程竞争self锁                }                try {                    pret.wait();      //释放pret锁，休眠等待唤醒                } catch (InterruptedException e) {}            }        }    }    public static void main(String[] args) throws InterruptedException {        Object a = new Object();        Object b = new Object();        Object c = new Object();        SysaAbcThread aThread = new SysaAbcThread(c, a, &quot;A&quot;);        SysaAbcThread bThread = new SysaAbcThread(a, b, &quot;B&quot;);        SysaAbcThread cThread = new SysaAbcThread(b, c, &quot;C&quot;);        /**         * 如果不sleep，则启动顺序会乱         */        new Thread(aThread).start();        Thread.sleep(100);        new Thread(bThread).start();        Thread.sleep(100);        new Thread(cThread).start();        Thread.sleep(100);    }}</code></pre><h2 id="9-什么是TCP三次握手，为什么四次挥手断开连接"><a href="#9-什么是TCP三次握手，为什么四次挥手断开连接" class="headerlink" title="9.什么是TCP三次握手，为什么四次挥手断开连接"></a>9.什么是TCP三次握手，为什么四次挥手断开连接</h2><p><strong>三此握手(Three-way Handshake)是指建立一个TCP连接时</strong>，需要客户端和服务端总共发送三个包。</p><p>三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><ul><li><p>第一次握手(SYN=1,seq=x):   <strong>客户端=&gt;服务端</strong></p><p>客户端发送一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口，以及初始序号X，保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕客户端进入<strong>SYN_SEND</strong>状态。</p></li></ul><ul><li><p>第二次握手(SYN=1,ACK=1,seq=y,ACKnum=x+1):  <strong>服务端=&gt;客户端</strong></p><p>服务器发回确认包(ACK)应答。即SYN标志和ACK标志位均为1。服务器端选择自己的ISN序列号，放到Seq域里，同时将确认序号(Acknowledgement Number)设置为客户端的ISN加1，即X+1。发送完毕后，服务器端进入<strong>SYN_RCVD</strong>状态。</p></li></ul><ul><li><p>第三次握手(ACK=1,ACKnum=y+1)：<strong>客户端=&gt;服务端</strong></p><p>客户端再次发回确认包(ACK)，SYN标志位为0，ACK标志为1，并把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写INS的+1</p><p>发送完毕后，客户端进入<strong>ESTABLISHED</strong>状态，当服务器端接收到这个包时，也进入<strong>ESTABLISHED</strong>状态，TCP握手结束。</p></li></ul><p><strong>四次挥手(Four-Way Wavehand)是指断开一个TCP连接时</strong>，需要客户端和服务端发送四个包确认连接断开。客户端或服务端均可主动发起挥手动作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<strong>FIN_WAIT_1</strong>状态</p></li></ul><ul><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端发送的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<strong>CLOSE_WAIT</strong>状态，客户端接收到这个确认包之后，进入<strong>FIN_WAIT_2</strong>状态，等待服务器关闭连接。</p></li></ul><ul><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN设置为1.</p><p>发送完毕后，服务端进入<strong>LAST_ACK</strong>状态，等待来自客户端的最后一个ACK。</p></li></ul><ul><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收来自服务器端的关闭请求，发送一个确认包，并进入<strong>TIME_WAIT</strong>状态，等待可能出现的要求重传的ACK包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入<strong>CLOSED</strong>状态。</p><p>客户端等待了某个固定时间（两个最大生命周期，2MSL，2 Maximum Segment Lifetime）之后，没收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<strong>CLOSED</strong>状态</p></li></ul><h2 id="10-手写一个冒泡算法"><a href="#10-手写一个冒泡算法" class="headerlink" title="10.手写一个冒泡算法"></a>10.手写一个冒泡算法</h2><pre><code class="java">    public int[] sort(int[] arr){        int length = arr.length;        for(int i=0;i&lt;length;i++){            for(int j=i;j&lt;length;j++){                if(arr[i] &gt; arr[j]){                    int temp = arr[j];                    arr[j] = arr[i];                    arr[i] = temp;                }            }        }        return arr;    }   </code></pre><h2 id="11-SpringMVC是怎么运行的？"><a href="#11-SpringMVC是怎么运行的？" class="headerlink" title="11.SpringMVC是怎么运行的？"></a>11.SpringMVC是怎么运行的？</h2><p>（1）用户发送请求至前端控制器<strong>DispatcherServlet</strong></p><p>（2）<strong>DispatcherServlet</strong>收到请求后，调用<strong>HandlerMapping</strong>处理映射器，请求获取Handle;</p><p>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有就生成)，一并返回给<strong>DispatcherServlet</strong></p><p>（4）<strong>DispatcherServlet</strong>调用<strong>HandlerAdapter</strong>处理适配器</p><p>（5）<strong>HandlerAdapter</strong>经过适配调用具体处理器(Handler，也叫后端控制器)；</p><p>（6）<strong>Handler</strong>执行完成返回<strong>ModelAndView</strong>；</p><p>（7）<strong>HandlerAdapter</strong>将Handler执行结果<strong>ModelAndView</strong>返回给<strong>DispatcherServlet</strong></p><p>（8）<strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>传给<strong>ViewResolver</strong>视图解析器进行解析</p><p>（9）<strong>ViewResolver</strong>解析后返回具体的<strong>view</strong></p><p>（10）<strong>DispatcherServlet</strong>对<strong>View</strong>进行渲染试图</p><p>（11）<strong>DispatcherServlet</strong>响应用户</p><p><img src="https://img-blog.csdn.net/20180708224853769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt=""></p><h2 id="12-索引类型及作用"><a href="#12-索引类型及作用" class="headerlink" title="12.索引类型及作用"></a>12.索引类型及作用</h2><ol><li><strong>主键索引：</strong>数据记录里面不能有null，数据内容不能重复，在一张表里不能有多个主键索引</li><li><strong>普通索引：</strong>使用字段关键字建立索引，提高查询质量</li><li><strong>唯一索引：</strong>字段数据是唯一的，可以为null，在一张表里，是可以添加多个唯一索引</li><li><strong>全文索引：</strong>对文本内容进行分词，进行搜索</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(三):实用指令</title>
    <link href="undefined2019/11/02/Linux-3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>2019/11/02/Linux-3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h3 id="Linux系统的运行级别"><a href="#Linux系统的运行级别" class="headerlink" title="Linux系统的运行级别"></a>Linux系统的运行级别</h3><pre><code class="bash">0:关机  1:单用户(找回丢失密码)2:多用户无网络服务3:多用户有网络服务4:保留5:图形界面6:重启命令 init [0||num]系统运行级别配置文件： /etc/inittab</code></pre><p><img src="https://i.loli.net/2019/10/09/R9DjLcyuoXtGkFI.png" srcset="/img/loading.gif" alt=""></p><h5 id="如何修改已经忘记密码"><a href="#如何修改已经忘记密码" class="headerlink" title="如何修改已经忘记密码"></a>如何修改已经忘记密码</h5><p><img src="https://i.loli.net/2019/10/09/rcNa2gMqbYtGkLe.png" srcset="/img/loading.gif" alt=""></p><p>首先，在进入启动页面的时候按<strong>e</strong>键，然后会进入下面这个页面</p><p><img src="https://i.loli.net/2019/10/09/g4j2GNFevKImaQn.png" srcset="/img/loading.gif" alt=""></p><p>将光标移动到下图那一行</p><p><img src="https://i.loli.net/2019/10/09/8k4sZdrAvRgEVno.png" srcset="/img/loading.gif" alt=""></p><p>在行尾添加 <strong>init=/bin/sh</strong>,</p><p><img src="https://i.loli.net/2019/10/09/LhdHGqYpItZvMAK.png" srcset="/img/loading.gif" alt=""></p><p>添加完，按<strong>Ctrl + X</strong>执行，即可进入单用户模式</p><p><img src="https://i.loli.net/2019/10/09/JBKHTxbWS5dGYIy.png" srcset="/img/loading.gif" alt=""></p><p>然后，就可以<strong>修改密码</strong>了</p><p><img src="https://i.loli.net/2019/10/09/4wbFxDeHrJGKBm8.png" srcset="/img/loading.gif" alt=""></p><p>这里可以看见会字符不可见，你需要输入<strong>LANG=en</strong>，才能让字符可见</p><p><img src="https://i.loli.net/2019/10/09/trswoihHCvd7JGu.png" srcset="/img/loading.gif" alt=""></p><p>最后,执行<strong>exec /sbin/init</strong>即可退出单用户模式</p><p><img src="https://i.loli.net/2019/10/09/gvKOq5eVhc3FwXd.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当你对某个指令不收悉的时候，就可以使用帮助指令</p><h4 id="获得帮助信息"><a href="#获得帮助信息" class="headerlink" title="获得帮助信息"></a>获得帮助信息</h4><ul><li><p>语法</p><pre><code class="bash">man [命令||配置文件]</code></pre></li><li><p>命令演示</p><pre><code class="bash">[root@localhost ~]# man ls</code></pre><p>输入命令按<strong>回车</strong>,</p><p><img src="https://i.loli.net/2019/10/10/AnB285ODQH9RKLf.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>ls加-a可以<strong>显示隐藏文件</strong></p><p><img src="https://i.loli.net/2019/10/10/mNfp1tGsEaX38D9.png" srcset="/img/loading.gif" alt=""></p><p>ls加-l可以以<strong>另外的列表形式显示</strong></p><p><img src="https://i.loli.net/2019/10/10/eOT45wiHoPu6gys.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">[root@localhost home]# ls -a.  ..  crg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><p>命令选项不光可以单个用，也可以连用，</p><pre><code class="bash">[root@localhost home]# ls -la总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy</code></pre><h4 id="help-命令"><a href="#help-命令" class="headerlink" title="help 命令"></a>help 命令</h4><ul><li><p>基本语法</p><pre><code class="bash">help 命令</code></pre></li><li><p>实例演示</p><pre><code class="bash">[root@localhost home]# help cdcd: cd [-L|[-P [-e]]] [dir]    Change the shell working directory.    Change the current directory to DIR.  The default DIR is the value of the    HOME shell variable.    The variable CDPATH defines the search path for the directory containing    DIR.  Alternative directory names in CDPATH are separated by a colon (:).    A null directory name is the same as the current directory.  If DIR begins    with a slash (/), then CDPATH is not used.    If the directory is not found, and the shell option `cdable_vars&#39; is set,    the word is assumed to be  a variable name.  If that variable has a value,    its value is used for DIR.    Options:        -L      force symbolic links to be followed        -P      use the physical directory structure without following symbolic        links        -e      if the -P option is supplied, and the current working directory        cannot be determined successfully, exit with a non-zero status    The default is to follow symbolic links, as if `-L&#39; were specified.    Exit Status:    Returns 0 if the directory is changed, and if $PWD is set successfully when    -P is used; non-zero otherwise.[root@localhost home]# </code></pre></li></ul><hr><h3 id="查看目录类命令"><a href="#查看目录类命令" class="headerlink" title="查看目录类命令"></a>查看目录类命令</h3><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p><strong>这个命令用来显示当前工作的绝对路径</strong></p><pre><code class="bash">[root@localhost ~]# pwd/root[root@localhost ~]# </code></pre><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p><strong>该命令用来查看当前目录的所有内容</strong></p><pre><code class="bash">ls [选项] [目录||文件]</code></pre><pre><code class="bash">[root@localhost home]# lscrg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# ls -al总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p><strong>用于切换目录</strong></p><pre><code class="bash">cd [参数](指定目录)</code></pre><pre><code class="bash">[root@localhost /]# ll总用量 16lrwxrwxrwx.   1 root root    7 9月   4 20:33 bin -&gt; usr/bindr-xr-xr-x.   5 root root 4096 9月   4 20:37 bootdrwxr-xr-x.  20 root root 3220 10月 10 09:01 devdrwxr-xr-x.  75 root root 8192 10月 10 09:01 etcdrwxr-xr-x.   4 root root   27 9月  29 09:45 homelrwxrwxrwx.   1 root root    7 9月   4 20:33 lib -&gt; usr/liblrwxrwxrwx.   1 root root    9 9月   4 20:33 lib64 -&gt; usr/lib64drwxr-xr-x.   2 root root    6 4月  11 2018 mediadrwxr-xr-x.   2 root root    6 4月  11 2018 mntdrwxr-xr-x.   2 root root    6 4月  11 2018 optdr-xr-xr-x. 135 root root    0 10月 10 09:01 procdr-xr-x---.   2 root root  151 10月  9 14:26 rootdrwxr-xr-x.  24 root root  720 10月 10 09:01 runlrwxrwxrwx.   1 root root    8 9月   4 20:33 sbin -&gt; usr/sbindrwxr-xr-x.   2 root root    6 4月  11 2018 srvdr-xr-xr-x.  13 root root    0 10月 10 09:01 sysdrwxrwxrwt.  12 root root  265 10月 10 10:09 tmpdrwxr-xr-x.  13 root root  144 9月  28 15:29 usrdrwxr-xr-x.  19 root root  267 9月   4 20:37 var[root@localhost /]# cd /home[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><hr><h3 id="操作文件类命令"><a href="#操作文件类命令" class="headerlink" title="操作文件类命令"></a>操作文件类命令</h3><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p><strong>用于创建目录</strong></p><pre><code class="bash">mkdir [选项] 要创建的目录-p : 创建多级目录</code></pre><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# mkdir dog[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mkdir /home/animal/catmkdir: 无法创建目录&quot;/home/animal/cat&quot;: 没有那个文件或目录[root@localhost home]# mkdir -p /home/animal/cat[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:46 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost animal]# cd animal[root@localhost animal]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 10 13:46 cat</code></pre><h4 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h4><p><strong>rmdir命令用于删除空目录</strong></p><pre><code class="bash">rmdir [目录]</code></pre><p>删除dog目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir dog[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir animalrmdir: 删除 &quot;animal&quot; 失败: 目录非空</code></pre><p>如果要删除一个<strong>非空的目录</strong>需要用<strong>rm -rf</strong>命令</p><pre><code class="bash">[root@localhost home]# rm -rf animal[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p><strong>创建一个空的文件</strong></p><p>接下来，创建一个Hello.txt</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# touch hello.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:14 hello.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# </code></pre><p><strong>touch</strong>也可以创建多个文件</p><pre><code class="bash">[root@localhost home]# touch sb.txt dl.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:15 dl.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy-rw-r--r--. 1 root root  0 10月 10 15:15 sb.txt[root@localhost home]# </code></pre><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p><strong>拷贝文件到指定目录</strong></p><pre><code class="bash">cp [选项] [待拷贝文件] [拷贝目标]-r: 拷贝整个文件夹</code></pre><p>接下来,将a.txt<strong>拷贝到</strong>aaa目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:23 aaa-rw-r--r--. 1 root root  0 10月 10 15:23 a.txtdrwxr-xr-x. 2 root root  6 10月 10 15:25 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# cp a.txt aaa[root@localhost home]# cd aaa[root@localhost aaa]# ll总用量 0-rw-r--r--. 1 root root 0 10月 10 15:23 a.txt[root@localhost aaa]# </code></pre><p>如果，要将aaa目录拷贝到bbb目录下，</p><pre><code class="bash">[root@localhost home]# cp aaa bbbcp: 略过目录&quot;aaa&quot;[root@localhost home]# </code></pre><p>会提示一个错误，略过目录”aaa”，这个时候就需要加入选项<strong>-r</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbb[root@localhost home]# cd bbb[root@localhost bbb]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:29 aaa[root@localhost bbb]# </code></pre><p>如果，再复制一次，会提示要不要覆盖，如果默认要覆盖可以使用<strong>\cp</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbbcp：是否覆盖&quot;bbb/aaa/a.txt&quot;？ y[root@localhost home]# /cp -r aaa bbb-bash: /cp: 没有那个文件或目录[root@localhost home]# \cp -r aaa bbb[root@localhost home]# </code></pre><p>这里注意是<strong>\cp</strong>，不仔细的话容易弄反</p><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p><strong>用于移除文件或目录</strong></p><pre><code class="bash">rm [文件||目录]-r : 递归删除整个文件夹-f : 强制删除不提示</code></pre><p>删除<strong>/home/a.txt</strong>，</p><pre><code class="bash">[root@localhost home]# rm a.txtrm：是否删除普通空文件 &quot;a.txt&quot;？y[root@localhost home]# </code></pre><p>删除<strong>/home/aaa</strong></p><pre><code class="bash">[root@localhost aaa]# rm /home/aaarm: 无法删除&quot;/home/aaa&quot;: 是一个目录[root@localhost aaa]# rm -r /home/aaarm：是否进入目录&quot;/home/aaa&quot;? yrm：是否删除普通空文件 &quot;/home/aaa/a.txt&quot;？yrm：是否删除目录 &quot;/home/aaa&quot;？y[root@localhost aaa]# </code></pre><p>这里可以看出如果要删除目录，要对目录下所有文件确认是否删除，非常麻烦，所以，如果不想提示，加上<strong>-f</strong>命令强制删除<strong>/home/bbb</strong>，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 15:29 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rm -rf /home/bbb/[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p><strong>mv指令用于移动文件或重命名</strong></p><pre><code class="bash">重命名 ： mv oldNameFile newNameFile移动 ： mv /oldPath /newPath</code></pre><p>接下来，我们将<strong>/home/aaa.txt</strong>重命名为<strong>sz.txt</strong></p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root  6 10月 11 09:26 aaa.txtdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mv aaa.txt sz.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# </code></pre><p>然后，将sz.txt移动到<strong>crg</strong>目录里面，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# mv /home/sz.txt/ /home/crg/[root@localhost home]# ll总用量 0drwx------. 3 crg dw 76 10月 11 09:34 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# cd crg[root@localhost crg]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 11 09:26 sz.txt[root@localhost crg]# </code></pre><hr><h3 id="查看文件类命令"><a href="#查看文件类命令" class="headerlink" title="查看文件类命令"></a>查看文件类命令</h3><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p><strong>用来查看文件内容，以只读的方式</strong></p><pre><code class="bash">cat [选项] [目标文件]</code></pre><p>用cat的方式查看<strong>/etc/profile</strong></p><pre><code class="bash">[root@localhost ~]# cat /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091155.png" srcset="/img/loading.gif" alt=""></p><p>这里可以查看，但没有行号，我们给他设定一个行号,加上选项<strong>-n</strong></p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091429.png" srcset="/img/loading.gif" alt=""></p><p>但是，cat命令每次都会直接跑到文件末尾，让你看不清，所以，一般还会给和<strong>| more</strong>连用，</p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile | more</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091759.png" srcset="/img/loading.gif" alt=""></p><p><strong>| more</strong>用来<strong>分页显示</strong>，按<strong>空格</strong>看下一页</p><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p><strong>more命令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件内容</strong></p><p>用<strong>more命令</strong>查看文件,</p><pre><code class="bash">[root@localhost ~]# more /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095423.png" srcset="/img/loading.gif" alt=""></p><p>快捷键,</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095608.png" srcset="/img/loading.gif" alt=""></p><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><p><strong>less命令和more命令类似，但它功能更强大，不会将整个文件加载完后再显示，比more效率更高，一般用于查看大型文件</strong></p><p>接下来，用less命令查看<strong>/etc/services</strong></p><pre><code class="bash">[root@localhost etc]# less /etc/services</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/1570846827372.png" srcset="/img/loading.gif" alt=""></p><p>可以看出，它只加载了这么多就不往下显示了，</p><p><strong>less快捷键：</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012102549.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(二):用户管理</title>
    <link href="undefined2019/11/02/Linux-2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>2019/11/02/Linux-2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h3 id="Linux用户基本介绍"><a href="#Linux用户基本介绍" class="headerlink" title="Linux用户基本介绍"></a>Linux用户基本介绍</h3><blockquote><p> Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 </p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录</p></blockquote><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927160228.png" srcset="/img/loading.gif" alt=""></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code class="bash">useradd [选项] 用户名</code></pre><p>接下来，添加一个用户 dl</p><pre><code class="bash">[root@localhost ~]# useradd dl</code></pre><p>可能界面看不出什么效果，其实系统已经创建了一个叫<strong>dl的用户</strong>并创建了同名的<strong>组</strong>和 <strong>/home/dl目录</strong></p><pre><code class="bash">[root@localhost /]# cd /home/[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 lj lj 83 9月   5 09:02 lj</code></pre><p>如果你不想创建在<strong>home目录</strong>下，你还可以将<strong>用户</strong>创建在其他目录，这里我想将用户创建在<strong>/home/sb/#</strong></p><pre><code class="bash">[root@localhost home]# mkdir sb[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwxr-xr-x. 2 root root  6 9月  28 08:54 sb</code></pre><p>此时目录已经创建完毕，接着输入命令：</p><pre><code class="bash">[root@localhost home]# useradd -d /home/sb/ qyuseradd：警告：此主目录已经存在。不从 skel 目录里向其中复制任何文件。正在创建信箱文件: 文件已存在</code></pre><p>然后，给用户<strong>dl</strong>和<strong>qy</strong>设置密码:</p><pre><code class="bash">[root@localhost home]# passwd dl更改用户 dl 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@localhost home]# passwd qy更改用户 qy 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。</code></pre><p>这里我两个用户密码都设置为：<strong>12345678</strong>,就算系统提示为通过字典检查，只要你无视它，接着输入<strong>密码</strong>，还是会设置成功，然后我使用<strong>SmarTTY</strong> 登录用户 <strong>dl</strong>和<strong>qy</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928094858.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928102011.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><h5 id="1-删除用户，但保留目录"><a href="#1-删除用户，但保留目录" class="headerlink" title="1.删除用户，但保留目录"></a>1.删除用户，但保留目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 qy qy 62 9月  28 13:48 qy[root@localhost home]# userdel qy //执行删除[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwx------. 2 1002 1002 62 9月  28 13:48 qy</code></pre><h5 id="2-删除用户和目录"><a href="#2-删除用户和目录" class="headerlink" title="2.删除用户和目录"></a>2.删除用户和目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  28 14:19 dldrwx------. 2 qy qy 62 9月  28 14:19 qy[root@localhost home]# userdel -r dl  //执行删除[root@localhost home]# ll总用量 0drwx------. 2 qy qy 62 9月  28 14:19 qy</code></pre><hr><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><pre><code>id  [用户名]</code></pre><pre><code class="bash">[root@localhost home]# id rootuid=0(root) gid=0(root) 组=0(root)[root@localhost home]# id qyuid=1001(qy) gid=1001(qy) 组=1001(qy)[root@localhost home]# </code></pre><hr><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre><code>su [用户名]</code></pre><pre><code class="bash">[root@localhost ~]# su qy[qy@localhost root]$ su root密码：[root@localhost ~]# </code></pre><p>这是一种从<strong>低权限用户</strong>切换到<strong>高权限用户</strong>的方法，</p><p>还有一种</p><pre><code class="bash">[qy@localhost /]$ exitexit[root@localhost ~]# </code></pre><p>直接<strong>exit</strong>，这样就避免了输密码</p><hr><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h5 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h5><pre><code class="bash">groupadd [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupadd dang[root@localhost ~]# </code></pre><h5 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h5><pre><code class="bash">groupdel [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupdel dang[root@localhost ~]# </code></pre><h5 id="增加用户直接加上组"><a href="#增加用户直接加上组" class="headerlink" title="增加用户直接加上组"></a>增加用户直接加上组</h5><pre><code class="bash">useradd -g [组] [用户名]</code></pre><p>增加一个用户crg，分组到zf</p><pre><code class="bash">[root@localhost ~]# useradd -g zf crguseradd：“zf”组不存在[root@localhost ~]# groupadd zf[root@localhost ~]# useradd -g zf crg[root@localhost ~]# id crguid=1002(crg) gid=1002(zf) 组=1002(zf)</code></pre><p>这里我原本以为直接用命令，系统会自动帮我建组，看来我想多了😭，必须你自己建个组，然后再分组</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg zf 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><pre><code class="bash">usermod -g [用户组] [用户名]</code></pre><pre><code class="bash">[root@localhost home]# groupadd dw[root@localhost home]# usermod -g dw crg[root@localhost home]# id crguid=1002(crg) gid=1003(dw) 组=1003(dw)</code></pre><p>这样我们就把<strong>crg</strong>从<strong>zf组</strong>调到<strong>dw组</strong></p><hr><h3 id="用户的配置文件"><a href="#用户的配置文件" class="headerlink" title="用户的配置文件"></a>用户的配置文件</h3><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190929105530.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009095520.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">crg: 用户名x: 加密的密码 真正的密码在 shadow文件里1002: 用户id1003: 组id/home/crg: 用户所在home目录/bin/bash：对应的shell</code></pre><h5 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009100032.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009140544.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">dw: 组名1003: 组id</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(一):vim与vi</title>
    <link href="undefined2019/11/02/Linux-1-vim%E4%B8%8Evi/"/>
    <url>2019/11/02/Linux-1-vim%E4%B8%8Evi/</url>
    
    <content type="html"><![CDATA[<h1 id="vim与vi"><a href="#vim与vi" class="headerlink" title="vim与vi"></a>vim与vi</h1><h3 id="什么是vim？"><a href="#什么是vim？" class="headerlink" title="什么是vim？"></a>什么是vim？</h3><blockquote><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p></blockquote><h3 id="vi和vim的三种模式转化图如下"><a href="#vi和vim的三种模式转化图如下" class="headerlink" title="vi和vim的三种模式转化图如下:"></a>vi和vim的三种模式转化图如下:</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtbszrfgj30ik0a4whj.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><pre><code class="linux">[root@localhost ~]# ll总用量 4-rw-------. 1 root root 1416 9月   4 20:36 anaconda-ks.cfg[root@localhost ~]# </code></pre><p>可以看出我没有Hello.java文件</p><p>使用命令</p><pre><code class="linux">[root@localhost ~]# vim Hello.java</code></pre><p>随后进入一般模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1dy0j2nj30lf0tb3yo.jpg" srcset="/img/loading.gif" alt=""></p><p>此时还不能编辑，如果要编辑 需要按  <strong>Insert</strong> 或 按 <strong>i</strong> ，进入编辑模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1gyfv0bj30ho0a5q2v.jpg" srcset="/img/loading.gif" alt=""></p><p>当左下角出现<strong>插入</strong>的时候才能开始编辑，如图</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1jlvw60j30ib04i3ys.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，如果要保存</p><blockquote><p><strong>Shift + ; + wq</strong>(wq是 写入(wirte)并退出(queit))</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1mqs047j303p03gmwz.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>:q!</strong>是不保存退出</p><h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtnweqdbj30q90f0gr2.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="1-拷贝"><a href="#1-拷贝" class="headerlink" title="1. 拷贝"></a>1. 拷贝</h5><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dubycqkbj307105zt8s.jpg" srcset="/img/loading.gif" alt=""></p><p>首先插入一些字符,随后按<strong>ESC</strong>进入<strong>命令模式</strong>，选定一行按<strong>yy</strong>，之后按<strong>p</strong>，按一次<strong>P</strong>，粘贴一次</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7duf1mpdzj3063071dft.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，将<strong>光标</strong>移动到第一行，并按<strong>5yy</strong>（Linux的所有数字都是大键盘上的，小键盘的数字会产生其他效果）,随后按<strong>P</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dulepza4j308b02g744.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dumcpa0bj30530bajrl.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h5><p>和拷贝语法类似，我们用<strong>5dd</strong>删除五行</p><p>效果如下:</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dusx4k7gj304406gdfu.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h5><p>进入<strong>命令模式</strong>，输入<strong>/ + [关键字] + 回车</strong>即可查询,按<strong>N</strong>查找下一个</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv1j36y1j303w01ft8h.jpg" srcset="/img/loading.gif" alt=""></p><p>这里要注意Linux的查找字符是<strong>严格区分大小写</strong>的，我这里小写的sbdl就没匹配到😭</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv20n1r3j305u0ag74k.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="4-设置行号"><a href="#4-设置行号" class="headerlink" title="4.设置行号"></a>4.设置行号</h5><p>例行进入<strong>命令模式</strong>，输入 <strong>:set nu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvy3a60vj304o02e3yc.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvygdj6ej307008xq37.jpg" srcset="/img/loading.gif" alt=""></p><p>取消，行号<strong>:set nonu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzjksdfj305r023t8i.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzwzaktj3049081jrj.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="5-行尾和行首"><a href="#5-行尾和行首" class="headerlink" title="5.行尾和行首"></a>5.行尾和行首</h5><pre><code>[root@localhost ~]# vim /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>Shift + g</strong>，进入行尾</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145504.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>gg</strong>回到行首</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><h5 id="6-撤消"><a href="#6-撤消" class="headerlink" title="6.撤消"></a>6.撤消</h5><p>在<strong>编辑模式</strong>下乱输字符</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145915.png" srcset="/img/loading.gif" alt=""></p><p>随后,按<strong>ESC</strong>进入<strong>正常模式</strong>按<strong>u</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927150026.png" srcset="/img/loading.gif" alt=""></p><h5 id="7-移动光标"><a href="#7-移动光标" class="headerlink" title="7.移动光标"></a>7.移动光标</h5><p>第一步：进入<strong>编辑模式</strong>，设置行号， <strong>:set nu</strong></p><p>第二步：进入<strong>正常模式</strong>，输入你要去的行数  10 + <strong>Shift + g</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927153646.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/10/30/hello-world/"/>
    <url>2019/10/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>