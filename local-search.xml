<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Srb(二):后端工程搭建</title>
    <link href="undefined2022/02/03/Srb-2-%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"/>
    <url>2022/02/03/Srb-2-%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Srb-二-后端工程搭建"><a href="#Srb-二-后端工程搭建" class="headerlink" title="Srb(二):后端工程搭建"></a>Srb(二):后端工程搭建</h1><h1 id="01-后台接口工程搭建"><a href="#01-后台接口工程搭建" class="headerlink" title="01-后台接口工程搭建"></a>01-后台接口工程搭建</h1><h2 id="基础框架结构"><a href="#基础框架结构" class="headerlink" title="基础框架结构"></a>基础框架结构</h2><p><strong>Srb：</strong> 总工程，父依赖</p><p><strong>srb-common：</strong>工程通用包依赖，其他的工程都引入这个通用工程 ( 非微服务 )</p><p><strong>service-base：</strong>持久层的依赖 ( 非微服务 )</p><p><strong>service-core：</strong>核心业务 ( 具体的微服务 )</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/architecture.png" srcset="/img/loading.gif" alt="基础框架结构图"></p><h2 id="一、创建父工程-Srb"><a href="#一、创建父工程-Srb" class="headerlink" title="一、创建父工程 Srb"></a>一、创建父工程 Srb</h2><h3 id="1-新建一个文件夹-取名-Srb"><a href="#1-新建一个文件夹-取名-Srb" class="headerlink" title="1. 新建一个文件夹 取名 Srb"></a>1. 新建一个文件夹 取名 Srb</h3><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/1.png" srcset="/img/loading.gif" alt="srb"></p><h3 id="2-添加一个pom-xml"><a href="#2-添加一个pom-xml" class="headerlink" title="2. 添加一个pom.xml"></a>2. 添加一个pom.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.frankeleyn&lt;/groupId&gt;    &lt;artifactId&gt;srb&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;!-- 打包方式 --&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;!-- 配置 Spring Boot 版本 --&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;!-- 配置 pom 依赖版本号 --&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring-cloud-alibaba.version&gt;2.2.2.RELEASE&lt;/spring-cloud-alibaba.version&gt;        &lt;spring-cloud.version&gt;Hoxton.SR8&lt;/spring-cloud.version&gt;        &lt;mybatis-plus.version&gt;3.4.1&lt;/mybatis-plus.version&gt;        &lt;velocity.version&gt;2.0&lt;/velocity.version&gt;        &lt;swagger.version&gt;2.9.2&lt;/swagger.version&gt;        &lt;swagger-bootstrap-ui.version&gt;1.9.2&lt;/swagger-bootstrap-ui.version&gt;        &lt;commons-lang3.version&gt;3.9&lt;/commons-lang3.version&gt;        &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt;        &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt;        &lt;alibaba.easyexcel.version&gt;2.1.1&lt;/alibaba.easyexcel.version&gt;        &lt;apache.xmlbeans.version&gt;3.1.0&lt;/apache.xmlbeans.version&gt;        &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt;        &lt;gson.version&gt;2.8.2&lt;/gson.version&gt;        &lt;json.version&gt;20170516&lt;/json.version&gt;        &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt;        &lt;aliyun-sdk-oss.version&gt;3.10.2&lt;/aliyun-sdk-oss.version&gt;        &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt;        &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt;        &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt;    &lt;/properties&gt;    &lt;!-- 配置 pom 依赖--&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;!--Spring Cloud--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--Spring Cloud Alibaba--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;                &lt;version&gt;${spring-cloud-alibaba.version}&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--mybatis-plus--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;                &lt;version&gt;${mybatis-plus.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--mybatis-plus 代码生成器--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;                &lt;version&gt;${mybatis-plus.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- Mybatis Plus 代码生成器模板引擎,  --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;                &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;                &lt;version&gt;${velocity.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--swagger--&gt;            &lt;dependency&gt;                &lt;groupId&gt;io.springfox&lt;/groupId&gt;                &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;                &lt;version&gt;${swagger.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--swagger ui--&gt;            &lt;dependency&gt;                &lt;groupId&gt;io.springfox&lt;/groupId&gt;                &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;                &lt;version&gt;${swagger.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--swagger-bootstrap-ui--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;                &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;                &lt;version&gt;${swagger-bootstrap-ui.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--commons-lang3--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;                &lt;version&gt;${commons-lang3.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--文件上传--&gt;            &lt;dependency&gt;                &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;                &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;                &lt;version&gt;${commons-fileupload.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--commons-io--&gt;            &lt;dependency&gt;                &lt;groupId&gt;commons-io&lt;/groupId&gt;                &lt;artifactId&gt;commons-io&lt;/artifactId&gt;                &lt;version&gt;${commons-io.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--excel解析--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;                &lt;version&gt;${alibaba.easyexcel.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--excel解析依赖--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.apache.xmlbeans&lt;/groupId&gt;                &lt;artifactId&gt;xmlbeans&lt;/artifactId&gt;                &lt;version&gt;${apache.xmlbeans.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--json--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;                &lt;version&gt;${fastjson.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.json&lt;/groupId&gt;                &lt;artifactId&gt;json&lt;/artifactId&gt;                &lt;version&gt;${json.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;                &lt;artifactId&gt;gson&lt;/artifactId&gt;                &lt;version&gt;${gson.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--阿里云SDK远程调用--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.aliyun&lt;/groupId&gt;                &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;                &lt;version&gt;${aliyun-java-sdk-core.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--阿里云文件管理--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;                &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;                &lt;version&gt;${aliyun-sdk-oss.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--日期时间工具--&gt;            &lt;dependency&gt;                &lt;groupId&gt;joda-time&lt;/groupId&gt;                &lt;artifactId&gt;joda-time&lt;/artifactId&gt;                &lt;version&gt;${jodatime.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--jwt工具--&gt;            &lt;dependency&gt;                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;                &lt;artifactId&gt;jjwt&lt;/artifactId&gt;                &lt;version&gt;${jwt.version}&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--httpclient--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;                &lt;artifactId&gt;httpclient&lt;/artifactId&gt;                &lt;version&gt;${httpclient.version}&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;</code></pre><h2 id="二、创建模块-srb-common"><a href="#二、创建模块-srb-common" class="headerlink" title="二、创建模块 srb-common"></a>二、创建模块 srb-common</h2><h3 id="1-创建-Maven-模块"><a href="#1-创建-Maven-模块" class="headerlink" title="1. 创建 Maven 模块"></a>1. 创建 Maven 模块</h3><p>在 Srb 父工程下，创建一个 Maven 模块</p><p>Group: <strong>com.frankeleyn</strong></p><p>Artifact: <strong>srb-common</strong></p><h3 id="2-配置-pom"><a href="#2-配置-pom" class="headerlink" title="2.  配置 pom"></a>2.  配置 pom</h3><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h2 id="三、创建模块-service-base"><a href="#三、创建模块-service-base" class="headerlink" title="三、创建模块 service-base"></a>三、创建模块 service-base</h2><h3 id="1-创建-Maven-模块-1"><a href="#1-创建-Maven-模块-1" class="headerlink" title="1. 创建 Maven 模块"></a>1. 创建 Maven 模块</h3><p>Group: <strong>com.frankeleyn</strong></p><p>Artifact: <strong>service-base</strong></p><h3 id="2-配置-pom-1"><a href="#2-配置-pom-1" class="headerlink" title="2. 配置 pom"></a>2. 配置 pom</h3><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- 引入 common 项目--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.frankeleyn&lt;/groupId&gt;        &lt;artifactId&gt;srb-common&lt;/artifactId&gt;        &lt;version&gt;1.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--swagger--&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--swagger ui--&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--mysql--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--mybatis-plus--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--mybatis-plus 代码生成器--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- Mybatis Plus 代码生成器模板引擎,  --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;        &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h2 id="四、创建模块-service-core"><a href="#四、创建模块-service-core" class="headerlink" title="四、创建模块 service-core"></a>四、创建模块 service-core</h2><h3 id="1-创建-Maven-模块-2"><a href="#1-创建-Maven-模块-2" class="headerlink" title="1. 创建 Maven 模块"></a>1. 创建 Maven 模块</h3><p>Group: <strong>com.frankeleyn</strong></p><p>Artifact: <strong>service-core</strong></p><h3 id="2-配置-pom-2"><a href="#2-配置-pom-2" class="headerlink" title="2. 配置 pom"></a>2. 配置 pom</h3><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.frankeleyn&lt;/groupId&gt;        &lt;artifactId&gt;service-base&lt;/artifactId&gt;        &lt;version&gt;1.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h2 id="五、启动应用程序"><a href="#五、启动应用程序" class="headerlink" title="五、启动应用程序"></a>五、启动应用程序</h2><p>进入 <strong>service-core</strong> 项目中</p><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p>创建 <strong>application.properties</strong></p><pre><code class="properties"># 端口号server.port= 8110# ==================== 数据源设置 =========================spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/srb_core?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123456# ================ mybatis 配置 =========================# 驼峰命名mybatis-plus.configuration.map-underscore-to-camel-case=true# 扫描映射配置文件mybatis-plus.mapper-locations=classpath:mapper/*Mapper.xml# 打印 sqlmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><h3 id="2-创建启动类"><a href="#2-创建启动类" class="headerlink" title="2. 创建启动类"></a>2. 创建启动类</h3><pre><code class="java">package com.frankeleyn.srb.core;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author Frankeleyn * @date 2022/1/21 11:53 */@SpringBootApplicationpublic class ServiceCoreApplication {    public static void main(String[] args) {        SpringApplication.run(ServiceCoreApplication.class, args);    }}</code></pre><h3 id="3-创建-Mybatis-Plus-配置文件"><a href="#3-创建-Mybatis-Plus-配置文件" class="headerlink" title="3. 创建 Mybatis Plus 配置文件"></a>3. 创建 Mybatis Plus 配置文件</h3><p>创建一个 <strong>config</strong> 包，创建类 <strong>MybatisPlusConfig</strong></p><pre><code class="java">package com.frankeleyn.srb.core.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * @author Frankeleyn * @date 2022/1/17 15:22 */@Configuration@EnableTransactionManagement@MapperScan(&quot;com.frankeleyn.srb.core.mapper&quot;)public class MybatisPlusConfig {    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() {        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        // 将分页插件放入容器        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        // 添加乐观锁插件        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());        return interceptor;    }}</code></pre><h2 id="六、代码生成器"><a href="#六、代码生成器" class="headerlink" title="六、代码生成器"></a>六、代码生成器</h2><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h3><p>创建数据库 <strong>srb_core</strong></p><p>并执行 sql 脚本初始化数据结构和数据</p><h3 id="2-创建代码生成器"><a href="#2-创建代码生成器" class="headerlink" title="2. 创建代码生成器"></a>2. 创建代码生成器</h3><p>在 <strong>test</strong> 目录中创建测试用例，并执行</p><pre><code class="java">package com.frankeleyn.srb.core;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;/** * @author Frankeleyn * @date 2022/1/21 14:03 */@SpringBootTestpublic class GeneratorTest {    @Test    public void generate() {        // 创建 mp 代码生成器        AutoGenerator autoGenerator = new AutoGenerator();        // 1 全局配置, 如命名规则，主键策略等        GlobalConfig gc = new GlobalConfig();        String projectPath = System.getProperty(&quot;user.dir&quot;);        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);        gc.setAuthor(&quot;Frankeleyn&quot;);        // 生成后是否打开资源管理器        gc.setOpen(false);        // 去掉Service接口的首字母I        gc.setServiceName(&quot;%sService&quot;);        // 主键策略        gc.setIdType(IdType.AUTO);        // 开启Swagger2模式        gc.setSwagger2(true);         autoGenerator.setGlobalConfig(gc);        // 2 数据源配置        DataSourceConfig dataSourceConfig = new DataSourceConfig();        dataSourceConfig.setUrl(&quot;jdbc:mysql://localhost:3306/srb_core?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false&quot;);        dataSourceConfig.setUsername(&quot;root&quot;);        dataSourceConfig.setPassword(&quot;123456&quot;);        dataSourceConfig.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);        dataSourceConfig.setDbType(DbType.MYSQL);        autoGenerator.setDataSource(dataSourceConfig);        // 3 生成映射代码类的包配置        PackageConfig packageConfig = new PackageConfig();        packageConfig.setParent(&quot;com.frankeleyn.srb.core&quot;);        packageConfig.setEntity(&quot;pojo.entity&quot;);        autoGenerator.setPackageInfo(packageConfig);        // 4 其他配置，如下划线，是否逻辑删除等        StrategyConfig strategy = new StrategyConfig();        //数据库表映射到实体的命名策略        strategy.setNaming(NamingStrategy.underline_to_camel);        //数据库表字段映射到实体的命名策略        strategy.setColumnNaming(NamingStrategy.underline_to_camel);        // lombok, 就是添加一个 @Data        strategy.setEntityLombokModel(true);        //逻辑删除字段名        strategy.setLogicDeleteFieldName(&quot;is_deleted&quot;);        //去掉布尔值的is_前缀（确保tinyint(1)）        strategy.setEntityBooleanColumnRemoveIsPrefix(true);        //restful api风格控制器        strategy.setRestControllerStyle(true);         autoGenerator.setStrategy(strategy);        // 执行 mp 代码生成器        autoGenerator.execute();    }}</code></pre><h3 id="3-执行结果"><a href="#3-执行结果" class="headerlink" title="3. 执行结果"></a>3. 执行结果</h3><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/generator.png" srcset="/img/loading.gif" alt="自动生成"></p><h1 id="02-积分等级-CRUD"><a href="#02-积分等级-CRUD" class="headerlink" title="02-积分等级 CRUD"></a>02-积分等级 CRUD</h1><h2 id="一、积分等级列表接口"><a href="#一、积分等级列表接口" class="headerlink" title="一、积分等级列表接口"></a>一、积分等级列表接口</h2><h3 id="1-编写积分等级管理接口"><a href="#1-编写积分等级管理接口" class="headerlink" title="1. 编写积分等级管理接口"></a>1. 编写积分等级管理接口</h3><p>在 <strong>controller</strong> 包中新建 <strong>admin</strong> 包，将自动生成的类 <strong>IntegralGradeController</strong> 移动到该包</p><pre><code class="java">@CrossOrigin@RestController@RequestMapping(&quot;/admin/core/integralGrade&quot;)public class IntegralGradeController {    @Autowired    private IntegralGradeService integralGradeService;    @GetMapping(&quot;/list&quot;)    public List&lt;IntegralGrade&gt; findAll() {        return integralGradeService.list();    }    @DeleteMapping(&quot;/remove/{id}&quot;)    public boolean removeById(@PathVariable Long id) {        return integralGradeService.removeById(id);    }    @PostMapping(&quot;/save&quot;)    public boolean save(@ReqestBody IntegralGrade integralGrade ) {        return integralGradeService.save(integralGrade);    }    @PutMapping(&quot;/update&quot;)    public boolean update(@ReqestBody IntegralGrade integralGrade ) {        return integralGradeService.updateById(integralGrade);    }}</code></pre><h3 id="2-测试"><a href="#2-测试" class="headerlink" title="2. 测试"></a>2. 测试</h3><p>访问：<a href="http://localhost:8110/admin/core/integralGrade/list" target="_blank" rel="noopener">http://localhost:8110/admin/core/integralGrade/list</a> 查看 json 结果</p><h2 id="二、配置-Swagger2"><a href="#二、配置-Swagger2" class="headerlink" title="二、配置 Swagger2"></a>二、配置 Swagger2</h2><p>Swagger 是一个根据接口自动生成 api 文档和对应测试的 web 页面</p><h3 id="1-Swagger2-配置文件"><a href="#1-Swagger2-配置文件" class="headerlink" title="1. Swagger2 配置文件"></a>1. Swagger2 配置文件</h3><p>新建 <strong>config</strong> 文件夹，然后新建 <strong>Swagger2Config</strong> 类</p><pre><code class="java">package com.frankeleyn.srb.core.config;import com.google.common.base.Predicates;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author Frankeleyn * @date 2022/1/21 15:03 */@EnableSwagger2@Configurationpublic class Swagger2Config {    @Bean    public Docket coreApiConfig() {        Docket docket = new Docket(DocumentationType.SWAGGER_2)                  .apiInfo(adminApiInfo())                  .groupName(&quot;adminApi&quot;)                  .select()                   // 扫描 Controller 下面的 admin 包                  .paths(Predicates.and(PathSelectors.regex(&quot;/admin/.*&quot;)))                  .build();        return docket;    }    private ApiInfo adminApiInfo(){        return new ApiInfoBuilder()                .title(&quot;尚融宝后台管理系统-API文档&quot;)                .description(&quot;本文档描述了尚融宝后台管理系统接口&quot;)                .version(&quot;1.0&quot;)                .contact(new Contact(&quot;Frankeleyn&quot;, &quot;https://githubfast.com/Frankeleyns/&quot;, &quot;2582726641@qq.com&quot;))                .build();    }}</code></pre><h3 id="2-移动-Controller"><a href="#2-移动-Controller" class="headerlink" title="2. 移动 Controller"></a>2. 移动 Controller</h3><p>在 <strong>controller</strong> 包下，新建 <strong>admin</strong> 包，将 <strong>IntegralGradeController</strong> 移动到 admin 文件夹下</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/02-2-2-1.png" srcset="/img/loading.gif" alt="移动 Controller"></p><h3 id="3-Swagger-常用注解"><a href="#3-Swagger-常用注解" class="headerlink" title="3. Swagger 常用注解"></a>3. Swagger 常用注解</h3><p><strong>实体类注解：</strong>entity的实体类中可以添加一些自定义设置</p><pre><code class="java">@ApiModelProperty(value = &quot;创建时间&quot;, example = &quot;2019-01-01 8:00:00&quot;)private LocalDateTime createTime;@ApiModelProperty(value = &quot;更新时间&quot;, example = &quot;2019-01-01 8:00:00&quot;)private LocalDateTime updateTime;</code></pre><p><strong>controller</strong> 注解</p><p>定义在类上：</p><pre><code class="java">@Api(tags = &quot;积分等级管理 Api&quot;)</code></pre><p>定义在方法上：</p><pre><code class="java">@ApiOperation(value = &quot;根据 id 删除积分等级&quot;, notes = &quot;逻辑删除&quot;)</code></pre><p>定义在参数上：</p><pre><code class="java">@ApiParam(value = &quot;数据id&quot;, required = true, example = &quot;100&quot;)</code></pre><h3 id="4-查看-Swagger-文档"><a href="#4-查看-Swagger-文档" class="headerlink" title="4. 查看 Swagger 文档"></a>4. 查看 Swagger 文档</h3><p>重启服务器查看接口文档：<a href="http://localhost:8110/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8110/swagger-ui.html</a></p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/swagger.png" srcset="/img/loading.gif" alt="swaager 文档"></p><h1 id="03-统一返回结果"><a href="#03-统一返回结果" class="headerlink" title="03-统一返回结果"></a>03-统一返回结果</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>通常项目中我们会将响应结果封装成 json 返回，一般我们会将所有接口的数据格式统一， 使前端工程师调用我们项目的外部接口更一致。</p><p>一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含<strong>状态码、返回消息、数据</strong>这三部分内容：</p><pre><code class="json">{   &quot;code&quot; : 0,    &quot;message&quot; : &quot;success&quot;,    &quot;data&quot; : &quot;数据&quot;}</code></pre><h2 id="二、定义统一返回结果"><a href="#二、定义统一返回结果" class="headerlink" title="二、定义统一返回结果"></a>二、定义统一返回结果</h2><h3 id="1-创建枚举"><a href="#1-创建枚举" class="headerlink" title="1. 创建枚举"></a>1. 创建枚举</h3><p>在 <strong>srb-common</strong> 项目下，新建 <strong>result</strong> 包，创建枚举类 <strong>ReponseEnum</strong></p><pre><code class="java">package com.frankeleyn.common.result;/** * @author Frankeleyn * @date 2022/1/21 15:38 */@Getter@AllArgsConstructor@ToStringpublic enum ResponseEnum {    SUCCESS(0, &quot;成功&quot;),    ERROR(-1, &quot;服务器内部错误&quot;),    //-1xx 服务器错误    BAD_SQL_GRAMMAR_ERROR(-101, &quot;sql语法错误&quot;),    SERVLET_ERROR(-102, &quot;servlet请求异常&quot;), //-2xx 参数校验    UPLOAD_ERROR(-103, &quot;文件上传错误&quot;),    EXPORT_DATA_ERROR(104, &quot;数据导出失败&quot;),    //-2xx 参数校验    BORROW_AMOUNT_NULL_ERROR(-201, &quot;借款额度不能为空&quot;),    MOBILE_NULL_ERROR(-202, &quot;手机号码不能为空&quot;),    MOBILE_ERROR(-203, &quot;手机号码不正确&quot;),    PASSWORD_NULL_ERROR(204, &quot;密码不能为空&quot;),    CODE_NULL_ERROR(205, &quot;验证码不能为空&quot;),    CODE_ERROR(206, &quot;验证码错误&quot;),    MOBILE_EXIST_ERROR(207, &quot;手机号已被注册&quot;),    LOGIN_MOBILE_ERROR(208, &quot;用户不存在&quot;),    LOGIN_PASSWORD_ERROR(209, &quot;密码错误&quot;),    LOGIN_LOKED_ERROR(210, &quot;用户被锁定&quot;),    LOGIN_AUTH_ERROR(-211, &quot;未登录&quot;),    USER_BIND_IDCARD_EXIST_ERROR(-301, &quot;身份证号码已绑定&quot;),    USER_NO_BIND_ERROR(302, &quot;用户未绑定&quot;),    USER_NO_AMOUNT_ERROR(303, &quot;用户信息未审核&quot;),    USER_AMOUNT_LESS_ERROR(304, &quot;您的借款额度不足&quot;),    LEND_INVEST_ERROR(305, &quot;当前状态无法投标&quot;),    LEND_FULL_SCALE_ERROR(306, &quot;已满标，无法投标&quot;),    NOT_SUFFICIENT_FUNDS_ERROR(307, &quot;余额不足，请充值&quot;),    PAY_UNIFIEDORDER_ERROR(401, &quot;统一下单错误&quot;),    ALIYUN_SMS_LIMIT_CONTROL_ERROR(-502, &quot;短信发送过于频繁&quot;),//业务限流    ALIYUN_SMS_ERROR(-503, &quot;短信发送失败&quot;),//其他失败    WEIXIN_CALLBACK_PARAM_ERROR(-601, &quot;回调参数不正确&quot;),    WEIXIN_FETCH_ACCESSTOKEN_ERROR(-602, &quot;获取access_token失败&quot;),    WEIXIN_FETCH_USERINFO_ERROR(-603, &quot;获取用户信息失败&quot;),    ;    private Integer code;//状态码    private String message;//消息}</code></pre><h3 id="2、定义统一结果类"><a href="#2、定义统一结果类" class="headerlink" title="2、定义统一结果类"></a>2、定义统一结果类</h3><pre><code class="java">package com.frankeleyn.common.result;/** * @author Frankeleyn * @date 2022/1/21 15:38 */@Datapublic class R {    private Integer code;    private String message;    private Map&lt;String, Object&gt; data = new HashMap();    /**     * 构造器私有     */    private R(){}    /**     * 返回成功     */    public static R ok(){        R r = new R();        r.setCode(ResponseEnum.SUCCESS.getCode());        r.setMessage(ResponseEnum.SUCCESS.getMessage());        return r;    }    public static R ok(String message) {        return ok().message(message);    }    public static R ok(String key, Object value) {        return ok().data(key, value);    }    /**     * 返回失败     */    public static R error(){        R r = new R();        r.setCode(ResponseEnum.ERROR.getCode());        r.setMessage(ResponseEnum.ERROR.getMessage());        return r;    }    public static R error(String message) {        return error().message(message);    }    public static R error(Integer code, String message) {        return error(message).code(code);    }    /**     * 设置特定结果     */    public static R setResult(ResponseEnum responseEnum){        R r = new R();        r.setCode(responseEnum.getCode());        r.setMessage(responseEnum.getMessage());        return r;    }    public R message(String message){        this.setMessage(message);        return this;    }    public R code(Integer code){        this.setCode(code);        return this;    }    public R data(String key, Object value){        this.data.put(key, value);        return this;    }    public R data(Map&lt;String, Object&gt; map){        this.setData(map);        return this;    }}</code></pre><h2 id="三、使用统一返回结果"><a href="#三、使用统一返回结果" class="headerlink" title="三、使用统一返回结果"></a>三、使用统一返回结果</h2><p>修改 <strong>IntegralGradeController</strong> 中的方法</p><h3 id="1-修改-findAll"><a href="#1-修改-findAll" class="headerlink" title="1. 修改 findAll"></a>1. 修改 findAll</h3><pre><code class="java">@ApiOperation(&quot;获取积分等级列表&quot;)@GetMapping(&quot;/list&quot;)public R findAll() {    List&lt;IntegralGrade&gt; integralGradeList = integralGradeService.list();    return R.ok(&quot;integralGradeList&quot;, integralGradeList);}</code></pre><h3 id="2-修改-removeById"><a href="#2-修改-removeById" class="headerlink" title="2. 修改 removeById"></a>2. 修改 removeById</h3><pre><code class="java">@ApiOperation(value = &quot;根据 id 删除积分等级&quot;, notes = &quot;逻辑删除&quot;)@DeleteMapping(&quot;/remove/{id}&quot;)public R removeById(@ApiParam(&quot;积分等级 id&quot;) @PathVariable Long id) {    boolean remove = integralGradeService.removeById(id);    if (remove)        return R.ok(&quot;删除积分等级成功&quot;);    else        return R.error(&quot;删除积分等级失败&quot;);}</code></pre><h3 id="3-修改-save"><a href="#3-修改-save" class="headerlink" title="3. 修改 save"></a>3. 修改 save</h3><pre><code class="java">@ApiOperation(&quot;新增积分等级&quot;)@PostMapping(&quot;/save&quot;)public R save(@ApiParam(&quot;积分等级对象&quot;) @RequestBody IntegralGrade integralGrade) {    boolean save = integralGradeService.save(integralGrade);    if (save)        return R.ok(&quot;新增积分等级成功&quot;);    else        return R.error(&quot;新增积分等级失败&quot;);}</code></pre><h3 id="4-修改-update"><a href="#4-修改-update" class="headerlink" title="4. 修改 update"></a>4. 修改 update</h3><pre><code class="java">@ApiOperation(&quot;修改积分等级&quot;)@PutMapping(&quot;/update&quot;)public R updateById(@ApiParam(&quot;积分等级对象&quot;) @RequestBody IntegralGrade integralGrade) {    boolean update = integralGradeService.updateById(integralGrade);    if (update)        return R.ok(&quot;修改积分等级成功&quot;);    else        return R.error(&quot;修改积分等级失败&quot;);}</code></pre><h3 id="5-根据-id-查询"><a href="#5-根据-id-查询" class="headerlink" title="5. 根据 id 查询"></a>5. 根据 id 查询</h3><pre><code class="java">@ApiOperation(&quot;根据 id 查询积分等级&quot;)@GetMapping(&quot;/get/{id}&quot;)public R findById(@ApiParam(&quot;积分等级 id&quot;) @PathVariable Long id) {    IntegralGrade integralGrade = integralGradeService.getById(id);    if (Objects.nonNull(integralGrade))         return R.ok(&quot;integralGrade&quot;, integralGrade);    else         return R.error(&quot;未查询到积分等级&quot;);}</code></pre><h1 id="04-统一异常处理"><a href="#04-统一异常处理" class="headerlink" title="04-统一异常处理"></a>04-统一异常处理</h1><h2 id="一、介绍-1"><a href="#一、介绍-1" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>在接口发生异常时，一般是在 <strong>controller</strong> 抛出 <strong>exception</strong> 异常时，通过 <strong>aop</strong> 的异常通知处理接口的返回结果的全局设置，叫 <strong>统一异常处理</strong>。</p><h2 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h2><h3 id="1-创建统一异常处理器"><a href="#1-创建统一异常处理器" class="headerlink" title="1. 创建统一异常处理器"></a>1. 创建统一异常处理器</h3><p>在 <strong>srb-common</strong> 中创建 <strong>exception</strong> 包，创建统一异常处理器类 <strong>UnifiedExceptionHandler</strong></p><pre><code class="java">package com.frankeleyn.common.exception;@Component@RestControllerAdvicepublic class UnifiedExceptionHandler {    @ExceptionHandler(Exception.class)    public R handleException(Exception e) {        return R.error();    }}</code></pre><h3 id="2-service-core-添加扫描"><a href="#2-service-core-添加扫描" class="headerlink" title="2. service-core 添加扫描"></a>2. service-core 添加扫描</h3><p><strong>UnifiedExceptionHandler</strong> 所在位置，是 <strong>service-core</strong> 服务启动器扫描不到的，所以需要在它的启动类中自定义扫描路径：</p><pre><code class="java">@SpringBootApplication@ComponentScan(basePackages = {&quot;com.frankeleyn.srb&quot;,&quot;com.frankeleyn.common&quot;})public class ServiceCoreApplication {</code></pre><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>返回统一错误结果</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/ExceptionHandler.png" srcset="/img/loading.gif" alt="ExceptionHandler"></p><h2 id="三、处理特定异常"><a href="#三、处理特定异常" class="headerlink" title="三、处理特定异常"></a>三、处理特定异常</h2><p>如果我们不想显示统一的“服务器内部错误”，需要个性化的显示异常信息，那么需要针对特定的异常做处理</p><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><p>在 <strong>srb-common</strong> 项目的 pom 中</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="2-添加异常处理方法"><a href="#2-添加异常处理方法" class="headerlink" title="2. 添加异常处理方法"></a>2. 添加异常处理方法</h3><p>在 <strong>UnifiedExceptionHandler</strong> 中添加</p><pre><code class="java">@ExceptionHandler(BadSqlGrammarException.class)public R handleSQLException(BadSqlGrammarException e) {    System.out.println(&quot;SQL 异常&quot; + e.getMessage());    return R.error(&quot;SQL 语法错误&quot;);}</code></pre><h3 id="3-测试-1"><a href="#3-测试-1" class="headerlink" title="3. 测试"></a>3. 测试</h3><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/ExceptionHandler2.png" srcset="/img/loading.gif" alt="SqlExceptionHandler"></p><h2 id="四、自定义异常"><a href="#四、自定义异常" class="headerlink" title="四、自定义异常"></a>四、自定义异常</h2><p>有些数据，数据库认为它是合理的，但是不符合我们现实中的认知，比如我的积分等级将你的起始借款金额设置为负数，这明显不符合逻辑，哪里有借款额度是负数的，但是程序却不认为这是错的，此类情况在开发中还有很多，所以我们就需要自定义异常用于业务处理，易于维护。</p><h3 id="1-创建自定义异常类"><a href="#1-创建自定义异常类" class="headerlink" title="1.  创建自定义异常类"></a>1.  创建自定义异常类</h3><p>在 <strong>srb-common</strong> 项目的 <strong>Exception</strong> 包下新建 <strong>BusinessException</strong></p><pre><code class="java">package com.frankeleyn.common.exception;@Data@NoArgsConstructorpublic class BusinessException extends RuntimeException {    //状态码    private Integer code;    //错误消息    private String message;    /**     *     * @param message 错误消息     */    public BusinessException(String message) {        this.message = message;    }    /**     *     * @param message 错误消息     * @param code 错误码     */    public BusinessException(String message, Integer code) {        this.message = message;        this.code = code;    }    /**     *     * @param message 错误消息     * @param code 错误码     * @param cause 原始异常对象     */    public BusinessException(String message, Integer code, Throwable cause) {        super(cause);        this.message = message;        this.code = code;    }    /**     *     * @param resultCodeEnum 接收枚举类型     */    public BusinessException(ResponseEnum resultCodeEnum) {        this.message = resultCodeEnum.getMessage();        this.code = resultCodeEnum.getCode();    }    /**     *     * @param resultCodeEnum 接收枚举类型     * @param cause 原始异常对象     */    public BusinessException(ResponseEnum resultCodeEnum, Throwable cause) {        super(cause);        this.message = resultCodeEnum.getMessage();        this.code = resultCodeEnum.getCode();    }}</code></pre><h3 id="2-修改-Controller"><a href="#2-修改-Controller" class="headerlink" title="2. 修改 Controller"></a>2. 修改 Controller</h3><p>修改 <strong>IntegralGradeController</strong> 中的 <strong>save</strong> 方法：</p><pre><code class="java">@ApiOperation(&quot;新增积分等级&quot;)@PostMapping(&quot;/save&quot;)public R save(@ApiParam(&quot;积分等级对象&quot;) @RequestBody IntegralGrade integralGrade) {    BigDecimal borrowAmount = integralGrade.getBorrowAmount();    if (Objects.isNull(borrowAmount) || borrowAmount.intValue() &lt;= 0) {        // 借款额度小于等于0，此处抛出异常        throw new BusinessException(ResponseEnum.BORROW_AMOUNT_NULL_ERROR);    }    boolean save = integralGradeService.save(integralGrade);    if (save)        return R.ok(&quot;新增积分等级成功&quot;);    else        return R.error(&quot;新增积分等级失败&quot;);}</code></pre><h3 id="3-添加异常处理方法"><a href="#3-添加异常处理方法" class="headerlink" title="3. 添加异常处理方法"></a>3. 添加异常处理方法</h3><p><strong>UnifiedExceptionHandler</strong> 类中添加：</p><pre><code class="java">/** * 自定义异常 * @param e * @return */@ExceptionHandler(BusinessException.class)public R handleBusinessException(BusinessException e){    System.out.println(&quot;自定义异常&quot; + e.getMessage());    return R.error(e.getCode(), e.getMessage());}</code></pre><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><p><strong>参数</strong></p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/ExceptionHandler3.png" srcset="/img/loading.gif" alt="BussinessExceptionHandler"></p><p><strong>结果</strong></p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/ExceptionHandler4.png" srcset="/img/loading.gif" alt="BussinessExceptionResult"></p><h2 id="五、异常处理优化"><a href="#五、异常处理优化" class="headerlink" title="五、异常处理优化"></a>五、异常处理优化</h2><p>我们的项目中需要对参数进行校验，于是就有大量的 if else，其实我们可以使用优雅的 <strong>Assert(断言)</strong> 类来校验业务的异常情况，消除 if else。</p><h3 id="1-断言示例"><a href="#1-断言示例" class="headerlink" title="1. 断言示例"></a>1. 断言示例</h3><pre><code class="java">package com.frankeleyn.srb.core;@SpringBootTestpublic class AssertTest {    @Test    public void testNotAssert() {        Object o = null;        if (o == null) {            throw new IllegalArgumentException(&quot;对象不能为空&quot;);        }    }    @Test    public void testAssert() {        Object o = null;        Assert.notNull(o, &quot;对象不能为空&quot;);    }}</code></pre><p>上述两个方法是等价的结果，但是断言封装了 if else，让你代码看起来更干净。</p><h3 id="2-自定义断言类"><a href="#2-自定义断言类" class="headerlink" title="2. 自定义断言类"></a>2. 自定义断言类</h3><p>在 <strong>srb-common</strong> 的 <strong>exception</strong> 包下新建 <strong>Assert</strong> 类</p><pre><code class="java">package com.frankeleyn.common.exception;/** * @author Frankeleyn * @date 2022/1/22 10:52 */@Slf4jpublic abstract class Assert {    /**     * 断言对象不为空     * 如果对象obj为空，则抛出异常     * @param obj 待判断对象     */    public static void notNull(Object obj, ResponseEnum responseEnum) {        if (obj == null) {            log.info(&quot;obj is null...............&quot;);            throw new BusinessException(responseEnum);        }    }    /**     * 断言对象为空     * 如果对象obj不为空，则抛出异常     * @param object     * @param responseEnum     */    public static void isNull(Object object, ResponseEnum responseEnum) {        if (object != null) {            log.info(&quot;obj is not null......&quot;);            throw new BusinessException(responseEnum);        }    }    /**     * 断言表达式为真     * 如果不为真，则抛出异常     *     * @param expression 是否成功     */    public static void isTrue(boolean expression, ResponseEnum responseEnum) {        if (!expression) {            log.info(&quot;fail...............&quot;);            throw new BusinessException(responseEnum);        }    }    /**     * 断言两个对象不相等     * 如果相等，则抛出异常     * @param m1     * @param m2     * @param responseEnum     */    public static void notEquals(Object m1, Object m2,  ResponseEnum responseEnum) {        if (m1.equals(m2)) {            log.info(&quot;equals...............&quot;);            throw new BusinessException(responseEnum);        }    }    /**     * 断言两个对象相等     * 如果不相等，则抛出异常     * @param m1     * @param m2     * @param responseEnum     */    public static void equals(Object m1, Object m2,  ResponseEnum responseEnum) {        if (!m1.equals(m2)) {            log.info(&quot;not equals...............&quot;);            throw new BusinessException(responseEnum);        }    }    /**     * 断言参数不为空     * 如果为空，则抛出异常     * @param s     * @param responseEnum     */    public static void notEmpty(String s, ResponseEnum responseEnum) {        if (StringUtils.isEmpty(s)) {            log.info(&quot;is empty...............&quot;);            throw new BusinessException(responseEnum);        }    }}</code></pre><h3 id="3-修改-Controller"><a href="#3-修改-Controller" class="headerlink" title="3. 修改 Controller"></a>3. 修改 Controller</h3><p>修改 <strong>IntegralGradeController</strong> 中的 <strong>save</strong> 方法：</p><pre><code class="java">@ApiOperation(&quot;新增积分等级&quot;)@PostMapping(&quot;/save&quot;)public R save(@ApiParam(&quot;积分等级对象&quot;) @RequestBody IntegralGrade integralGrade) {    BigDecimal borrowAmount = integralGrade.getBorrowAmount();    // 借款额度不能为空    Assert.notNull(borrowAmount, ResponseEnum.BORROW_AMOUNT_NULL_ERROR);    // 借款额读不嫩能为0    Assert.isTrue(0!=borrowAmount.intValue(), ResponseEnum.BORROW_AMOUNT_NULL_ERROR);    boolean save = integralGradeService.save(integralGrade);    if (save)        return R.ok(&quot;新增积分等级成功&quot;);    else        return R.error(&quot;新增积分等级失败&quot;);}</code></pre><h1 id="05-统一日志处理"><a href="#05-统一日志处理" class="headerlink" title="05-统一日志处理"></a>05-统一日志处理</h1><h2 id="一、Logback-日志"><a href="#一、Logback-日志" class="headerlink" title="一、Logback 日志"></a>一、Logback 日志</h2><h3 id="1、什么是日志"><a href="#1、什么是日志" class="headerlink" title="1、什么是日志"></a>1、什么是日志</h3><p>通过日志查看程序的运行过程，运行信息，异常信息等</p><h3 id="2-日志级别"><a href="#2-日志级别" class="headerlink" title="2. 日志级别"></a>2. 日志级别</h3><p>日志记录器（Logger）的行为是分等级的。如下所示：</p><p>分为：<strong>TRACE, DEBUG, INFO(默认), WARN, ERROR</strong></p><p>以上日志级别，从左至右，内容量<strong>从多到少</strong></p><h3 id="3-创建日志文件"><a href="#3-创建日志文件" class="headerlink" title="3. 创建日志文件"></a>3. 创建日志文件</h3><p>spring boot 内部使用 Logback 作为日志默认实现的框架。</p><p><strong>先删除前面在配置文件中的日志级别配置</strong></p><p><strong>resources</strong> 中创建 <strong>logback-spring.xml</strong> （默认日志文件的名字）</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;&lt;/configuration&gt;</code></pre><h2 id="二、基本配置说明"><a href="#二、基本配置说明" class="headerlink" title="二、基本配置说明"></a>二、基本配置说明</h2><h3 id="1-configuration"><a href="#1-configuration" class="headerlink" title="1. configuration"></a>1. configuration</h3><p>日志配置的根节点</p><pre><code class="xml">&lt;configuration&gt;&lt;/configuration&gt;</code></pre><h3 id="2-contextName"><a href="#2-contextName" class="headerlink" title="2.contextName"></a>2.contextName</h3><p><strong>日志文件的名称</strong>，每个logger都关联到logger上下文，默认上下文名称为“default”，用于区分不同的应用程序。</p><pre><code class="xml">&lt;contextName&gt;Srb&lt;/contextName&gt;</code></pre><h3 id="3-property"><a href="#3-property" class="headerlink" title="3. property"></a>3. property</h3><p>日志的属性，相当于 Java 类的属性，用来存储颜色、大小、打印方式等。</p><p>通过<property>定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。</p><pre><code class="xml">&lt;!-- 日志的输出目录 --&gt;&lt;property name=&quot;log.path&quot; value=&quot;E:/WorkSpace/log/srb&quot;/&gt;&lt;!--控制台日志格式：彩色日志--&gt;&lt;!-- magenta:洋红 --&gt;&lt;!-- boldMagenta:粗红--&gt;&lt;!-- cyan:青色 --&gt;&lt;!-- white:白色 --&gt;&lt;!-- magenta:洋红 --&gt;&lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;          value=&quot;%yellow(%date{yyyy-MM-dd HH:mm:ss}) %highlight([%-5level]) %green(%logger) %msg%n&quot;/&gt;&lt;!--文件日志格式--&gt;&lt;property name=&quot;FILE_LOG_PATTERN&quot;          value=&quot;%date{yyyy-MM-dd HH:mm:ss} [%-5level] %thread %file:%line %logger %msg%n&quot; /&gt;&lt;!--编码--&gt;&lt;property name=&quot;ENCODING&quot; value=&quot;UTF-8&quot; /&gt;</code></pre><h3 id="4-appender"><a href="#4-appender" class="headerlink" title="4.appender"></a>4.appender</h3><p><strong>日志对象</strong></p><p><appender>有两个必要属性name和class：name指定appender名称，class指定appender的全限定名</p><p><encoder>对日志进行格式化</p><p><pattern>定义日志的具体输出格式</p><p><charset>编码方式</p><h4 id="控制台日志配置"><a href="#控制台日志配置" class="headerlink" title="控制台日志配置"></a>控制台日志配置</h4><pre><code class="xml">&lt;!-- 控制台日志：将日志打印在控制台中 --&gt;&lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;    &lt;encoder&gt;        &lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt;        &lt;charset&gt;${ENCODING}&lt;/charset&gt;    &lt;/encoder&gt;&lt;/appender&gt;</code></pre><h4 id="文件日志配置"><a href="#文件日志配置" class="headerlink" title="文件日志配置"></a>文件日志配置</h4><p><file>表示日志文件的位置，如果上级目录不存在会自动创建，没有默认值。</p><p><append>默认 true，日志被追加到文件结尾，如果是 false，服务重启后清空现存文件。</p><pre><code class="xml">&lt;!-- 文件日志：可以将日志打印在文件中 --&gt;&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;    &lt;file&gt;${log.path}/log.log&lt;/file&gt;    &lt;append&gt;true&lt;/append&gt;    &lt;encoder&gt;        &lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt;        &lt;charset&gt;${ENCODING}&lt;/charset&gt;    &lt;/encoder&gt;&lt;/appender&gt;</code></pre><h3 id="5-logger"><a href="#5-logger" class="headerlink" title="5. logger"></a>5. logger</h3><p><strong>日志记录器</strong>，或者叫日志打印器</p><p>用来设置某一个包或具体某一个类的日志打印级别、指定<appender></p><p>name：用来指定受此logger约束的某一个包或者具体的某一个类</p><p>level：用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF。默认继承上级的级别</p><p><logger>可以包含零个或多个<appender-ref>元素，标识这个appender将会添加到这个 logger</p><pre><code class="xml">&lt;!-- 日志记录器  --&gt;&lt;logger name=&quot;com.atguigu&quot; level=&quot;INFO&quot;&gt;    &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;    &lt;appender-ref ref=&quot;FILE&quot; /&gt;&lt;/logger&gt;</code></pre><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><p>测试日志记录的控制台输出、文件输出、以及日志级别</p><h4 id="控制台日志结果"><a href="#控制台日志结果" class="headerlink" title="控制台日志结果"></a>控制台日志结果</h4><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/ConsoleLog.png" srcset="/img/loading.gif" alt="控制台日志"></p><h4 id="文件中的日志"><a href="#文件中的日志" class="headerlink" title="文件中的日志"></a>文件中的日志</h4><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/FileLog.png" srcset="/img/loading.gif" alt="文件中的日志"></p><h2 id="三、滚动日志"><a href="#三、滚动日志" class="headerlink" title="三、滚动日志"></a>三、滚动日志</h2><p>生产环境下，如果系统长时间运行，那么日志文件会变得越来越大，系统读取和写入日志的时间会越来越慢，严重的情况会耗尽系统内存，导致系统宕机。</p><p>这个时候我们就可以设置 <strong>滚动日志</strong>。</p><h3 id="1-设置-RollingFileAppender"><a href="#1-设置-RollingFileAppender" class="headerlink" title="1. 设置 RollingFileAppender"></a>1. 设置 RollingFileAppender</h3><pre><code class="xml">&lt;appender name=&quot;ROLLING_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;    &lt;!--  要区别于其他的appender中的文件名字  --&gt;    &lt;file&gt;${log.path}/log-rolling.log&lt;/file&gt;    &lt;encoder&gt;        &lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt;        &lt;charset&gt;${ENCODING}&lt;/charset&gt;    &lt;/encoder&gt;    &lt;!-- 设置滚动日志记录的滚动策略 --&gt;    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;        &lt;!-- 日志归档路径以及格式 --&gt;        &lt;fileNamePattern&gt;${log.path}/info/log-rolling-%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;    &lt;/rollingPolicy&gt;&lt;/appender&gt;</code></pre><h3 id="2-设置触发滚动时机"><a href="#2-设置触发滚动时机" class="headerlink" title="2. 设置触发滚动时机"></a>2. 设置触发滚动时机</h3><p>放在<rollingPolicy>的子节点的位置，基于实践策略的触发滚动策略</p><p><maxFileSize>设置触发滚动条件：单个文件大于100M时生成新的文件</p><p><strong>注意：修改日志文件名</strong> 此时 <fileNamePattern>${log.path}/info/log-rolling-%d{yyyy-MM-dd}<strong>.%i</strong>.log</fileNamePattern></p><pre><code class="xml">&lt;!-- 如果日志大小超过 1KB 就生成新日志 --&gt;&lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;    &lt;maxFileSize&gt;1KB&lt;/maxFileSize&gt;&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</code></pre><h3 id="3-结果"><a href="#3-结果" class="headerlink" title="3. 结果"></a>3. 结果</h3><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/Srb/main/doc/img/01/RollingLog.png" srcset="/img/loading.gif" alt="滚动日志"></p><h2 id="四、完整的日志配置文件"><a href="#四、完整的日志配置文件" class="headerlink" title="四、完整的日志配置文件"></a>四、完整的日志配置文件</h2><p>一般开发的时候不会使用日志配置，一般会等项目上线后才设置。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;contextName&gt;Srb&lt;/contextName&gt;    &lt;!-- 日志的输出目录 --&gt;    &lt;property name=&quot;log.path&quot; value=&quot;E:/WorkSpace/log/srb&quot;/&gt;    &lt;!--控制台日志格式：彩色日志--&gt;    &lt;!-- magenta:洋红 --&gt;    &lt;!-- boldMagenta:粗红--&gt;    &lt;!-- cyan:青色 --&gt;    &lt;!-- white:白色 --&gt;    &lt;!-- magenta:洋红 --&gt;    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;              value=&quot;%yellow(%date{yyyy-MM-dd HH:mm:ss}) %highlight([%-5level]) %green(%logger) %msg%n&quot;/&gt;    &lt;!--文件日志格式--&gt;    &lt;property name=&quot;FILE_LOG_PATTERN&quot;              value=&quot;%date{yyyy-MM-dd HH:mm:ss} [%-5level] %thread %file:%line %logger %msg%n&quot; /&gt;    &lt;!--编码--&gt;    &lt;property name=&quot;ENCODING&quot; value=&quot;UTF-8&quot; /&gt;    &lt;!-- 控制台日志：将日志打印在控制台中 --&gt;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt;            &lt;charset&gt;${ENCODING}&lt;/charset&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!-- 文件日志：可以将日志打印在文件中 --&gt;    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;        &lt;file&gt;${log.path}/log.log&lt;/file&gt;        &lt;append&gt;true&lt;/append&gt;        &lt;encoder&gt;            &lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt;            &lt;charset&gt;${ENCODING}&lt;/charset&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!-- 滚动日志 --&gt;    &lt;appender name=&quot;ROLLING_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!--  要区别于其他的appender中的文件名字  --&gt;        &lt;file&gt;${log.path}/log-rolling.log&lt;/file&gt;        &lt;encoder&gt;            &lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt;            &lt;charset&gt;${ENCODING}&lt;/charset&gt;        &lt;/encoder&gt;        &lt;!-- 设置滚动日志记录的滚动策略 --&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!-- 日志归档路径以及格式: log-rolling-2022-01-22.1.log --&gt;            &lt;fileNamePattern&gt;${log.path}/info/log-rolling-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;            &lt;!--归档日志文件保留的最大数量--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;1KB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;/rollingPolicy&gt;    &lt;/appender&gt;    &lt;!-- 日志记录器 如果需要打印 Mybatis SQL 就需要将级别调整为 DEBUG, 将 namde 的值设置为 mapper 目录 --&gt;    &lt;logger name=&quot;com.frankeleyn&quot; level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;        &lt;appender-ref ref=&quot;FILE&quot; /&gt;        &lt;appender-ref ref=&quot;ROLLING_FILE&quot; /&gt;    &lt;/logger&gt;&lt;/configuration&gt;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Srb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Srb(一):项目介绍</title>
    <link href="undefined2022/01/22/Srb-1-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    <url>2022/01/22/Srb-1-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Srb-一-项目介绍"><a href="#Srb-一-项目介绍" class="headerlink" title="Srb (一): 项目介绍"></a>Srb (一): 项目介绍</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p><strong>尚融宝</strong> ( Srb ) 是一个用来学习的前后端分离 P2P 金融项目</p><p>项目从0到1全过程都会写在博客中</p><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p><img src="https://s2.loli.net/2022/01/22/P9IkmlXJwjzu6e1.png" srcset="/img/loading.gif" alt="SrbArchiteture.png"></p><h2 id="项目开发环境"><a href="#项目开发环境" class="headerlink" title="项目开发环境"></a>项目开发环境</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul><li><p>jdk1.8</p></li><li><p>maven</p></li><li><p>idea</p></li></ul><h3 id="后台技术栈"><a href="#后台技术栈" class="headerlink" title="后台技术栈"></a>后台技术栈</h3><p>Spring Boot</p><p>Spring Cloud</p><p>Mybatis Plus：持久层框架</p><p>Lombok：简化代码</p><p>Swagger2：自动生成 Api 接口工具</p><p>Logback：日志</p><p>alibaba-easyexcel：Excel 读写</p><p>Spring Data Redis：访问 Redis</p><p>HttpClient：基于 Http 协议的客户端，可发送 Http 请求</p><p>Spring Task： 定时任务</p><h3 id="数据库和中间件"><a href="#数据库和中间件" class="headerlink" title="数据库和中间件"></a>数据库和中间件</h3><p>MySql 5.7：关系型数据库</p><p>Redis：内存数据库</p><p>RabbitMQ：消息中间件</p><h3 id="第三方接口"><a href="#第三方接口" class="headerlink" title="第三方接口"></a>第三方接口</h3><p>阿里云短信</p><p>阿里云 OSS</p><p>资金托管平台 API 对接 汇付宝</p><h3 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h3><p>Node.js： JavaScript 运行环境</p><p>ES6：JavaScript的模块化版本</p><p>axios：一个发送Ajax请求的工具</p><p>Vue.js：web 界面的渐进式框架</p><p>Element-UI：前端组件库</p><p>模块化开发：解决javascript变量全局空间污染的问题</p><p>NPM：模块资源管理器</p><p>vue-element-admin：基于Vue.js的后台管理系统UI集成方案</p><p>NuxtJS：基于Vue.js构建的服务器端渲染应用的轻量级框架</p>]]></content>
    
    
    
    <tags>
      
      <tag>Srb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Router</title>
    <link href="undefined2022/01/21/Vue%20Router/"/>
    <url>2022/01/21/Vue%20Router/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/FrontEnd-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Vue.js 路由允许我们通过锚点定义不同的 URL， 达到访问不同的页面的目的，每个页面的内容通过延迟加载渲染出来。</p><p>通过 Vue.js 可以实现多视图的<strong>单页Web应用</strong>（single page web application，SPA）</p><h2 id="二、路由案例"><a href="#二、路由案例" class="headerlink" title="二、路由案例"></a>二、路由案例</h2><h3 id="1-创建文件夹和文件"><a href="#1-创建文件夹和文件" class="headerlink" title="1. 创建文件夹和文件"></a>1. 创建文件夹和文件</h3><p>创建文件夹 <strong>07-router</strong>，创建 <strong>index.html</strong></p><h3 id="2-引入-js"><a href="#2-引入-js" class="headerlink" title="2. 引入 js"></a>2. 引入 js</h3><pre><code class="html">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;vue-router.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="3-编写-html"><a href="#3-编写-html" class="headerlink" title="3. 编写 html"></a>3. 编写 html</h3><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;h1&gt;Hello Vue Router!&lt;/h1&gt;        &lt;p&gt;            &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;            &lt;!-- 通过传入 `to` 属性指定链接. --&gt;            &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;            &lt;router-link to=&quot;/equip&quot;&gt;装备列表&lt;/router-link&gt;            &lt;router-link to=&quot;/heor&quot;&gt;英雄列表&lt;/router-link&gt;        &lt;/p&gt;        &lt;!-- 路由出口 --&gt;        &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="4-编写-js"><a href="#4-编写-js" class="headerlink" title="4. 编写 js"></a>4. 编写 js</h3><pre><code class="html">&lt;script&gt;    // 1. 定义路由组件    const welcome = { template: &quot;&lt;div&gt;英雄联盟首页&lt;/div&gt;&quot; }    const equip = { template: &quot;&lt;div&gt;装备列表&lt;div&gt;&quot; }    const hero = {template: &quot;&lt;div&gt;英雄列表&lt;/div&gt;&quot; }    // 2. 定义路由集合    const routes = [        { path: &#39;/&#39;, redirect: &#39;/welcome&#39; }, // 默认的欢迎页面        { path: &#39;/welcome&#39;, component: welcome },        { path: &#39;/equip&#39;, component: equip },        { path: &#39;/hero&#39;, component: hero }    ]    // 3. 创建 router 实例，传入组件    const router = new VueRouter({        routes // 缩写，相当于 routes: routes    })    // 4. 加载 vue-router    new Vue({        el: &quot;#app&quot;,        data: {},        router    })&lt;/script&gt;</code></pre><h3 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5. 运行结果"></a>5. 运行结果</h3><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/v-router.png" srcset="/img/loading.gif" alt="router"></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端技术</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue UI 组件库</title>
    <link href="undefined2022/01/21/Vue%20UI/"/>
    <url>2022/01/21/Vue%20UI/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-UI-组件库"><a href="#Vue-UI-组件库" class="headerlink" title="Vue UI 组件库"></a>Vue UI 组件库</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/FrontEnd-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、常见组件库"><a href="#一、常见组件库" class="headerlink" title="一、常见组件库"></a>一、常见组件库</h2><h3 id="1、Mint-UI"><a href="#1、Mint-UI" class="headerlink" title="1、Mint UI"></a>1、Mint UI</h3><p>主页：<a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">http://mint-ui.github.io/#!/zh-cn</a></p><p>说明：饿了么开源的基于Vue的移动端UI组件库</p><h3 id="2、Element-UI"><a href="#2、Element-UI" class="headerlink" title="2、Element-UI"></a>2、Element-UI</h3><p>主页：<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a></p><p>说明：饿了么开源的基于Vue的PC端UI组件库</p><h2 id="二、Element-UI-案例"><a href="#二、Element-UI-案例" class="headerlink" title="二、Element-UI 案例"></a>二、Element-UI 案例</h2><p>创建文件夹 <strong>06-ui</strong>，创建 <strong>01-demo.html</strong></p><h3 id="1-引入脚本"><a href="#1-引入脚本" class="headerlink" title="1. 引入脚本"></a>1. 引入脚本</h3><pre><code class="html">    &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;axios.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot; /&gt;    &lt;!-- 引入组件库 --&gt;    &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="2-渲染数据"><a href="#2-渲染数据" class="headerlink" title="2. 渲染数据"></a>2. 渲染数据</h3><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;el-table :data=&quot;users&quot; stripe border style=&quot;width: 100%&quot; &gt;                &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot;&gt;&lt;/el-table-column&gt;                &lt;el-table-column prop=&quot;age&quot; label=&quot;年龄&quot;&gt;&lt;/el-table-column&gt;                &lt;el-table-column prop=&quot;skill&quot; label=&quot;技能&quot;&gt;&lt;/el-table-column&gt;        &lt;/el-table&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    new Vue({        el: &quot;#app&quot;,        data: {            users: [                { name: &quot;亚索&quot;, age: 28, skill: &quot;狂风绝息斩&quot; },                { name: &quot;永恩&quot;, age: 29, skill: &quot;封尘绝念斩&quot; }            ]        }    })&lt;/script&gt;</code></pre><h3 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3.运行结果"></a>3.运行结果</h3><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/v-ui.png" srcset="/img/loading.gif" alt="v-ui"></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端技术</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="undefined2022/01/21/Vue/"/>
    <url>2022/01/21/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/FrontEnd-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、 简介"></a>一、 简介</h2><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a> 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。</p><h2 id="二、起步"><a href="#二、起步" class="headerlink" title="二、起步"></a>二、起步</h2><p>创建文件夹 <strong>05-vue</strong>，复制 <strong>vue.js</strong>，创建 <strong>01-hello.html</strong></p><h3 id="1-引入脚本"><a href="#1-引入脚本" class="headerlink" title="1. 引入脚本"></a>1. 引入脚本</h3><p>去网上下载一个 <strong>vue.js</strong>，放入 <strong>05-vue</strong> 目录下，引入</p><pre><code class="js">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="2-数据绑定"><a href="#2-数据绑定" class="headerlink" title="2. 数据绑定"></a>2. 数据绑定</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;hello&lt;/title&gt;    &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;!-- 插值表达式，绑定 vue 中的 data 数据 --&gt;        {{message}}    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    new Vue({        // 选择器，选定绑定范围        el : &#39;#app&#39;,        data : {            // 注册一个数据对象，用于视图中的数据绑定            &quot;message&quot; : &quot;Hello Vue&quot;        }    })&lt;/script&gt;&lt;/html&gt;</code></pre><p><strong>声明式渲染：</strong>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统</p><pre><code class="json">data: {    message: &#39;Hello Vue!&#39;}</code></pre><h2 id="三、数据绑定"><a href="#三、数据绑定" class="headerlink" title="三、数据绑定"></a>三、数据绑定</h2><h3 id="1-单向绑定"><a href="#1-单向绑定" class="headerlink" title="1. 单向绑定"></a>1. 单向绑定</h3><p><strong>①</strong> 创建 <strong>02-bind.html</strong></p><p><strong>②</strong> 引入脚本，创建 Vue 对象</p><pre><code class="html">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    new Vue({    el: &#39;#app&#39;,    data: {        company: &#39;尚硅谷&#39;,        site: &#39;http://www.atguigu.com&#39;    }})&lt;/script&gt;</code></pre><p><strong>③</strong> 使用数据绑定渲染</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;a v-bind:href=&quot;site&quot; target=&quot;_blank&quot;&gt;{{company}}&lt;/a&gt;    &lt;input type=&quot;text&quot; v-bind:value=&quot;company&quot;&gt;&lt;/div&gt;</code></pre><p><strong>v-bind</strong> 简写：</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;a :href=&quot;site&quot; target=&quot;_blank&quot;&gt;{{company}}&lt;/a&gt;    &lt;input type=&quot;text&quot; :value=&quot;company&quot;&gt;&lt;/div&gt;</code></pre><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/V-vbind.png" srcset="/img/loading.gif" alt="v-bind"></p><h3 id="2-双向绑定"><a href="#2-双向绑定" class="headerlink" title="2. 双向绑定"></a>2. 双向绑定</h3><p><strong>①</strong> 创建 <strong>03-model.html</strong></p><p><strong>②</strong> 复制 02 的代码重命名为 03</p><p><strong>③</strong> 将 <strong>v-bind:value</strong> 改为 <strong>v-model</strong></p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;a :href=&quot;site&quot; target=&quot;_blank&quot;&gt;{{company}}&lt;/a&gt;    &lt;input type=&quot;text&quot; v-model=&quot;company&quot;&gt;&lt;/div&gt;</code></pre><p>双向数据绑定的作用</p><ul><li><p>当数据发生变化的时候，视图也会跟着发生变化</p><p>数据模型发生了改变，会直接显示在页面上</p></li><li><p>当视图发生变化的时候，数据也会跟着同步变化</p><p>用户在页面上的修改，会自动同步到数据模型中去</p></li></ul><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/V-vmodel.png" srcset="/img/loading.gif" alt="v-model"></p><p>当我在 2 的文本框修改值的时候，1 也会变成和 2 一样的值，而单向绑定就不会有这个效果。</p><h2 id="四、绑定事件监听"><a href="#四、绑定事件监听" class="headerlink" title="四、绑定事件监听"></a>四、绑定事件监听</h2><p>创建 <strong>04-event.html</strong></p><p>使用 <strong>v-on</strong> 进行事件绑定，<strong>v-on:click</strong> 表示处理鼠标点击事件，事件调用的方法定义在 vue 对象声明的 <strong>methods</strong> 节点中</p><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;button v-on:click=&quot;play&quot;&gt;玩游戏&lt;/button&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    new Vue({        el : &quot;#app&quot;,        data : {            game : &quot;英雄联盟&quot;        },        methods: {            play() {                alert(&#39;我要玩 &#39; + this.game)            }        }    })&lt;/script&gt;</code></pre><p>v-on 指令的可简写：</p><pre><code class="html">&lt;button @click=&quot;play&quot;&gt;玩游戏&lt;/button&gt;</code></pre><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/V-on.png" srcset="/img/loading.gif" alt="v-on"></p><h2 id="五、计算属性"><a href="#五、计算属性" class="headerlink" title="五、计算属性"></a>五、计算属性</h2><p>在实现具体值的时候对该值需要计算的属性叫做 <strong>计算属性</strong>。</p><p>创建 <strong>05-calcul.html</strong></p><h3 id="1-模板中使用-js-表达式"><a href="#1-模板中使用-js-表达式" class="headerlink" title="1. 模板中使用 js 表达式"></a>1. 模板中使用 js 表达式</h3><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;p&gt;原始值：{{message}}&lt;/p&gt;        &lt;p&gt;反转：{{message.split('').reverse().join('')}}&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    new Vue({        el : &quot;#app&quot;,        data : {           &quot;message&quot; : &quot;hello&quot;        }    })&lt;/script&gt;</code></pre><p>模板表达式非常便利，但是设计它们的初衷是用于简单运算的，复杂的逻辑不太适合放在这里，这时候就需要用到 <strong>计算属性</strong>。</p><h3 id="2-计算属性"><a href="#2-计算属性" class="headerlink" title="2. 计算属性"></a>2. 计算属性</h3><p>计算属性，就是<strong>有计算方法的属性</strong>。</p><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;p&gt;原始值：{{message}}&lt;/p&gt;        &lt;p&gt;反转：{{reversedMessage}}&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    new Vue({        el : &quot;#app&quot;,        data : {           &quot;message&quot; : &quot;hello&quot;        },        computed: {            reversedMessage () {                console.log(&#39;计算属性&#39;)                return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)            }        }    })&lt;/script&gt;</code></pre><h3 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h3><pre><code class="json">methods:{    reversed () {        console.log(&#39;方法执行&#39;)        return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)    }}</code></pre><pre><code class="html">&lt;!-- 调用方法 --&gt;&lt;p&gt;反转：{{reversed()}}&lt;/p&gt;</code></pre><h3 id="计算属性和方法的区别"><a href="#计算属性和方法的区别" class="headerlink" title="计算属性和方法的区别"></a>计算属性和方法的区别</h3><ul><li><h5 id="计算属性基于缓存"><a href="#计算属性基于缓存" class="headerlink" title="计算属性基于缓存"></a>计算属性基于缓存</h5></li><li><h5 id="方法总会再次执行"><a href="#方法总会再次执行" class="headerlink" title="方法总会再次执行"></a>方法总会再次执行</h5></li></ul><p>普通方法是一个操作手册，相当于一个说明书</p><p>计算属性是针对内存的一次运算，是内存结果出现之前所插入的一段代码</p><pre><code class="html">&lt;!-- 2、使用计算属性 --&gt;&lt;p&gt;反转消息: {{ reversedMessage }}&lt;/p&gt;&lt;!-- 调用两次只执行一次属性的计算 --&gt;&lt;p&gt;反转消息: {{ reversedMessage }}&lt;/p&gt;&lt;!-- 3、使用方法 --&gt;&lt;p&gt;反转消息: {{ reversed() }}&lt;/p&gt;&lt;!-- 调用两次执行了两次属性的计算 --&gt;&lt;p&gt;反转消息: {{ reversed() }}&lt;/p&gt;</code></pre><h3 id="计算属性的案例"><a href="#计算属性的案例" class="headerlink" title="计算属性的案例"></a>计算属性的案例</h3><p>创建 <strong>06-full-name.html</strong></p><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        姓: &lt;input placeholder=&quot;First Name&quot; v-model=&quot;firstName&quot; /&gt;&lt;br /&gt;        名: &lt;input placeholder=&quot;Last Name&quot; v-model=&quot;lastName&quot; /&gt;&lt;br /&gt;        姓名1(单向): &lt;input placeholder=&quot;Full Name1&quot; v-model=&quot;fullName1&quot; /&gt;&lt;br /&gt;        姓名2(双向): &lt;input placeholder=&quot;Full Name2&quot; v-model=&quot;fullName2&quot; /&gt;&lt;br /&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&#39;vue.js&#39;&gt;&lt;/script&gt;&lt;script&gt;    new Vue({        el : &#39;#app&#39;,        data : {            &quot;firstName&quot; : &quot;Benjamin&quot;,            &quot;lastName&quot; : &quot;Franklin&quot;        },        computed: {            fullName1() {                console.log(&#39;计算 fullName1&#39;);                return this.firstName + this.lastName            },            fullName2: {                get() {                        console.log(&#39;计算fullName2&#39;)                        return this.firstName + &#39; &#39; + this.lastName                },                set(value) {                    console.log(&#39;fullName2 的 setter&#39;)                    const names = value.split(&#39; &#39;)                    this.firstName = names[0]                    this.lastName = names[1]                }            }        }    })&lt;/script&gt;</code></pre><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/full-name.png" srcset="/img/loading.gif" alt="full-name"></p><h2 id="六、条件渲染"><a href="#六、条件渲染" class="headerlink" title="六、条件渲染"></a>六、条件渲染</h2><p>创建 <strong>07-if.html</strong></p><p>点击复选框，显示或隐藏协议内容。分别使用 <strong>v-if</strong> 和 <strong>v-show</strong> 实现</p><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;input type=&quot;checkbox&quot; v-model=&quot;status&quot;&gt;&lt;br&gt;        &lt;!-- v-if 实现 --&gt;        &lt;p v-if=&quot;status&quot;&gt;显示&lt;/p&gt;        &lt;p v-else&gt;不显示&lt;/p&gt;        &lt;!-- v-show 实现 --&gt;        &lt;p v-show=&quot;status&quot;&gt;显示&lt;/p&gt;        &lt;p v-show=&quot;!status&quot;&gt;不显示&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    new Vue({        el : &quot;#app&quot;,        data : {            &quot;status&quot; : false        }    })&lt;/script&gt;</code></pre><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/v-if-f.png" srcset="/img/loading.gif" alt="false"></p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/v-if-t.png" srcset="/img/loading.gif" alt="true"></p><h2 id="七、列表渲染"><a href="#七、列表渲染" class="headerlink" title="七、列表渲染"></a>七、列表渲染</h2><p>创建 <strong>08-for.html</strong></p><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(item, index) in users&quot;&gt;                {{index + 1}}   姓名: {{item.name}}  年龄: {{item.age}}   技能: {{item.skill}}            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    new Vue({        el : &quot;#app&quot;,        data : {            users : [                {name : &quot;亚索&quot;, age : 28, skill : &quot;狂风绝息斩&quot;},                {name : &quot;永恩&quot;, age : 29, skill : &quot;封尘绝念斩&quot;}            ]        }    })&lt;/script&gt;</code></pre><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/v-for.png" srcset="/img/loading.gif" alt="v-for"></p><h2 id="八、生命周期"><a href="#八、生命周期" class="headerlink" title="八、生命周期"></a>八、生命周期</h2><p>创建 <strong>09-period.html</strong></p><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;h2 id=&quot;h2&quot;&gt;{{message}}&lt;/h2&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    new Vue({        el : &quot;#app&quot;,        data : {            &quot;message&quot; : &quot;谦逊薄弱，就是见识薄弱&quot;        },        methods: {            show() {                console.log(&quot;show() 函数被调用&quot;);            }        },        created() {            console.log(&quot;created 钩子函数调用&quot;);            // 可以操作 data 中的数据            console.log(this.message);            // 可以调用 methods 中的方法            this.show();             // 但是获取不了 dom 节点，因为此时 vue 还没开始渲染                    console.log(&quot;获取 dom &quot; + document.getElementById(&quot;h2&quot;).innerText);        },        mounted() {            console.log(&quot;mounted 钩子函数被调用&quot;);            // 此时 vue 已经渲染好了数据，可以获取 dom 节点            console.log(&quot;获取 dom &quot; + document.getElementById(&quot;h2&quot;).innerText);        }    })&lt;/script&gt;</code></pre><p>执行结果：<br><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/v-period.png" srcset="/img/loading.gif" alt="period"></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端技术</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="undefined2022/01/20/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>2022/01/20/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>js 的模块化就像封装 java 框架一样，在 js 封装的过程叫 <strong>模块化</strong>。</p><h3 id="1-案例"><a href="#1-案例" class="headerlink" title="1. 案例"></a>1. 案例</h3><p>① 创建 <strong>04-module-demo</strong> 目录，创建 <strong>no-module</strong> 目录，创建 <strong>a.js</strong></p><pre><code class="js">let name = &#39;奥巴马&#39;</code></pre><p>② 创建 <strong>b.js</strong></p><pre><code class="js">let name = &#39;暴暴&#39;</code></pre><p>③ 创建 <strong>demo.html</strong></p><p>从这个例子可以看出，<strong>name</strong> 的值的不确定性很大，a和b两个 js 文件中的同名变量互相干扰。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&#39;a.js&#39;&gt;&lt;/script&gt;    &lt;script src=&#39;b.js&#39;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;    console.log(name);&lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="二、模块化规范"><a href="#二、模块化规范" class="headerlink" title="二、模块化规范"></a>二、模块化规范</h2><h3 id="1-导出模块"><a href="#1-导出模块" class="headerlink" title="1. 导出模块"></a>1. 导出模块</h3><p>创建 <strong>module</strong> 目录，创建 <strong>m1.js</strong></p><pre><code class="js">export let name = &#39;亚索&#39;export function r() {    console.log(&quot;狂风绝息斩&quot;);}</code></pre><p>创建 <strong>m2.js</strong></p><pre><code class="js">export let name = &#39;永恩&#39;export function r() {    console.log(&#39;封尘绝念斩&#39;);}// 或者这样导出export let name = &#39;永恩&#39;export function r() {    console.log(&#39;封尘绝念斩&#39;);}export {star, sing}</code></pre><h3 id="2-导入模块"><a href="#2-导入模块" class="headerlink" title="2. 导入模块"></a>2. 导入模块</h3><p>创建 <strong>demo.html</strong></p><pre><code class="html">&lt;body&gt;    &lt;h1&gt;模块化测试&lt;/h1&gt;&lt;/body&gt;&lt;script type=&#39;module&#39;&gt;    import * as m1 from &#39;./m1.js&#39;    import * as m2 from &#39;./m2.js&#39;    console.log(m1.name);    m1.r()    console.log(m2.name);    m2.r()    //还可以这样导入：解构赋值的形式    import {name, r} from &#39;./m1.js&#39;    import {name as name2} from &#39;./m2.js&#39; //使用as防止重名    console.log(name)    r()    console.log(name2)&lt;/script&gt;</code></pre><h2 id="三、默认暴露模块"><a href="#三、默认暴露模块" class="headerlink" title="三、默认暴露模块"></a>三、默认暴露模块</h2><h3 id="1-默认暴露"><a href="#1-默认暴露" class="headerlink" title="1. 默认暴露"></a>1. 默认暴露</h3><p>创建 <strong>m3.js</strong></p><pre><code class="js">export default{    username : &#39;奥巴马&#39;,    age : 25,    r() {        console.log(&quot;圣枪洗礼&quot;);    }}</code></pre><h3 id="2-导入模块-1"><a href="#2-导入模块-1" class="headerlink" title="2. 导入模块"></a>2. 导入模块</h3><p>在 <strong>demo.html</strong> 中导入模块</p><pre><code class="js">//导入m3import m3 from &#39;./m3.js&#39;console.log(m3)</code></pre><h2 id="四、封装代码"><a href="#四、封装代码" class="headerlink" title="四、封装代码"></a>四、封装代码</h2><h3 id="1-创建-app-js"><a href="#1-创建-app-js" class="headerlink" title="1. 创建 app.js"></a>1. 创建 app.js</h3><pre><code class="js">import * as m1 from &#39;./m1.js&#39;import * as m2 from &#39;./m2.js&#39;import m3 from &#39;./m3.js&#39;m1.r()m2.r()m3.r()</code></pre><h3 id="2-引入-app-js"><a href="#2-引入-app-js" class="headerlink" title="2. 引入 app.js"></a>2. 引入 app.js</h3><p>创建 <strong>demo-app.html</strong>，引入 <strong>app.js</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&#39;m1.js&#39;&gt;&lt;/script&gt;    &lt;script src=&#39;m2.js&#39;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;模块化测试&lt;/h1&gt;&lt;/body&gt;&lt;script type=&#39;module&#39; src=&#39;./app.js&#39;&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><p>运行结果：</p><pre><code class="tex">狂风绝息斩封尘绝念斩圣枪洗礼</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios</title>
    <link href="undefined2022/01/20/Axios/"/>
    <url>2022/01/20/Axios/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/FrontEnd-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、Axios-入门"><a href="#一、Axios-入门" class="headerlink" title="一、Axios 入门"></a>一、Axios 入门</h2><h3 id="1-Axios-的-作用"><a href="#1-Axios-的-作用" class="headerlink" title="1. Axios 的 作用"></a>1. Axios 的 作用</h3><p><a href="http://www.axios-js.com" target="_blank" rel="noopener">Axios</a> 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><h3 id="2-入门案例"><a href="#2-入门案例" class="headerlink" title="2. 入门案例"></a>2. 入门案例</h3><h5 id="①-添加后端接口"><a href="#①-添加后端接口" class="headerlink" title="① 添加后端接口"></a>① 添加后端接口</h5><p>自己建一个可以返回 json 数据的 SpringBoot 项目，指定端口号和地址。</p><p>比如，我的地址是：<a href="http://localhost:8082/user/list" target="_blank" rel="noopener">http://localhost:8082/user/list</a></p><h5 id="②-创建文件夹"><a href="#②-创建文件夹" class="headerlink" title="② 创建文件夹"></a>② 创建文件夹</h5><p>创建 <strong>03-axios-demo</strong> 文件夹</p><h5 id="③-引入-axios-js"><a href="#③-引入-axios-js" class="headerlink" title="③ 引入 axios.js"></a>③ 引入 axios.js</h5><p>将 <strong>axios.js</strong> 引入 <strong>03-axios-demo</strong> 文件夹</p><h5 id="④-测试"><a href="#④-测试" class="headerlink" title="④ 测试"></a>④ 测试</h5><p>创建 <strong>index.html</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;axios 案例&lt;/title&gt;    &lt;script src=&quot;axios.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Axios 案例&lt;/h1&gt;&lt;/body&gt;&lt;script&gt;    // 普通写法    axios({        method: &#39;get&#39;,        url: &#39;http://localhost:8082/user/list&#39;,    })    .then((response) =&gt; {        console.log(&#39;获取数据成功&#39;, response)    })    .catch((error) =&gt; {        console.log(&#39;获取数据失败&#39;, error)    })    // ES6 写法    axios.get(&#39;http://localhost:8082/user/list&#39;)         .then(res =&gt; {            console.log(&#39;获取数据成功：&#39; + res);         })         .catch(error =&gt; {            console.log(&#39;获取数据失败：&#39; + error);         })&lt;/script&gt;&lt;/html&gt;</code></pre><h5 id="⑤-运行"><a href="#⑤-运行" class="headerlink" title="⑤ 运行"></a>⑤ 运行</h5><p>使用 <strong>Open with Live Server</strong>  运行(需要安装 Live Server 插件)，这样使用的就是 node 服务器运行的前端项目。</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/A-1-2-5-1.png" srcset="/img/loading.gif" alt="运行"></p><p>运行之后你就发现，报错了，因为没有<strong>设置跨域</strong> (下文介绍跨域)</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/A-1-2-5-2.png" srcset="/img/loading.gif" alt="跨域失败"></p><h2 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h2><h3 id="1-为什么出现跨域"><a href="#1-为什么出现跨域" class="headerlink" title="1. 为什么出现跨域"></a>1. 为什么出现跨域</h3><p><strong>跨域</strong> 是因为浏览器的<strong>同源策略</strong>限制所导致的。</p><p><strong>同源</strong>（即指在同一个域）就是两个地址具有相同的协议（protocol）、主机（host）和端口号（port）</p><p>以下情况都属于跨域：</p><table><thead><tr><th align="left"><strong>跨域原因</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">域名不同</td><td>jd.com 和 taobao.com</td></tr><tr><td align="left">端口不同</td><td><a href="http://www.qq.com:81" target="_blank" rel="noopener">www.qq.com:81</a> 和 <a href="http://www.qq.com:82" target="_blank" rel="noopener">www.qq.com:82</a></td></tr></tbody></table><p>http和https也属于跨域。</p><p><strong>同源策略会阻止一个域的 javascript 脚本和另外一个域的内容进行交互</strong>。</p><p>我们是从 localhost:5500 端口去访问 localhost:8082 端口，这属于端口不同，跨域了。</p><h3 id="2-解决跨域"><a href="#2-解决跨域" class="headerlink" title="2. 解决跨域"></a>2. 解决跨域</h3><p>① JsonP，利用 js 标签的一个漏洞</p><p>② Nginx 反向代理，请求转发，将不跨域的请求转发到跨域请求上</p><p>③ Cors, Http 允许跨域</p><p>在后台的 controller上添加一个注解 <strong>@CrossOrigin</strong> 就可以了。</p><h2 id="三、自定义配置"><a href="#三、自定义配置" class="headerlink" title="三、自定义配置"></a>三、自定义配置</h2><h3 id="1、配置axios实例"><a href="#1、配置axios实例" class="headerlink" title="1、配置axios实例"></a>1、配置axios实例</h3><p>可以对axios进行配置，简化代码的编写</p><pre><code class="js">// 创建一个 axios 对象const request = axios.create({    baseURL: &#39;http://localhost:8082&#39;, //url前缀    timeout: 1000, //超时时间    headers: {&#39;jsessionid&#39;: &#39;frankeleyn&#39;}})</code></pre><h3 id="2-配置请求参数"><a href="#2-配置请求参数" class="headerlink" title="2. 配置请求参数"></a>2. 配置请求参数</h3><p>远程接口的url地址可以修改成相对路径了</p><pre><code class="js">// 发送 axios 请求request({    method:&#39;get&#39;,    url:&#39;/user/list&#39;}).then(response =&gt; {    console.log(&#39;获取数据成功&#39;, response.data[0].name)}).catch(error =&gt; {    console.log(&#39;获取数据失败&#39;, error)})// es6 写法request.get(&#39;/user/list&#39;)    .then(res =&gt; console.log(&#39;获取数据成功：&#39; + res.data[1].name))    .catch(error =&gt; console.log(&#39;获取数据失败：&#39; + error))</code></pre><h2 id="四、拦截器"><a href="#四、拦截器" class="headerlink" title="四、拦截器"></a>四、拦截器</h2><p>在请求或响应被 then 或 catch 处理前拦截他们。</p><p>在前后端分离的项目中，Session 是不共享的，于是我们就需要在请求到达之前 或 响应之后，拦截请求做一些操作。</p><h3 id="1-请求拦截器"><a href="#1-请求拦截器" class="headerlink" title="1. 请求拦截器"></a>1. 请求拦截器</h3><p>在发送axios请求前，可以拦截请求，对请求做一些处理</p><pre><code class="js">// 开启请求拦截器request.interceptors.request.use(  (config) =&gt; {    // 正常的请求    config.headers.token = &quot;user-frankeleyn&quot;    return config  },  (error) =&gt; {    // 错误的请求    return Promise.reject(error)  })</code></pre><p>发送请求时，就会携带这个你自定义的 token</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/A-4-1.png" srcset="/img/loading.gif" alt="request interceptors"></p><h3 id="2-响应拦截器"><a href="#2-响应拦截器" class="headerlink" title="2. 响应拦截器"></a>2. 响应拦截器</h3><p>在发送完请求，获取到响应后，可以对响应做一些处理，再返回给前端用户</p><pre><code class="js">// 返回结果拦截器request.interceptors.response.use(  (response) =&gt; {    console.log(&#39;返回结果拦截&#39;, response);    return response.data  },  (error) =&gt; {    return Promise.reject(error)  })</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript 6</title>
    <link href="undefined2022/01/20/ES6/"/>
    <url>2022/01/20/ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/FrontEnd-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>ECMA</strong>（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际。</p><p><strong>ECMAScript</strong> 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言，而 <strong>ECMAScript 6</strong> 简称 <strong>ES6</strong>。</p><p>ES6 和 后端的 Java8 的概念类似。</p><h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><p>创建文件夹 <strong>02-es6-demo</strong></p><h3 id="1-let-声明变量"><a href="#1-let-声明变量" class="headerlink" title="1. let 声明变量"></a>1. let 声明变量</h3><p>let 和 var 的区别体现在作用域上。var 的作用域被规定为一个函数作用域，而 let 则被规定为块作用域，块作用域要比函数作用域小一些，但是如果两者既没在函数中，也没在块作用域中定义，那么两者都属于全局作用域。</p><p>他两的用法则是相同的，var 怎么使用，let 就怎么使用。</p><p>创建 <strong>01-let.js</strong></p><pre><code class="js">// 声明变量let alet b,c,dlet e = 1let f = 2, g = &#39;abc&#39;, h = [], i = {}// 域的作用{    var star = 3    console.log(star);}// console.log(star); 报错, star not defined// console.log(song); 报错: cannot access before initializationlet song = &#39;Hey Jude&#39;console.log(song);</code></pre><h3 id="2-const声明常量"><a href="#2-const声明常量" class="headerlink" title="2. const声明常量"></a>2. const声明常量</h3><p>创建 <strong>02-const.js</strong></p><pre><code class="js">// 声明常量const SCHOOL = &#39;清华&#39;console.log(SCHOOL);// 报错，常量不允许修改，下面这段会报错SCHOOL = &#39;北大&#39;console.log(SCHOOL);// 报错，常量必须给初始值const A;// 常量变量不能改，但常量指向的对象和数组可以改，因为内存地址没变更// 如果重新指向内存地址就会报错，比如： TEAM = [&#39;IG&#39;, &#39;FPX&#39;]const TEAM = [&#39;RNG&#39;, &#39;WE&#39;, &#39;EDG&#39;]console.log(TEAM);TEAM.push(&#39;TOP&#39;)console.log(TEAM);</code></pre><h3 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a>3. 模板字符串</h3><p>创建 <strong>03-temStr.js</strong></p><p>模板字符串相当于加强版的字符串，用反引号 `，除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。</p><pre><code class="js">// 变量拼接let name = &#39;撒贝宁&#39;let find = `${name}真帅`console.log(find);</code></pre><h3 id="4-箭头函数"><a href="#4-箭头函数" class="headerlink" title="4. 箭头函数"></a>4. 箭头函数</h3><p>创建 <strong>04-fun.js</strong></p><p>函数式编程，和 java 中的 lambda 差不多</p><pre><code class="java">// 函数alet a = function(n) {    return n + 100;}console.log(a(1));// 用箭头函数简写 函数alet b = n =&gt; n + 100;console.log(b(2));</code></pre><h3 id="5-Promise"><a href="#5-Promise" class="headerlink" title="5. Promise"></a>5. Promise</h3><p>创建 <strong>05-promise.js</strong></p><p>Promise 是ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数， 用来封装异步操作并可以获取其成功或失败的结果。</p><pre><code class="js">// 用 promise 异步读取 file.txtconst { rejects } = require(&#39;assert&#39;)const fs = require(&#39;fs&#39;)// 实例化 Promise 对象：// Promise对象有三个状态：初始化、成功、失败const p = new Promise((resolve, rejects) =&gt; {    fs.readFile(&#39;../file.txt&#39;, (err, data) =&gt; {        // 当文件读取失败时，reject将Promise对象的状态设置为失败，获取 err 的信息        if (err)             reject(err)        // 读取成功        resolve(data)    })})p.then(res =&gt; {    // 打印成功信息    console.log(res.toString());}).catch(error =&gt; {    // 打印错误信息    console.log(error.toString());})</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 入门</title>
    <link href="undefined2022/01/20/Node.js%E5%85%A5%E9%97%A8/"/>
    <url>2022/01/20/Node.js%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-入门"><a href="#Node-js-入门" class="headerlink" title="Node.js 入门"></a>Node.js 入门</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/FrontEnd-demo" target="_blank" rel="noopener">Github</a></p><p>创建文件夹 <strong>01-node-demo</strong></p><h2 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1. Hello World"></a>1. Hello World</h2><p>① 新建一个 <strong>hello-world.js</strong>，输入如下代码：</p><pre><code class="js">console.log(&quot;Hello World!&quot;)</code></pre><p>② 打开 cmd</p><p>进入到程序所在目录，输入</p><pre><code class="bash">node ./hello-world.js</code></pre><p>然后就可以看到执行结果了！</p><h2 id="2-文件读取"><a href="#2-文件读取" class="headerlink" title="2. 文件读取"></a>2. 文件读取</h2><p>① 新建一个 file.txt，放入数据</p><pre><code class="json">{    &quot;name&quot; : &quot;frankeleyn&quot;,    &quot;age&quot; : 21}</code></pre><p>② 创建 <strong>02-read-file.js</strong></p><pre><code class="js">// 引入文件库const fs = require(&#39;fs&#39;)// 读取文件fs.readFile(&quot;./file.txt&quot;, (err, data) =&gt; {    if(err) {        console.log(err);        return;    }    // 打印文件中的数据    console.log(data.toString());})</code></pre><p>③ 运行</p><pre><code class="bash">node ./read-file-02.js</code></pre><h2 id="3-服务器端介绍"><a href="#3-服务器端介绍" class="headerlink" title="3. 服务器端介绍"></a>3. 服务器端介绍</h2><p>① 创建 <strong>03-node-server.js</strong></p><pre><code class="js">// 引入 http 库const http = require(&#39;http&#39;)// 创建一个 http 服务http.createServer((req, res) =&gt; {    console.log(&quot;访问我的 http 服务器&quot;)    // 设置响应状态码和响应头    res.writeHead(200,{&#39;content-type&#39; : &#39;text/html&#39;})    res.end(&#39;&lt;h1&gt;Hello Node Server&lt;/h1&gt;&#39;)}).listen(8088)</code></pre><p>② 运行：</p><pre><code class="bash">node ./node-server-03.js</code></pre><p>之后可以打开浏览器，输入 <strong>localhost:8088</strong>，就能看到结果</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/FrontEnd-demo/main/img/3-1.png" srcset="/img/loading.gif" alt="3-1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端技术</tag>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus(五):条件构造器</title>
    <link href="undefined2022/01/18/MybatisPlus-5-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <url>2022/01/18/MybatisPlus-5-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisPlus-五-条件构造器"><a href="#MybatisPlus-五-条件构造器" class="headerlink" title="MybatisPlus(五):条件构造器"></a>MybatisPlus(五):条件构造器</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/mybaties-plus-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、Wrapper-介绍"><a href="#一、Wrapper-介绍" class="headerlink" title="一、Wrapper 介绍"></a>一、Wrapper 介绍</h2><p><strong>Mybatis-Plus</strong> 提供条件构造器来执行较复杂的查询，条件构造器其实就是 <strong>where</strong> 语句的封装。</p><h3 id="1-Wrapper-家族"><a href="#1-Wrapper-家族" class="headerlink" title="1. Wrapper 家族"></a>1. Wrapper 家族</h3><p> <img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/mybaties-plus-demo/main/img/5-1-1.png" srcset="/img/loading.gif" alt="Wrapper家族"></p><p>Wrapper ： 条件构造抽象类，最顶端父类  </p><p>  AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</p><p>​    QueryWrapper ： 查询条件封装</p><p>​    UpdateWrapper ： Update 条件封装</p><p>  AbstractLambdaWrapper ： 使用Lambda 语法</p><p>​    LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</p><p>​    LambdaUpdateWrapper ： Lambda 更新封装Wrapper</p><h3 id="2-创建测试类"><a href="#2-创建测试类" class="headerlink" title="2. 创建测试类"></a>2. 创建测试类</h3><pre><code class="java">@SpringBootTestpublic class WrapperTest {    @Autowired    private UserMapper userMapper;}</code></pre><h2 id="二、QueryWrapper"><a href="#二、QueryWrapper" class="headerlink" title="二、QueryWrapper"></a>二、QueryWrapper</h2><h3 id="1-查询条件"><a href="#1-查询条件" class="headerlink" title="1. 查询条件"></a>1. 查询条件</h3><p>查询名字中包含 n，年龄大于等于20且小于等于30，email 不为空的用户</p><pre><code class="java">@Testpublic void testWrapper01() {    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper        .like(&quot;name&quot;,&quot;n&quot;)        .between(&quot;age&quot;, 20, 30)        .isNotNull(&quot;email&quot;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);}</code></pre><h3 id="2-排序条件"><a href="#2-排序条件" class="headerlink" title="2. 排序条件"></a>2. 排序条件</h3><p>按年龄降序查询用户，如果年龄相同则按id升序排列</p><pre><code class="java">@Testpublic void testWrapper02() {    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper        .orderByDesc(&quot;age&quot;)        .orderByAsc(&quot;id&quot;);    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);    userList.forEach(System.out::println);}</code></pre><h3 id="3-删除条件"><a href="#3-删除条件" class="headerlink" title="3. 删除条件"></a>3. 删除条件</h3><p>删除 email 为空的所有用户，注意因为前面加了 <strong>@TableLogic</strong>，所以是逻辑删除，不是真的删了那条数据。</p><pre><code class="java">@Testpublic void testWrapper03() {    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.isNull(&quot;email&quot;);    int row = userMapper.delete(queryWrapper);    System.out.println(&quot;删除 &quot; + row + &quot; 条数据&quot;);}</code></pre><h3 id="4-条件的优先级"><a href="#4-条件的优先级" class="headerlink" title="4. 条件的优先级"></a>4. 条件的优先级</h3><p>查询名字中包含n，且（年龄小于18或email为空的用户），并将这些用户的年龄设置为18，邮箱设置为 <strong><a href="mailto:user@github.com">user@github.com</a></strong></p><pre><code class="java">@Testpublic void testWrapper04() {    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.like(&quot;name&quot;, &quot;n&quot;)        .and(i -&gt; i.lt(&quot;age&quot;, 18).or().isNull(&quot;email&quot;));    User user = new User();    user.setAge(18);    user.setEmail(&quot;user@github.com&quot;);    int row = userMapper.update(user, queryWrapper);    System.out.println(row + &quot; 行被修改&quot;);}</code></pre><h3 id="5-select子句"><a href="#5-select子句" class="headerlink" title="5. select子句"></a>5. select子句</h3><p>查询所有用户的用户名和年龄</p><pre><code class="java">@Testpublic void testWrapper05() {    QueryWrapper&lt;User&gt;  queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.select(&quot;name&quot;, &quot;age&quot;);    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);    maps.forEach(System.out::println);}</code></pre><h3 id="6-子查询"><a href="#6-子查询" class="headerlink" title="6. 子查询"></a>6. 子查询</h3><p>查询id不大于3的所有用户的id列表</p><pre><code class="java">@Testpublic void testWrapper06() {    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;);    List&lt;Object&gt; objects = userMapper.selectObjs(queryWrapper);    objects.forEach(System.out::println);}</code></pre><p>上面这个写法容易 sql 注入，可以用别的方式替换</p><pre><code class="java">queryWrapper.lt(&quot;id&quot;, 3);// 或者queryWrapper.in(&quot;id&quot;, 1,2,3);</code></pre><h2 id="三、UpdateWrapper"><a href="#三、UpdateWrapper" class="headerlink" title="三、UpdateWrapper"></a>三、UpdateWrapper</h2><h3 id="7-条件优先级"><a href="#7-条件优先级" class="headerlink" title="7. 条件优先级"></a>7. 条件优先级</h3><p>查询名字中包含n，且（年龄小于18或email为空的用户），并将这些用户的年龄设置为18，邮箱设置为 <strong><a href="mailto:user@github.com">user@github.com</a></strong></p><pre><code class="java">@Testpublic void testWrapper07() {    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    updateWrapper.set(&quot;age&quot;, 18)        .set(&quot;email&quot;, &quot;user@github.com&quot;)        .like(&quot;name&quot;, &quot;n&quot;)        .and(i -&gt; i.lt(&quot;age&quot;, 18).or().isNull(&quot;email&quot;));    //这里必须要创建User对象，否则无法应用自动填充。如果没有自动填充，可以设置为null    User user = new User();    int row = userMapper.update(user, updateWrapper);    System.out.println(row + &quot; 行被修改&quot;);}</code></pre><h2 id="四、Condition"><a href="#四、Condition" class="headerlink" title="四、Condition"></a>四、Condition</h2><h3 id="8-动态组装查询条件"><a href="#8-动态组装查询条件" class="headerlink" title="8. 动态组装查询条件"></a>8. 动态组装查询条件</h3><p>查询名字中包含 n，年龄大于20且小于30的用户，查询条件来源于用户输入，是可选的</p><pre><code class="java">@Testpublic void testWrapper08() {    //定义查询条件，有可能为null（用户未输入）    String name = null;    Integer ageBegin = 20;    Integer ageEnd = 30;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    if(StringUtils.isNotBlank(name)){        queryWrapper.like(&quot;name&quot;,&quot;n&quot;);    }    if(ageBegin != null){        queryWrapper.ge(&quot;age&quot;, ageBegin);    }    if(ageEnd != null){        queryWrapper.le(&quot;age&quot;, ageEnd);    }    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);}</code></pre><p>上面这个写法没有问题，就是代码比较复杂，我们可以使用带 condition 参数的条件方法，简化代码：</p><pre><code class="java">    @Test    public void testWrapper08() {        //定义查询条件，有可能为null（用户未输入）        String name = null;        Integer ageBegin = 20;        Integer ageEnd = 30;        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();        queryWrapper.like(StringUtils.isNotBlank(name), &quot;name&quot;, name)                    .gt(ageBegin != null, &quot;age&quot;, ageBegin)                    .lt(ageEnd != null, &quot;age&quot;, ageEnd);        List&lt;User&gt; users = userMapper.selectList(queryWrapper);        users.forEach(System.out::println);    }</code></pre><h2 id="五、LambaWrapper"><a href="#五、LambaWrapper" class="headerlink" title="五、LambaWrapper"></a>五、LambaWrapper</h2><h3 id="9-Query-组装查询条件"><a href="#9-Query-组装查询条件" class="headerlink" title="9. Query-组装查询条件"></a>9. Query-组装查询条件</h3><p>查询名字中包含 n，年龄大于20且小于30的用户，查询条件来源于用户输入，是可选的</p><pre><code class="java">@Testpublic void testWrapper09() {    //定义查询条件，有可能为null（用户未输入）    String name = null;    Integer ageBegin = 20;    Integer ageEnd = 30;    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.like(StringUtils.isNotBlank(name), User::getName, &quot;n&quot;)        .gt(ageBegin != null, User::getAge, ageBegin)        .lt(ageEnd != null, User::getAge, ageEnd);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);}</code></pre><h3 id="10-Update-条件更新"><a href="#10-Update-条件更新" class="headerlink" title="10. Update-条件更新"></a>10. Update-条件更新</h3><p>查询名字中包含n，且（年龄小于20或email为空的用户），并将这些用户的年龄设置为18，邮箱设置为 <strong><a href="mailto:user@github.com">user@github.com</a></strong></p><pre><code class="java">@Testpublic void testWrapper10() {    LambdaUpdateWrapper&lt;User&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;();    updateWrapper        .set(User::getAge, 20)        .set(User::getEmail, &quot;user@atguigu.com&quot;)        .like(User::getName, &quot;n&quot;)        .and(i -&gt; i.lt(User::getAge, 20).or().isNull(User::getEmail));    int row = userMapper.update(new User(), updateWrapper);    System.out.println(row + &quot; 行被修改&quot;);}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus(四):插件</title>
    <link href="undefined2022/01/18/MybatisPlus-4-%E6%8F%92%E4%BB%B6/"/>
    <url>2022/01/18/MybatisPlus-4-%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisPlus-四-插件"><a href="#MybatisPlus-四-插件" class="headerlink" title="MybatisPlus(四):插件"></a>MybatisPlus(四):插件</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/mybaties-plus-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、分页插件"><a href="#一、分页插件" class="headerlink" title="一、分页插件"></a>一、分页插件</h2><h3 id="1-添加配置类"><a href="#1-添加配置类" class="headerlink" title="1. 添加配置类"></a>1. 添加配置类</h3><pre><code class="java">package com.frankeleyn.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author Frankeleyn * @date 2022/1/17 15:22 */@Configurationpublic class MybatisPlusConfig {    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() {        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        // 将分页插件放入容器        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return interceptor;    }}</code></pre><h3 id="2-测试分页"><a href="#2-测试分页" class="headerlink" title="2. 测试分页"></a>2. 测试分页</h3><p>新建一个测试类 <strong>InterceptorTest</strong></p><pre><code class="java">@SpringBootTestpublic class InterceptorTest {    @Autowired    private UserMapper userMapper;    @Test    public void testFindByPage() {        Page&lt;User&gt; page = new Page&lt;&gt;();        page.setCurrent(2); // 当前页数        page.setSize(3); // 每页条数        Page&lt;User&gt; userPage = userMapper.selectPage(page, null);        long total = userPage.getTotal(); // 总记录数        System.out.println(&quot;总记录数： &quot; + total);        List&lt;User&gt; records = userPage.getRecords();        records.forEach(System.out::println);    }}</code></pre><h2 id="二、自定义分页"><a href="#二、自定义分页" class="headerlink" title="二、自定义分页"></a>二、自定义分页</h2><h3 id="1-定义接口方法"><a href="#1-定义接口方法" class="headerlink" title="1. 定义接口方法"></a>1. 定义接口方法</h3><pre><code class="java">public interface UserMapper extends BaseMapper&lt;User&gt; {    IPage&lt;User&gt; findUserPageByName(IPage&lt;User&gt; page, @Param(&quot;name&quot;) String name);}</code></pre><h3 id="2-定义-XML"><a href="#2-定义-XML" class="headerlink" title="2. 定义 XML"></a>2. 定义 XML</h3><pre><code class="xml">&lt;select id=&quot;findUserPageByName&quot; resultType=&quot;com.frankeleyn.entity.User&quot;&gt;    SELECT * FROM user    WHERE name like &quot;%&quot;#{name}&quot;%&quot;&lt;/select&gt;</code></pre><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><pre><code class="java">@Testpublic void testDivPage() {    Page&lt;User&gt; page = new Page&lt;&gt;();    page.setCurrent(2); // 当前页数    page.setSize(2); // 每页条数    IPage&lt;User&gt; pages = userMapper.findUserPageByName(page, &quot;Obama&quot;);    pages.getRecords().forEach(System.out::println);}</code></pre><h3 id="提别提醒"><a href="#提别提醒" class="headerlink" title="提别提醒"></a>提别提醒</h3><p>如果你用了自定义方法，<strong>@TableLogic</strong> 就不生效了，需要自己手动加你的逻辑删除语句。</p><h2 id="三、乐观锁"><a href="#三、乐观锁" class="headerlink" title="三、乐观锁"></a>三、乐观锁</h2><h3 id="1-场景"><a href="#1-场景" class="headerlink" title="1. 场景"></a>1. 场景</h3><p>一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。</p><p>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50=150元存入了数据库；小王将商品减了30元，并将100-30=70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。</p><ul><li>创建商品表</li></ul><pre><code class="java">CREATE TABLE product(    id BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,    name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;商品名称&#39;,    price INT(11) DEFAULT 0 COMMENT &#39;价格&#39;,    version INT(11) DEFAULT 0 COMMENT &#39;乐观锁版本号&#39;,    PRIMARY KEY (id));INSERT INTO product (id, NAME, price) VALUES (1, &#39;笔记本&#39;, 100);</code></pre><ul><li><p>创建实体类</p><pre><code class="java">@Datapublic class Product {    private Long id;    private String name;    private Integer price;    private Integer version;}</code></pre></li><li><p>创建 Mapper</p><pre><code class="java">public interface ProductMapper extends BaseMapper&lt;Product&gt; {}</code></pre></li><li><p>测试</p><pre><code class="java">@Testpublic void testLocal() {    // 小李    Product li = productMapper.selectById(1L);    // 小王    Product wang = productMapper.selectById(1L);    // 小李将价格提高50元存入数据库    li.setPrice(li.getPrice() + 50);    productMapper.updateById(li);    // 小王将价格降低30元存入数据库    wang.setPrice(wang.getPrice() - 30);    productMapper.updateById(wang);    // 查询结果    Product product = productMapper.selectById(1L);    System.out.println(&quot;最后的结果：&quot; + product.getPrice()); // 最后的结果：70}</code></pre></li></ul><p>等于 70 是肯定不行的，老板要的售价是 120。</p><h3 id="2-Mybati-Plus-中的乐观锁实现"><a href="#2-Mybati-Plus-中的乐观锁实现" class="headerlink" title="2. Mybati-Plus 中的乐观锁实现"></a>2. Mybati-Plus 中的乐观锁实现</h3><h4 id="①-修改实体类"><a href="#①-修改实体类" class="headerlink" title="① 修改实体类"></a>① 修改实体类</h4><p>给实体类加上 <strong>@Version</strong> 注解</p><pre><code class="java">@Versionprivate Integer version;</code></pre><h4 id="②-添加乐观锁插件"><a href="#②-添加乐观锁插件" class="headerlink" title="② 添加乐观锁插件"></a>② 添加乐观锁插件</h4><p>在 <strong>MybatisPlusConfig</strong> 加入下面这句代码：</p><pre><code class="java">// 添加乐观锁插件interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</code></pre><h4 id="③-重新执行测试代码"><a href="#③-重新执行测试代码" class="headerlink" title="③ 重新执行测试代码"></a>③ 重新执行测试代码</h4><p>小王执行会失败，因为 <strong>version</strong> 已经被小李修改了。</p><h4 id="④-优化流程"><a href="#④-优化流程" class="headerlink" title="④ 优化流程"></a>④ 优化流程</h4><p>让小王失败后重试</p><pre><code class="java">    @Test    public void testLocal() {        // 小李        Product li = productMapper.selectById(1L);        // 小王        Product wang = productMapper.selectById(1L);        // 小李将价格提高50元存入数据库        li.setPrice(li.getPrice() + 50);        productMapper.updateById(li);        // 小王将价格降低30元存入数据库        wang.setPrice(wang.getPrice() - 30);        int row = productMapper.updateById(wang);        while (row == 0) {            // 小王执行失败，等待 1 秒后，重新执行            try {                Thread.sleep(1_000);            } catch (InterruptedException e) {                e.printStackTrace();            }            Product wang2 = productMapper.selectById(1L);            wang2.setPrice(wang2.getPrice() - 30);            row = productMapper.updateById(wang2);        }        // 查询结果        Product product = productMapper.selectById(1L);        System.out.println(&quot;最后的结果：&quot; + product.getPrice()); // 最后的结果：120    }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus(三):常用注解</title>
    <link href="undefined2022/01/18/MybatisPlus-3-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <url>2022/01/18/MybatisPlus-3-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisPlus-三-常用注解"><a href="#MybatisPlus-三-常用注解" class="headerlink" title="MybatisPlus(三):常用注解"></a>MybatisPlus(三):常用注解</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/mybaties-plus-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、-TableName"><a href="#一、-TableName" class="headerlink" title="一、 TableName"></a>一、 TableName</h2><p>表名，将实体类绑定到对应的数据库</p><pre><code class="java">@TableName(&quot;t_user&quot;)public class User{}</code></pre><h2 id="二、TableId"><a href="#二、TableId" class="headerlink" title="二、TableId"></a>二、TableId</h2><h3 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a>type 属性</h3><p>type 属性用来指定主键策略</p><ul><li><p><strong>AUTO</strong>，主键自增，Mysql 主键自增的最小值总是要大于现有数据的最大值</p><pre><code class="java">@TableId(type = IdType.AUTO)private Long id;</code></pre></li><li><p><strong>ASSIGN_ID</strong>，使用<strong>雪花算法</strong>生成主键，例: 1482xxxxxxxxxxx</p><pre><code class="java">@TableId(type = IdType.ASSIGN_ID)private Long id;</code></pre></li></ul><p><strong>id 策略的选择</strong></p><p>一般小数据量，使用自增策略，当数据量超过千万级别后，涉及分库分表，需要使用雪花算法。</p><h2 id="三、TableField"><a href="#三、TableField" class="headerlink" title="三、TableField"></a>三、TableField</h2><h3 id="1-value-属性"><a href="#1-value-属性" class="headerlink" title="1. value 属性"></a>1. value 属性</h3><p>将数据库字段和实体类对应的属性绑定</p><p>将字段 create_time 和 update_time 绑定到实体类的 createTime 和 updateTime 属性上</p><p><img src="E:%5CWorkSpace%5Cmybatis-plus-demo%5Cimg%5C3-3-1.png" srcset="/img/loading.gif" alt="3-3-1"></p><pre><code class="java">@TableField(&quot;create_time&quot;)private LocalDateTime createTime;@TableField(&quot;update_time&quot;)private LocalDateTime updateTime;</code></pre><h3 id="2-自动填充"><a href="#2-自动填充" class="headerlink" title="2. 自动填充"></a>2. 自动填充</h3><p>对于字段，比如 create_time 和 update_time 一般情况下不用刻意处理，可以将这两个字段的默认值设为 <strong>CURRENT_TIMESTAMP</strong> 以获取当前时间。</p><p>MyBatis Plus 提供了自动填充功能，同样可以完成这些字段的赋值工作。</p><ul><li><p>添加 <strong>fill</strong> 属性，指定在哪个操作执行时自动填充</p><pre><code class="java">@TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT)private LocalDateTime createTime;@TableField(value = &quot;update_time&quot;, fill = FieldFill.INSERT_UPDATE)private LocalDateTime updateTime;</code></pre></li><li><p>配置元数据对象处理器</p><pre><code class="java">@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler {    @Override    public void insertFill(MetaObject metaObject) {        System.out.println(&quot;insertFill...&quot;);        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now());        this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());    }    @Override    public void updateFill(MetaObject metaObject) {        System.out.println(&quot;updateFill...&quot;);        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());    }}</code></pre></li></ul><p>之后测试插入和修改。</p><h2 id="四、TableLogic"><a href="#四、TableLogic" class="headerlink" title="四、TableLogic"></a>四、TableLogic</h2><p><strong>逻辑删除：</strong>就是将数据中代表删除的字段修改为<strong>删除状态</strong>，但是在数据库中仍然可以看到该数据。</p><p><strong>@TableLogic</strong> 的作用就是在查询或更新的时候自动为 sql 语句添加一段 你标注的属性 = 0 的后缀</p><h3 id="1-创建逻辑删除列"><a href="#1-创建逻辑删除列" class="headerlink" title="1. 创建逻辑删除列"></a>1. 创建逻辑删除列</h3><p><img src="E:%5CWorkSpace%5Cmybatis-plus-demo%5Cimg%5C3-4-1.png" srcset="/img/loading.gif" alt="3-4-1"></p><h3 id="2-实体类添加注解"><a href="#2-实体类添加注解" class="headerlink" title="2. 实体类添加注解"></a>2. 实体类添加注解</h3><pre><code class="java">@TableLogic@TableField(value = &quot;is_deleted&quot;)private Integer deleted;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus(二):基本用法</title>
    <link href="undefined2022/01/18/MybatisPlus-2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>2022/01/18/MybatisPlus-2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisPlus-二-基本用法"><a href="#MybatisPlus-二-基本用法" class="headerlink" title="MybatisPlus(二)  基本用法"></a>MybatisPlus(二)  基本用法</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/mybaties-plus-demo" target="_blank" rel="noopener">Github</a></p><h2 id="一、通用-Mapper"><a href="#一、通用-Mapper" class="headerlink" title="一、通用 Mapper"></a>一、通用 Mapper</h2><p>在 <strong>Mybatis Plus</strong> 框架中不需要实现 xml 映射配置文件和对应的 sql，它默认有单表的增删改查，都已经在 <strong>BaseMapper&lt;T&gt;</strong> 中实现了，我们只需要声明一个 Mapper 接口，并继承它就能使用。</p><h3 id="1-Insert"><a href="#1-Insert" class="headerlink" title="1. Insert"></a>1. Insert</h3><pre><code class="java">@Testpublic void testInsert() {    // 构造器模式创建 User 对象    User user = User.builder()        .name(&quot;Vincent&quot;)        .age(33)        .email(&quot;Vincent@qq.com&quot;).build();    int row = userMapper.insert(user);    System.out.println(&quot;影响的行数：&quot; + row);    System.out.println(&quot;获取自动生成的 id: &quot; + user.getId());}</code></pre><h3 id="2-Selete"><a href="#2-Selete" class="headerlink" title="2. Selete"></a>2. Selete</h3><pre><code class="java">@Testpublic void testSelect() {    // 根据 id 查询用户    User user1 = userMapper.selectById(1L);    System.out.println(user1);    // 根据 id 列表查询多个用户    List&lt;User&gt; userList = userMapper.selectBatchIds(Arrays.asList(2L, 3L, 4L));    userList.forEach(System.out::println);    // 根据 map 中的条件查询    Map map = new HashMap();    // map 的键使用数据库的字段名，不是类中的属性名    map.put(&quot;name&quot;, &quot;Franklin&quot;);    map.put(&quot;age&quot;, &quot;21&quot;);    List usersList = userMapper.selectByMap(map);    usersList.forEach(System.out::println);}</code></pre><h3 id="3-Update"><a href="#3-Update" class="headerlink" title="3. Update"></a>3. Update</h3><pre><code class="java">@Testpublic void testUpdate() {    User user = userMapper.selectById(1L);    user.setAge(28);    // 更新 id 为 1的用户年龄为 28    int row = userMapper.updateById(user);    System.out.println(&quot;影响的行数： &quot; + row);}</code></pre><h3 id="4-Delete"><a href="#4-Delete" class="headerlink" title="4. Delete"></a>4. Delete</h3><pre><code class="java">@Testpublic void testDelete() {    // 删除 id 为5的用户    int row = userMapper.deleteById(5);    System.out.println(&quot;影响的行数： &quot; + row);}</code></pre><h2 id="二、通用-Service"><a href="#二、通用-Service" class="headerlink" title="二、通用 Service"></a>二、通用 Service</h2><p><strong>mybatis-plus</strong> 提供一个接口 <strong>IService</strong> 和其实现类 <strong>ServiceImpl</strong> ，封装了常见单表的业务层逻辑，也是 CRUD。</p><h3 id="1-创建-Service-接口"><a href="#1-创建-Service-接口" class="headerlink" title="1. 创建 Service 接口"></a>1. 创建 Service 接口</h3><pre><code class="java">package com.frankeleyn.service;import com.baomidou.mybatisplus.extension.service.IService;import com.frankeleyn.entity.User;/** * @author Frankeleyn * @date 2022/1/17 10:15 */public interface UserService extends IService&lt;User&gt; {}</code></pre><h3 id="2-创建-Service-实现类"><a href="#2-创建-Service-实现类" class="headerlink" title="2. 创建 Service 实现类"></a>2. 创建 Service 实现类</h3><pre><code class="java">package com.frankeleyn.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.frankeleyn.entity.User;import com.frankeleyn.mapper.UserMapper;import com.frankeleyn.service.UserService;/** * @author Frankeleyn * @date 2022/1/17 10:16 */@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {}</code></pre><h3 id="3-创建测试类"><a href="#3-创建测试类" class="headerlink" title="3. 创建测试类"></a>3. 创建测试类</h3><pre><code class="java">package com.frankeleyn;import com.frankeleyn.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;/** * @author Frankeleyn * @date 2022/1/17 10:19 */@SpringBootTestpublic class UserServiceTest {    @Autowired    private UserService userService;}</code></pre><h3 id="4-获取总记录数"><a href="#4-获取总记录数" class="headerlink" title="4. 获取总记录数"></a>4. 获取总记录数</h3><pre><code class="java">@Testpublic void testAdd() {    // 获取数据库所有记录数    int count = userService.count();    System.out.println(count);}</code></pre><h3 id="5-批量插入数据"><a href="#5-批量插入数据" class="headerlink" title="5. 批量插入数据"></a>5. 批量插入数据</h3><pre><code class="java">@Testpublic void testBatchAdd() {    // 测试批量插入数据    ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 5; i++) {        User user = new User();        user.setName(&quot;Obama&quot; + i);        user.setAge(10 + i);        users.add(user);    }    userService.saveBatch(users);}</code></pre><h2 id="三、自定义-Mapper"><a href="#三、自定义-Mapper" class="headerlink" title="三、自定义 Mapper"></a>三、自定义 Mapper</h2><p>如果通用 Mapper 不符号我们的需求，我们也可以像以前使用 Mybatis 一样，自定义接口方法并配置 xml 文件，写 sql 语句。</p><h3 id="1-接口方法"><a href="#1-接口方法" class="headerlink" title="1. 接口方法"></a>1. 接口方法</h3><p>在 UserMapper 中定义一个方法 <strong>findUsersByName</strong></p><pre><code class="java">public interface UserMapper extends BaseMapper&lt;User&gt; {    List&lt;User&gt; findUsersByName(String name);}</code></pre><h3 id="2-创建配置文件"><a href="#2-创建配置文件" class="headerlink" title="2. 创建配置文件"></a>2. 创建配置文件</h3><p>在 resource 目录下新建 <strong>mapper</strong> 文件夹，创建 <strong>UserMapper.xml</strong></p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/mybaties-plus-demo/main/img/2-3-2.png" srcset="/img/loading.gif" alt="2-3-2"></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.frankeleyn.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;findUsersByName&quot; resultType=&quot;com.frankeleyn.entity.User&quot;&gt;        SELECT * FROM user        WHERE name like &quot;%&quot;#{name}&quot;%&quot;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h3 id="3-测试自定义条件查询"><a href="#3-测试自定义条件查询" class="headerlink" title="3. 测试自定义条件查询"></a>3. 测试自定义条件查询</h3><pre><code class="java">@Testpublic void testFindUserByName() {    // 查询用户名字中带有 Obama     List&lt;User&gt; userList = userMapper.findUsersByName(&quot;Obama&quot;);    userList.forEach(System.out::println);}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus(一):入门案例</title>
    <link href="undefined2022/01/18/MybatisPlus-1-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
    <url>2022/01/18/MybatisPlus-1-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisPlus-一-入门案例"><a href="#MybatisPlus-一-入门案例" class="headerlink" title="MybatisPlus(一) 入门案例"></a>MybatisPlus(一) 入门案例</h1><p>代码地址：<a href="https://githubfast.com/Frankeleyns/mybaties-plus-demo" target="_blank" rel="noopener">Github</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://baomidou.com/" target="_blank" rel="noopener">MyBatis-Plus </a>（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/mybaties-plus-demo/main/img/banner.png" srcset="/img/loading.gif" alt="banner"></p><h2 id="1-创建数据表-User"><a href="#1-创建数据表-User" class="headerlink" title="1. 创建数据表 User"></a>1. 创建数据表 User</h2><pre><code class="mysql">CREATE TABLE user(    id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;,    name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;,    age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;,    email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,    PRIMARY KEY (id));INSERT INTO user (id, name, age, email) VALUES(1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;),(2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;),(3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;),(4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;),(5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;);</code></pre><h2 id="2-创建-Spring-Boot-工程"><a href="#2-创建-Spring-Boot-工程" class="headerlink" title="2. 创建 Spring Boot 工程"></a>2. 创建 Spring Boot 工程</h2><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/mybaties-plus-demo/main/img/1-2-1.png" srcset="/img/loading.gif" alt="02"></p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/mybaties-plus-demo/main/img/1-2-2.png" srcset="/img/loading.gif" alt="03"></p><h2 id="3-引入依赖"><a href="#3-引入依赖" class="headerlink" title="3. 引入依赖"></a>3. 引入依赖</h2><p>修改你的 pom 文件</p><pre><code class="xml">    &lt;!-- 配置 Spring Boot 版本 --&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h2 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h2><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/mybaties-plus-demo/main/img/1-4-1.png" srcset="/img/loading.gif" alt="4-1"></p><pre><code class="properties"># 端口号server.port= 8082# ==================== 数据源设置 =========================spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123456# ================ mybatis 配置 =========================# 驼峰命名mybatis-plus.configuration.map-underscore-to-camel-case=true# 扫描映射配置文件mybatis-plus.mapper-locations=classpath:mapper/*Mapper.xml</code></pre><h2 id="5-创建实体类"><a href="#5-创建实体类" class="headerlink" title="5. 创建实体类"></a>5. 创建实体类</h2><p>创建包 <strong>entity</strong> 并创建 <strong>User</strong> 实体类</p><pre><code class="java">package com.frankeleyn.entity;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;/** * @author Frankeleyn * @date 2022/1/14 16:24 */@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class User {    // 主键    private Long id;    // 名字    private String name;    // 年龄    private Integer age;    // 邮箱    private String email;}</code></pre><h2 id="6-创建-Mapper-接口"><a href="#6-创建-Mapper-接口" class="headerlink" title="6. 创建 Mapper 接口"></a>6. 创建 Mapper 接口</h2><p>创建包 <strong>mapper</strong> 并创建 <strong>UserMapper</strong> 接口继承 <strong>BaseMapper</strong> 接口</p><pre><code class="java">package com.frankeleyn.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.frankeleyn.entity.User;/** * @author Frankeleyn * @date 2022/1/14 16:33 */public interface UserMapper extends BaseMapper&lt;User&gt; {}</code></pre><h2 id="7-添加启动类注解"><a href="#7-添加启动类注解" class="headerlink" title="7. 添加启动类注解"></a>7. 添加启动类注解</h2><p>给启动类添加注解 <strong>@MapperScan</strong> ，要不然会报一个找不到 Mapper 的错误</p><pre><code class="java">package com.frankeleyn;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.frankeleyn.mapper&quot;)public class MybatisPlusDemoApplication {    public static void main(String[] args) {        SpringApplication.run(MybatisPlusDemoApplication.class, args);    }}</code></pre><h2 id="8-添加测试类进行功能测试"><a href="#8-添加测试类进行功能测试" class="headerlink" title="8. 添加测试类进行功能测试"></a>8. 添加测试类进行功能测试</h2><pre><code class="java">package com.frankeleyn;import com.frankeleyn.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;/** * @author Frankeleyn * @date 2022/1/15 10:42 */@SpringBootTestpublic class UserDaoTest {    @Autowired    private UserMapper userMapper;    @Test    public void testFindAll() {        userMapper.selectList(null).forEach(System.out::println);    }}</code></pre><p>打印结果：</p><p><img src="https://external.githubfast.com/https/raw.githubusercontent.com/Frankeleyns/mybaties-plus-demo/main/img/1-8-1.png" srcset="/img/loading.gif" alt="8-1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java(七)：复合优于继承</title>
    <link href="undefined2020/11/08/EffectiveJava-7-%E5%A4%8D%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
    <url>2020/11/08/EffectiveJava-7-%E5%A4%8D%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="复合优于继承"><a href="#复合优于继承" class="headerlink" title="复合优于继承"></a>复合优于继承</h2><p>继承（extends）是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。使用不当会导致应用变的脆弱。下面我举一个例子，我需要查询<strong>HashSet</strong>看看它被创建以来添加过多少个元素。为了实现该功能，我会继承该类，增加一个<strong>addCount</strong>属性来记录元素插入数量，还有一个访问该数值的方法，并覆盖<strong>add</strong>、<strong>addAll</strong>这两个增加元素的方法。</p><pre><code class="java">//Broken - inappropriate use of inheritance!public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {    //The number of attempted element insertions    private int addCount = 0;    public InstrumentedHashSet(){}    public InstrumentedHashSet(int initCap, float loadFactor){        super(initCap,loadFactor);    }    @Override    public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override    public boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getCount(){        return addCount;    }}</code></pre><p>然后，创建一个实例运行试试：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; list = Arrays.asList(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;);        InstrumentedHashSet&lt;String&gt; ihashSert = new InstrumentedHashSet&lt;String&gt;();        ihashSert.addAll(list);        System.out.println(ihashSert.getCount());    //输出： 6    }</code></pre><p>我只添加了3个元素，然而实际结果却返回6，为什么呢？请看下面的<strong>HashSet</strong>的<strong>addAll</strong>方法的实现：</p><pre><code class="java">    public boolean addAll(Collection&lt;? extends E&gt; c) {        boolean modified = false;        for (E e : c)            if (add(e))        //调用add方法                modified = true;        return modified;    }</code></pre><p>原来<strong>HashSet</strong>的<strong>addAll</strong>方法是基于<strong>add</strong>方法来实现的，但这在它的文档里并没有说明，我们<strong>InstrumentedHashSet</strong>类中的<strong>addAll</strong>方法，首先给<strong>addCount</strong>增加3，然后当进入<strong>super.addAll</strong>来调用<strong>HashSet</strong>的<strong>addAll</strong>实现的时候，Bug出现了，这时又会调用三次add方法，每个元素调用一次，给<strong>addCount</strong>又增加了3，所以总共增加了6。</p><p>下面我们使用<strong>复合（composition）</strong>来解决这个继承产生的坑。</p><pre><code class="java">//Wrapper class - uses composition in place of extendspublic class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {    private final Set&lt;E&gt; s;    public ForwardingSet(Set&lt;E&gt; s) {        this.s = s;    }    @Override    public void clear() {        s.clear();    }    @Override    public int size() {        return s.size();    }    @Override    public boolean isEmpty() {        return s.isEmpty();    }    @Override    public boolean contains(Object o) {        return s.contains(o);    }    @Override    public Iterator&lt;E&gt; iterator() {        return s.iterator();    }    @Override    public Object[] toArray() {        return s.toArray();    }    @Override    public &lt;T&gt; T[] toArray(T[] a) {        return s.toArray(a);    }    @Override    public boolean add(E e) {        return s.add(e);    }    @Override    public boolean remove(Object o) {        return s.remove(o);    }    @Override    public boolean containsAll(Collection&lt;?&gt; c) {        return s.containsAll(c);    }    @Override    public boolean addAll(Collection&lt;? extends E&gt; c) {        return s.addAll(c);    }    @Override    public boolean retainAll(Collection&lt;?&gt; c) {        return s.retainAll(c);    }    @Override    public boolean removeAll(Collection&lt;?&gt; c) {        return s.removeAll(c);    }}</code></pre><pre><code class="java">//Reusable forwarding classpublic class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt;{    private int addCount = 0;    public InstrumentedSet(Set&lt;E&gt; s) {        super(s);    }    @Override    public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override    public boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getAddCount(){        return addCount;    }}</code></pre><p>创建实例测试一下：</p><pre><code class="java">    public static void main(String[] args) {        List&lt;String&gt; list = Arrays.asList(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;);        InstrumentedSet&lt;String&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;());        s.addAll(list);        System.out.println(s.getAddCount());    //输出： 3    }</code></pre><p><strong>ForwardingSet</strong>类中的每个实例方法都可以调用被包含的现有类<strong>Set</strong>实例中的对应方法，并返回它的结果，这被称为转发（forwarding），<strong>ForwardingSet</strong>中的方法被称为<strong>转发方法(forwarding method)</strong>，这样得到的方法非常稳固，不依赖于现有类的实现细节，所以就不会出现像继承<strong>HashSet</strong>时的Bug。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java(六)：使可变性最小</title>
    <link href="undefined2020/09/26/EffectiveJava-6-%E4%BD%BF%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F/"/>
    <url>2020/09/26/EffectiveJava-6-%E4%BD%BF%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="使可变性最小"><a href="#使可变性最小" class="headerlink" title="使可变性最小"></a>使可变性最小</h2><p><strong>Java</strong>类库包含许多不可变类，其中有<strong>String</strong>、基本类型的包装类、<strong>BigInteger</strong>和<strong>BigDecimal</strong>。这些不可变类比可变类更加易于设计、实现和使用。</p><p>使类要不可变，有五条原则：</p><ol><li><p><strong>不要提供任何会修改对象状态的方法(也称设值的方法，比如Setter)</strong>。</p></li><li><p><strong>保证类不会被扩展。</strong></p></li><li><p><strong>声明所有的域都是final的。</strong></p></li><li><p><strong>声明所有的域都是私有的。</strong></p></li><li><p><strong>确保对于任何可变组件的互斥访问。</strong></p></li></ol><p>下面举一个例子：</p><pre><code class="java">public final class Complex {    private final double re;    private final double im;    public Complex(double re, double im) {        this.re = re;        this.im = im;    }    public double realPart(){ return re; }    public double imaginaryPart(){ return im; }    public Complex plus(Complex c){        return new Complex(re + c.re, im + c.im);    }    public Complex minus(Complex c){        return new Complex(re - c.re, im - c.im);    }    public Complex times(Complex c){        return new Complex(re * c.re - im * c.im,                           re * c.im + im * c.re);    }    public Complex dividedBy(Complex c){        double tmp = c.re * c.re + c.im * c.im;        return new Complex((re * c.re + im * c.im) / tmp,                               (im * c.re - re * c.im) / tmp);    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (!(o instanceof Complex)) return false;        Complex c = (Complex) o;        return Double.compare(c.re, re) == 0 &amp;&amp; Double.compare(c.im, im) == 0;    }    @Override    public int hashCode() {        return 31 * Double.hashCode(re) + Double.hashCode(im);    }    @Override    public String toString() {        return &quot;Complex{&quot; +                &quot;re=&quot; + re +                &quot;, im=&quot; + im +                &#39;}&#39;;    }}</code></pre><p>这个类表示一个<strong>复数</strong>（complex number，有实部和虚部）。里面有四个基本算术运算：加、减、乘、除。需要注意的是这些算术运算都是<strong>返回新的实例，而不是修改现有的实例</strong>。这种方式被称为<strong>函数的（functional）</strong>的方法，这些方法返回的是一个函数的结果，这些函数对操作数运算但不修改它。</p><p>​    <strong>不可变对象本质上是线程安全的，它们不要求同步。</strong>当多个线程并发访问这样的对象时，它们不会遭到破坏。这无疑是获得线程安全最容易的办法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java(五)：覆盖equals时请遵守约定</title>
    <link href="undefined2020/09/20/EffectiveJava-5-%E8%A6%86%E7%9B%96equals%E6%97%B6%E8%AF%B7%E9%81%B5%E5%AE%88%E7%BA%A6%E5%AE%9A/"/>
    <url>2020/09/20/EffectiveJava-5-%E8%A6%86%E7%9B%96equals%E6%97%B6%E8%AF%B7%E9%81%B5%E5%AE%88%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="覆盖equals时请遵守约定"><a href="#覆盖equals时请遵守约定" class="headerlink" title="覆盖equals时请遵守约定"></a>覆盖equals时请遵守约定</h2><p>在你覆盖类的<strong>equals</strong>方法时需要遵守一定的约定：</p><ul><li><strong>自反性（reflexive）：</strong>对于任何非null的引用值<strong>x</strong>,<strong>x.equals(x)</strong>必须返回<strong>true</strong>。</li><li><strong>对称性（symmetric）：</strong>对于任何非null的引用值<strong>x</strong>和<strong>y</strong>，当且仅当<strong>y.equals(x)</strong>返回<strong>true</strong>时，<strong>x.equals(y)</strong>必须返回<strong>true</strong>。</li><li><strong>传递性（transitive）：</strong>对于任何非null的引用值<strong>x,y **和</strong>z<strong>，如果</strong>x.equals(y)<strong>返回</strong>true<strong>，并且</strong>y.equals(z)<strong>也返回</strong>true<strong>，那么</strong>x.equals(z)<strong>也必须返回</strong>true**。</li><li><strong>一致性（consistent）：</strong>对于任何非null的引用值<strong>x</strong>和<strong>y</strong>，只要<strong>equals</strong>的比较操作在对象中所用的信息没有被修改，多次调用<strong>x.equals(y)</strong>就会一致的返回<strong>true</strong>，或一致的返回<strong>false</strong>。</li><li>对于任何非null的引用值<strong>x</strong>，<strong>x.equals(null)</strong>必须返回<strong>false</strong>。</li></ul><p>下面有一个<strong>破坏对称性</strong>的例子：</p><pre><code class="java">//Broken - violates symmetrypublic final class CaseInsensitiveString {    private final String s;    public CaseInsensitiveString(String s) {        this.s = Objects.requireNonNull(s);    }    //Broken - violates symmetry    @Override    public boolean equals(Object o) {        if(o instanceof  CaseInsensitiveString)            return s.equalsIgnoreCase( ((CaseInsensitiveString) o).s );        if(o instanceof String)     //单向操作            return s.equalsIgnoreCase((String) o);        return  false;    }}</code></pre><p>假设有一个不区分大小的字符串和一个普通字符串：</p><pre><code class="java">      public static void main(String[] args) {        CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);        String s = &quot;polish&quot;;        System.out.println(cis.equals(s));    //输出：true        System.out.println(s.equals(cis));    //输出：false    }</code></pre><p>这里的问题在于<strong>CaseInsensitiveString</strong>类中的<strong>equals</strong>知道如何处理普通的字符串对象，但是<strong>String</strong>类中的<strong>equals</strong></p><p>却不知道如何区分大小写，显然违反了对称性，解决这个问题的办法就是去掉企图与<strong>String</strong>类互操作的代码：</p><pre><code class="java">    @Override    public boolean equals(Object o) {        return o instanceof CaseInsensitiveString &amp;&amp;                ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);    }------------------------------------------------------    public static void main(String[] args) {        CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);        String s = &quot;polish&quot;;        System.out.println(cis.equals(s));    //输出：false        System.out.println(s.equals(cis));    //输出：false    }</code></pre><p>这次我们举一个破坏<strong>传递性</strong>的例子,我们以一个简单的<strong>Point</strong>类开始：</p><pre><code class="java">public class Point {    private final int x;    private final int y;   public Point(int x,int y){       this.x = x;       this.y = y;   }    @Override    public boolean equals(Object o) {        if(!(o instanceof Point))            return false;        Point p = (Point) o;        return p.x == x &amp;&amp; p.y == y;    }}</code></pre><p>然后我们想扩展这个类，给它加个颜色</p><pre><code class="java">public class ColorPoint extends Point {    private final Color color;    public ColorPoint(int x, int y, Color color) {        super(x, y);        this.color = color;    }}</code></pre><p>这样会产生什么后果呢？<strong>equals</strong>方法不生效，因为当前类没有<strong>equals</strong>方法而是直接从<strong>Point</strong>继承过来的，这显然不符合我们的逻辑。我们的想法是，当<strong>ColorPoint</strong>的<strong>x,y</strong>一样并且颜色一样才返回<strong>true</strong>：</p><pre><code class="java">    //Broken - violates symmetry!    @Override    public boolean equals(Object o) {        if(!(o instanceof  ColorPoint))            return false;        return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;    }</code></pre><p>这样写在比较普通点和有色点会产生问题，普通点会忽略颜色，返回<strong>true</strong>，有色点会返回<strong>false</strong>，显然破坏了<strong>对称性</strong>：</p><pre><code class="java">    public static void main(String[] args) {        Point p = new Point(1,2);        ColorPoint cp = new ColorPoint(1, 2, Color.RED);        System.out.println(p.equals(cp));   //输出结果： true        System.out.println(cp.equals(p));   //输出结果： false    }</code></pre><p>所以，我们可以让<strong>ColorPoint</strong>在混合比较时忽略颜色信息：</p><pre><code class="java">    //Broken - violates transitivity!    @Override    public boolean equals(Object o) {        if(!(o instanceof  Point))            return false;        //if o is a normal Point,do a color-blind comparison        if(!(o instanceof ColorPoint))            return o.equals(this);        return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;    }</code></pre><p>这样确实有了对称性，但又破坏了传递性：</p><pre><code class="java">    public static void main(String[] args) {        ColorPoint p1 = new ColorPoint(1,2,Color.RED);        Point p2 = new Point(1, 2);        ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);        System.out.println(p1.equals(p2));  //输出结果： true        System.out.println(p2.equals(p3));  //输出结果： true        System.out.println(p1.equals(p3));  //输出结果： false    }</code></pre><p>所以，我们有没有一种方法，既增加新的值组件，又保留<strong>equals</strong>约定？答案就是<strong>复合优于继承</strong>：</p><pre><code class="java">public class ColorsPoint {    private final Point point;    private final Color color;    public ColorsPoint(int x, int y, Color color) {        point = new Point(x, y);        this.color = Objects.requireNonNull(color);    }    /**     * Returns the point-view of this color point.     */    public Point asPoint(){        return point;    }    @Override    public boolean equals(Object o) {        if(!(o instanceof ColorPoint))            return false;        ColorsPoint cp = (ColorsPoint) o;        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);    }}</code></pre><p>不再让<strong>ColorPoint</strong>继承<strong>Point</strong>，而是在<strong>ColorPoint</strong>中加入一个私有<strong>Point</strong>域，以及一个公有视图方法，该方法返回有色点在相同位置的<strong>Point</strong>对象</p><pre><code class="java">    public static void main(String[] args) {        ColorPoint p1 = new ColorPoint(1,2,Color.RED);        Point p2 = new Point(1, 2);        ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);        System.out.println(p1.equals(p2));  //输出结果： false        System.out.println(p2.equals(p3));  //输出结果： false        System.out.println(p1.equals(p3));  //输出结果： false    }</code></pre><p>最后，还有一些<strong>equals</strong>需要注意的点：</p><ul><li>覆盖<strong>equals</strong>时总要覆盖<strong>hashCode</strong></li><li>不要企图让<strong>equals</strong>方法过于智能。如果简单的比较值是否相等，就不难做到遵守<strong>equals约定</strong>，如果过度的寻求等价关系，就会容易陷入麻烦之中，如上面的<strong>Point</strong>和<strong>ColorPoint</strong>。</li><li>不要将<strong>equals</strong>声明的<strong>Object</strong>对象替换为其他类型。这样编译器会提示并不是重写方法，因为它和<strong>Object.equals</strong>不同。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java(四)：try-with-resources优于try-finally</title>
    <link href="undefined2020/08/30/EffectiveJava-4-try-with-resources%E4%BC%98%E4%BA%8Etry-finally/"/>
    <url>2020/08/30/EffectiveJava-4-try-with-resources%E4%BC%98%E4%BA%8Etry-finally/</url>
    
    <content type="html"><![CDATA[<h2 id="try-with-resources优于try-finally"><a href="#try-with-resources优于try-finally" class="headerlink" title="try-with-resources优于try-finally"></a>try-with-resources优于try-finally</h2><p>许多java类库中都有通过调用<strong>close</strong>方法来手工关闭资源。比如<strong>java.sql.Connection</strong>、<strong>InputStream</strong>、<strong>OutputStream</strong>。</p><p>通常我们都是使用<strong>try-finally</strong>来关闭资源：</p><pre><code class="java">    /**     * 读取任意文件第一行     * @param path 文件路径     * @return  文件内容     * @throws IOException 抛出异常     */    public static String  firstLineOfFile(String path) throws IOException {        BufferedReader br = new BufferedReader(new FileReader(path));        try {            return br.readLine();        } finally {            br.close();        }    }</code></pre><p>看起来也不是很麻烦，如果你引用两个资源呢？</p><pre><code class="java">    /**     * 拷贝文件     * @param src   源文件路径     * @param dst   目标文件路径     * @throws IOException  抛出异常     */    public static void copy(String src,String dst) throws IOException {        InputStream in = new FileInputStream(src);        try{            OutputStream out = new FileOutputStream(dst);            try{                byte[] buf = new byte[5];                int n;                while((n = in.read(buf)) &gt;= 0 )                    out.write(buf,0,n);            } finally {                out.close();            }        } finally {            in.close();        }    }</code></pre><p>这看起来和写<strong>if-else</strong>没啥区别，破坏了代码的可读性，当我们使用了<strong>try-with-resources</strong>，这个问题迎刃而解。</p><p>使用<strong>try-with-resources</strong>第一个例子</p><pre><code class="java">    public static String firstLineOfFile(String path) throws IOException {        try(BufferedReader br = new BufferedReader(                new FileReader(path)        )){            return br.readLine();        }    }</code></pre><p>使用<strong>try-with-resources</strong>第二个例子</p><pre><code class="java">    public static void copy(String src,String dst) throws IOException {        try(InputStream in = new FileInputStream(src);            OutputStream out = new FileOutputStream(dst)                ){            byte[] buf = new byte[5];            int n;            while ((n = in.read(buf)) &gt;= 0)                out.write(buf,0,n);        }    }</code></pre><p>发现了吗？使用<strong>try-with-resources</strong>的好处就是不用再去手动<strong>close</strong>资源，使代码变得简洁易懂。书上形容这种写法<strong>short and sweet</strong>。我们依然还可以在<strong>try-with-resources</strong>增加<strong>catch</strong>子句来处理发生异常后的流程。</p><p><strong>try-with-resources</strong>不仅可以使用jdk内置类，开发者也可以通过实现<strong>java.lang.AutoCloseable</strong>接口，然后使自己的类可以在<strong>try-with-resources</strong>生效：</p><p><strong>AutoCloseable</strong>就一个方法：</p><pre><code class="java">public interface AutoClosable{    public void close() throws Exception;}</code></pre><p>下面自己写一个简单的例子</p><pre><code class="java">public class MyClose implements AutoCloseable {    public void doSomething(){        System.out.println(&quot;MyClose Do Something！&quot;);    }    @Override    public void close() throws Exception {        System.out.println(&quot;MyClose Closed!&quot;);    }}</code></pre><p>这样我们也能在<strong>try-with-resources</strong>使用自己的类了：</p><pre><code class="java">    public static void myAutoClose() throws Exception {        try(MyClose myClose = new MyClose()){            myClose.doSomething();        }    }输出：    MyClose Do Something！      MyClose Closed!</code></pre><p>结论：在处理必须关闭的资源时，始终要优先考虑使用<strong>try-with-resources</strong>，而不是复杂的<strong>try-finally</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java(三)：消除过期的对象引用</title>
    <link href="undefined2020/08/22/EffectiveJava-3-%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/"/>
    <url>2020/08/22/EffectiveJava-3-%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><p>Java比C好用的地方，就是java有<strong>GC</strong>（Carbge Collection），不用的对象系统会自动帮你回收，C用完内存需要程序员手工管理。这方便了程序员们工作，但你不能认为你不用考虑<strong>内存管理</strong>的事情。</p><p>看一下用java实现简单的栈：</p><pre><code class="java">public class Stack {    private Object[] elements;    private int top = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 3;    public Stack(){        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e){        ensureCapacity();        elements[top++] = e;    }    public Object pop(){        if(top == 0)            throw new EmptyStackException();        Object result = elements[--top];        return result;    }    /**     *  保证每次新增元素都有足够空间     */    private void ensureCapacity(){        if(elements.length == top)            elements = Arrays.copyOf(elements,2 * top + 1);    }}</code></pre><p>这样写看起来好像没啥问题，但是当你调用的时候就发现——靠北，问题大了！</p><pre><code class="java">        Stack stack = new Stack();        stack.push(&quot;a&quot;);         stack.push(&quot;b&quot;);        stack.pop();        stack.pop();输出：        Stack{elements=[a, null, null], top=1}        Stack{elements=[a, b, null], top=2}        Stack{elements=[a, b, null], top=1}        Stack{elements=[a, b, null], top=0}</code></pre><p>你会发现<strong>pop()</strong>不起作用，我明明不用这个对象了，为啥java不把他回收呢？那是因为栈内部维护着这些对象的<strong>过期引用(obsolete reference)</strong>，而过期引用是永远不会被回收的。</p><p>因为你的Stack类是自己管理着内存，开发人员知道，<strong>elements</strong>里数组下标<strong>小于top</strong>的对象重要，其余的需要回收，但是垃圾回收器不懂，他认为整个<strong>elements</strong>里的元素都是一视同仁的，都是有用的。于是就造成了<strong>过期引用</strong>，<strong>只要是类自己管理内存，程序员就要警惕内存泄漏问题。</strong></p><p>解决的办法也很简单就是<strong>手动清空</strong>。</p><pre><code class="java">    public Object pop(){        if(top == 0)            throw new EmptyStackException();        Object result = elements[--top];        elements[top] = null; /* 手动清空 */        return result;    }</code></pre><p>因为JDK也有Stack类,所以我去翻了翻JDK<strong>java.util.Stack</strong>的源码，看看它是怎么做的，下面是JDK的Stack类的pop方法：</p><pre><code class="java">    public synchronized E pop() {        E       obj;        int     len = size();        obj = peek();        removeElementAt(len - 1);        return obj;    }</code></pre><p>这里面调用了一个<strong>removeElementAt()</strong>方法，这是<strong>java.util.Vector</strong>的方法，而JDK里的Stack类继承自<strong>Vector</strong>类，进去<strong>Vector.removeElementAt()</strong>你就会看见下面这句话：</p><pre><code class="java">        elementData[elementCount] = null; /* to let gc do its work */</code></pre><p>JDK的Stack也是用的手动清空的方式来回收内存！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java(二)：使用私有构造器或枚举强化Singleton属性</title>
    <link href="undefined2020/08/17/EffectiveJava-2-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E6%9E%9A%E4%B8%BE%E5%BC%BA%E5%8C%96Singleton%E5%B1%9E%E6%80%A7/"/>
    <url>2020/08/17/EffectiveJava-2-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E6%9E%9A%E4%B8%BE%E5%BC%BA%E5%8C%96Singleton%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="使用私有构造器或枚举强化Singleton属性"><a href="#使用私有构造器或枚举强化Singleton属性" class="headerlink" title="使用私有构造器或枚举强化Singleton属性"></a>使用私有构造器或枚举强化Singleton属性</h2><p>实现单例模式的常用方法都是，保持构造器私有，然后导出公有静态成员</p><pre><code class="java">public class FakeInstance {    public static final FakeInstance INSTANCE = new FakeInstance();    private FakeInstance(){}}</code></pre><p>但这种单例模式是可以被反射攻击的</p><pre><code class="java">    public static void fakeInstance() throws Exception {        Class&lt;FakeInstance&gt; clazz = FakeInstance.class;        Constructor&lt;FakeInstance&gt; constructor = clazz.getDeclaredConstructor(null);        constructor.setAccessible(true);        FakeInstance fakeInstance = constructor.newInstance();        FakeInstance instance = FakeInstance.INSTANCE;        System.out.println(fakeInstance.equals(instance) &amp;&amp; fakeInstance == instance);  //输出：false    }</code></pre><p>而单例最好的实现方式是枚举，这种方式的好处有三个，枚举类没法反射、线程安全、防止序列化生成新的类，而且代码简洁</p><pre><code class="java">public enum RealInstance {        INSTANCE;        public void become(){            System.out.println(&quot;成为单例&quot;);        }}</code></pre><p>调用示例：</p><pre><code class="java">    RealInstance.INSTANCE.become();  //输出：成为单例</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java(一)：遇到多个构造器参数考虑使用Builder模式</title>
    <link href="undefined2020/08/08/EffectiveJava-1-%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8Builder%E6%A8%A1%E5%BC%8F/"/>
    <url>2020/08/08/EffectiveJava-1-%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8Builder%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="遇到多个构造器参数考虑使用Builder模式"><a href="#遇到多个构造器参数考虑使用Builder模式" class="headerlink" title="遇到多个构造器参数考虑使用Builder模式"></a>遇到多个构造器参数考虑使用Builder模式</h2><p>我们经常遇到一个开发场景，就是一个实体类的参数很多，你要创建它的对象然后给它赋值。</p><p>第一种方法，使用类的构造方法</p><pre><code class="java">public User(String id,String account,String password,String sex,String name,String phone){       this.id        = id;       this.account   = account;       ...   }</code></pre><p>创建实例</p><pre><code class="java">User user = new User(UUID,&quot;123456&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;会飞的猪&quot;,&quot;10010&quot;);</code></pre><p>这样的过多的参数会使你眼花缭乱，值很多不知道什么意思，有时候还容易弄错属性的顺序，可读性不太好。</p><p>第二种方法，就是使用JavaBeans模式，也就是Getter Setter</p><pre><code class="java">public void setId(String id) {this.id = id;}public void setAccount(String account){this.account = account;}  ....</code></pre><p>创建对象</p><pre><code class="java">User user = new User();user.setId(UUID);user.setAccount(&quot;123456&quot;);...</code></pre><p>绝大部分人肯定用的都是这种方式，可惜的是这种方式其实是有缺点的。因为有很多set，所以构造过程被拆分成好几个调用，在构造过程中会导致JavaBeans可能处于<strong>不一致状态</strong>，于是你就需要额外写代码来保持线程安全。</p><p>   第三种方法，既可以像构造器模式那样安全，也可以像JavaBeans模式那样可读性好。这就是<strong>建造者模式(Builder Pattern)</strong></p><pre><code class="java">public class User {    private String id;    private String account;    private String password;    private String sex;    private String name;    private String phone;    public static class Builder{        private String id;        private String account;        private String password;        private String sex;        private String name;        private String phone;        public Builder id(String var){ id = var;   return this; }        public Builder account(String var){ account = var;return this;};        public Builder password(String var){        password = var;  return this; };        public Builder sex(String var){ sex = var;  return this; };        public Builder name(String var){ name = var;  return this; };        public Builder phone(String var){ phone = var;  return this; };        //将构造器的值赋给实体类        public User build(){            return new User(this);        }    }    //私有类的构造方法保证安全性(类似单例模式)    private User(Builder builder){        this.id = builder.id;        this.account = builder.account;        this.password = builder.password;        this.sex = builder.sex;        this.name = builder.name;        this.phone = builder.phone;    }}</code></pre><p>创建对象</p><pre><code class="java">User user = new  User.Builder()    .id(&quot;1As5w86a1d&quot;).account(&quot;123456&quot;)    .password(&quot;123456&quot;).sex(&quot;男&quot;)    .name(&quot;轩辕狂傲&quot;).phone(&quot;111111&quot;).build();</code></pre><p>这样既可以像构造器模式那样安全，也可以像JavaBeans模式那样可读性好，一举两得！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(五)：SSH免密登录</title>
    <link href="undefined2020/03/09/Linux-5-%E5%AE%89%E8%A3%85SSH/"/>
    <url>2020/03/09/Linux-5-%E5%AE%89%E8%A3%85SSH/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h1><p><strong>SSH(Secure Shell)</strong>是一种<strong>网络协议</strong>，用于计算机之间的<strong>加密登录</strong>。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p><p>想进一步了解的话可以，参考阮一峰老师的<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">博客</a></p><h2 id="一-配置Hosts"><a href="#一-配置Hosts" class="headerlink" title="一.配置Hosts"></a>一.配置Hosts</h2><p>配置你的hosts，不配置会导致ssh登录无效</p><pre><code class="bash">$ sudo vim /etc/hosts</code></pre><p>添加服务器所对应的IP和主机名</p><p><img src="https://i.loli.net/2020/03/09/6zhtRGrVs2laPAT.png" srcset="/img/loading.gif" alt="ssh-hosts.png"></p><h2 id="二-生成密钥"><a href="#二-生成密钥" class="headerlink" title="二.生成密钥"></a>二.生成密钥</h2><p>在<strong>hadoop000</strong>用命令生成<strong>SSH密钥</strong>，接着，按三下回车就好</p><pre><code class="bash">$ ssh-keygen -t rsa</code></pre><p><img src="https://i.loli.net/2020/03/06/lGMkCYLPdoV8yni.png" srcset="/img/loading.gif" alt="ssh-keygen"></p><p>然后，进入<strong>.ssh</strong>文件夹，查看目录，会发现多了两个文件，<strong>id_rsa(私钥)</strong>和<strong>id_rsa.pub(公钥)</strong></p><p><img src="https://i.loli.net/2020/03/06/rl7G81CyxpAumYg.png" srcset="/img/loading.gif" alt=""></p><h2 id="三-公钥登录"><a href="#三-公钥登录" class="headerlink" title="三.公钥登录"></a>三.公钥登录</h2><p>用<strong>ssh-copy-id</strong>命令，将<strong>hadoop000</strong>生成的公钥传到<strong>hadoop8</strong>，@前面是目标用户名，@后面为目标服务器IP，如果用户名不同，还是要密码登录</p><pre><code class="bash">$ ssh-copy-id hadoop@192.168.1.8</code></pre><p><strong>hadoop8</strong>的<strong>.ssh</strong>目录会多出来一个<strong>authorized_keys</strong>的文件，然后设置一下权限</p><pre><code class="bash">$ chmod 600 authorized_keys #如果不设置，可能会因为权限问题不能免密登录</code></pre><p>用<strong>hadoop000</strong>ssh登录<strong>hadoop8</strong>，登录的时候不用输入密码了，<strong>SSH配置成功</strong></p><p><img src="https://i.loli.net/2020/03/09/ZSRxlpLfwJuk8Kt.png" srcset="/img/loading.gif" alt="ssh-success.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(四):安装JAVA环境(jdk1.8)</title>
    <link href="undefined2020/03/04/Linux-4-%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/"/>
    <url>2020/03/04/Linux-4-%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-JAVA环境-jdk1-8"><a href="#安装-JAVA环境-jdk1-8" class="headerlink" title="安装 JAVA环境(jdk1.8)"></a>安装 JAVA环境(jdk1.8)</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p><strong>下载jdk1.8</strong></p><p>进入Oracle官网下载页面</p><p><img src="https://i.loli.net/2020/03/04/SIwEvHBJ56gzUtr.png" srcset="/img/loading.gif" alt=""></p><p>如果你下的很慢的话，我给你贴心的准备好了我下好了的    <a href="https://pan.baidu.com/s/1_toI_omzKLYwinFo60BpRA" target="_blank" rel="noopener">点我(提取码：guk0)</a></p><p>下好后可以用<strong>WinScp</strong>或<strong>XFTP</strong>自行上传到自己的服务器目录，如果不会的话，我建议你<strong>百度</strong></p><p>我这里将JDK传到了我的<strong>~/software</strong>目录，我建议你们也可以自己建个software目录专门存放要安装的软件包</p><p><img src="https://i.loli.net/2020/03/04/Twra1WCDXcSZkoN.png" srcset="/img/loading.gif" alt="linux"></p><p>这里可以看到我的<strong>software</strong>目录已经有我上传的jdk了</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p><strong>解压</strong>已经传到服务器的jdk文件</p><p>使用<strong>tar</strong>命令将software目录下的jdk解压到app目录</p><pre><code class="bash">tar -zvxf jdk-8u241-linux-x64.tar.gz  -C ~/app</code></pre><p>解压完进入查看一下</p><pre><code class="bash">[hadoop@hadoop000 ~]$ lsapp   Desktop    Downloads  maven_resp  Pictures  README.txt  software   t.txtdata  Documents  lib        Music       Public    shell       Templates  Videos[hadoop@hadoop000 ~]$ cd app[hadoop@hadoop000 app]$ lshadoop-2.6.0-cdh5.15.1  hive-1.1.0-cdh5.15.1  jdk1.8.0_241  tmp[hadoop@hadoop000 app]$ cd jdk1.8.0_241/[hadoop@hadoop000 jdk1.8.0_241]$ pwd/home/hadoop/app/jdk1.8.0_241</code></pre><p>可以看到我的jdk已经解压到app目录了，路径是<strong>/home/hadoop/app/jdk1.8.0_241</strong></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p><strong>配置环境变量</strong></p><p>编辑环境变量文件</p><pre><code class="bash">vim ~/.bash_profile</code></pre><p>找个地方，添加下面这段</p><pre><code class="bash">export JAVA_HOME=/home/hadoop/app/jdk1.8.0_241export PATH=$JAVA_HOME/bin:$PATH</code></pre><p><img src="https://i.loli.net/2020/03/04/FZrAkKRNPIL71XT.png" srcset="/img/loading.gif" alt=""></p><p>使环境变量生效</p><pre><code class="bash"> source ~/.bash_profile</code></pre><p>使用java命令，验证生效情况</p><pre><code class="bash">java</code></pre><p><img src="https://i.loli.net/2020/03/04/P3ncaNAEDtiUqrb.png" srcset="/img/loading.gif" alt=""></p><p>出现，如图所示情况，安装成功😀</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在配置环境变量的时候，一般网上都是</p><pre><code class="bash">vim /etc/profile</code></pre><p>而我的是<strong>.bash_profile</strong>，这两者的区别再去</p><p><strong>/etc/profile：</strong>这个配置文件是对<strong>所有系统用户</strong>生效</p><p><strong>.bash_profile：</strong>这个配置文件是对<strong>当前登录</strong>生效</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node安装与配置</title>
    <link href="undefined2020/01/23/Node%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>2020/01/23/Node%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Node环境搭建"><a href="#Node环境搭建" class="headerlink" title="Node环境搭建"></a>Node环境搭建</h1><p>简单的说，node就是一个前端程序员看后端不爽，用<strong>JavaScript</strong>写出来的后端。</p><p><strong>下载地址：</strong></p><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a></p><p><img src="https://i.loli.net/2020/01/29/4iNUcfwOZk7qVxQ.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-20-25.png"></p><p>选择自己系统对应的版本下载，然后一键安装，小白看教程：</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></p><p>打开<strong>CMD</strong>，输入<strong>node -v</strong>和<strong>npm -v</strong>，如果显示了版本，则安装完成</p><p><img src="https://i.loli.net/2020/01/29/GU8cF6YdOTePqiL.png" srcset="/img/loading.gif" alt="Photo_2020-01-21_18-50-27.png"></p><h2 id="Node配置"><a href="#Node配置" class="headerlink" title="Node配置"></a>Node配置</h2><p>这里node的配置主要是配置<strong>npm</strong>，简单来说<strong>npm</strong>就相当于<strong>Java中的Maven</strong>，或者说它就是前端开发中的Maven</p><h3 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>node也和Maven一样有着默认镜像，默认镜像访问速度较慢，下面是它原本的镜像</p><pre><code class="bash">npm get registry //获取镜像</code></pre><p><img src="http://ww1.sinaimg.cn/large/007SzKTZgy1gb6amm6wulj30d6065jr9.jpg" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-37-07.png"></p><p>我们要将默认镜像切换为淘宝镜像</p><pre><code class="bash">npm config set registry https://registry.npm.taobao.org        //设置镜像</code></pre><p><img src="https://i.loli.net/2020/01/29/iGoHaKL9YCnPFBM.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-40-17.png"></p><p>上面已经切换成淘宝镜像了，如果想国内镜像和国外镜像一起使用的也可以，通过<strong>cnpm</strong></p><pre><code class="bash">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>这样以后使用，<strong>cnpm i <model_name></strong>就是使用国内镜像，<strong>npm i <model_name></strong>就是使用默认镜像</p><h3 id="npm仓库地址"><a href="#npm仓库地址" class="headerlink" title="npm仓库地址"></a>npm仓库地址</h3><p>npm库拉到本地后，会默认存在你的<strong>C盘</strong>，占C盘空间</p><h4 id="1-新建node-global和node-cache"><a href="#1-新建node-global和node-cache" class="headerlink" title="1.新建node_global和node_cache"></a>1.新建node_global和node_cache</h4><ul><li><strong>node_globa</strong>为npm的全局安装路径，类似maven仓库地址</li><li><strong>node_cache</strong>为缓存路径</li></ul><p>一般我习惯在我的nodejs安装目录下新建，如果你想放别的地方也可以</p><p><img src="https://i.loli.net/2020/01/29/mzUkENQTleAZpu3.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-53-07.png"></p><h4 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h4><p>打开<strong>此电脑=&gt;属性=&gt;高级系统设置=&gt;环境变量</strong></p><p><img src="https://i.loli.net/2020/01/29/FKaE7kC2lp6UxRz.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-59-38.png"></p><p>新建系统变量<strong>NODE_PATH</strong>，填写新建的<strong>node_global</strong>的路径</p><p><img src="https://i.loli.net/2020/01/29/e1gQ7RcKPo3SYfE.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-04-54.png"></p><p>然后配置<strong>用户变量-&gt;Path</strong>，加入<strong>%NODE_PATH%</strong></p><p><img src="https://i.loli.net/2020/01/29/ET2BuDXCVY8Oh5S.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-10-35.png"></p><h4 id="3-设置全局"><a href="#3-设置全局" class="headerlink" title="3.设置全局"></a>3.设置全局</h4><p>打开cmd，输入命令：</p><pre><code class="bash">npm config set prefix &quot;F:\Node\node_global&quot;npm config set cache &quot;F:\Node\node_cache&quot;</code></pre><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><p>我们全局安装一下常用的<strong>express</strong>模块试一下</p><pre><code class="bash">npm install express -g</code></pre><p><img src="https://i.loli.net/2020/01/29/muvyVU29Jz5HjOA.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-17-10.png"></p><p>可以看到在node_global文件夹出现了express，配置完成😀</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端技术</tag>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础：集合</title>
    <link href="undefined2019/12/04/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"/>
    <url>2019/12/04/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础：集合"><a href="#Java基础：集合" class="headerlink" title="Java基础：集合"></a>Java基础：集合</h1><p>JAVA的集合类被定义在Java.util包中，主要有4种集合，分别为<strong>List、Queue、Set、Map</strong>，每种集合的具体分类如图：</p><p><img src="https://i.loli.net/2019/12/04/XAyEQ4fDdN35sCz.png" srcset="/img/loading.gif" alt=""></p><h2 id="List：加强版数组"><a href="#List：加强版数组" class="headerlink" title="List：加强版数组"></a>List：加强版数组</h2><h3 id="1-ArrayList：基于数组实现，增删慢，查询快，线程不安全"><a href="#1-ArrayList：基于数组实现，增删慢，查询快，线程不安全" class="headerlink" title="1.ArrayList：基于数组实现，增删慢，查询快，线程不安全"></a>1.ArrayList：基于数组实现，增删慢，查询快，线程不安全</h3><p>因为是基于数组实现，所以当需要<strong>插入</strong>或<strong>删除</strong>一个节点时，需要移动其他所有节点，代价较高，因此，ArrayList不适合更新操作。</p><p>ArrayList不需要定义数组长度，在默认长度（默认长度为10）不够时，ArrayList会创建一个新的更大数组并将已有的数据复制到新数组中，通过调用一个native方法<strong>System.arraycopy</strong>实现</p><h3 id="2-Vector-基于数组实现，增删慢，查询快，线程安全"><a href="#2-Vector-基于数组实现，增删慢，查询快，线程安全" class="headerlink" title="2.Vector: 基于数组实现，增删慢，查询快，线程安全"></a>2.Vector: 基于数组实现，增删慢，查询快，线程安全</h3><p>Vector的数据结构与ArrayList一样，都是基于数组实现，不同的是Vector支持线程同步，以保证多线程环境下数据的一致性，但由于频繁的加锁和释放锁操作，Vector整体独写效率比ArrayList低。</p><h3 id="3-LinkedList-基于双向链表实现，增删快，查询慢，线程不安全"><a href="#3-LinkedList-基于双向链表实现，增删快，查询慢，线程不安全" class="headerlink" title="3.LinkedList: 基于双向链表实现，增删快，查询慢，线程不安全"></a>3.LinkedList: 基于双向链表实现，增删快，查询慢，线程不安全</h3><p>LinkedList采用双向链表结构存储元素，在对LinkedList插入和删除时，只需要将上一个节点的指针指向要操作的节点即可，数据改动较小，因此更新效率高。但对LinkedList进行访问时，需要从链表头部一直遍历到需要访问的节点，因此查询的效率很慢。除此之外，LinkedList还定义了用于<strong>操作链表头和尾部</strong>的元素，因此有时可以当作堆栈、队列和双向队列使用。</p><h2 id="Map-键值对"><a href="#Map-键值对" class="headerlink" title="Map: 键值对"></a>Map: 键值对</h2><h3 id="1-HashMap：数组-链表实现，线程不安全"><a href="#1-HashMap：数组-链表实现，线程不安全" class="headerlink" title="1.HashMap：数组 + 链表实现，线程不安全"></a>1.HashMap：数组 + 链表实现，线程不安全</h3><p>HashMap基于键的HashCode值唯一标识一条数据，同时<strong>基于HashCode进行数据的存取</strong>，因此可以快速更新和查找数据，但遍历顺序不保证一样，HashMap的key和valu允许为null.</p><p>HashMap不是线程安全的，如果同一时刻多个线程操作HashMap会导致数据不一致，使HashMap造成环形链表。如果需要线程安全可以使用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或使用ConcurrentHashMap.</p><p>HashMap的结构如图所示，</p><p><img src="https://i.loli.net/2019/12/10/aEwPsmeXMQuCp2y.png" srcset="/img/loading.gif" alt=""></p><p>其内部是一个<strong>数组</strong>，数组中的<strong>每个元素都是一个单向链表</strong>，链表中的每个元素都是Node类实例，Node类包含4个属性：<strong>key、value、hash和用于指向下一个元素的next</strong></p><pre><code class="JAVA">    /**     * 初始化数组容量，默认为16，可以扩容，扩容后数组大小为当前的两倍，该值使用为2^n次方     */    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16    transient Node&lt;K,V&gt;[] table;    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;    }</code></pre><p>HashMap在查找数据时，根据HashMap的Hash值可以快速定位到数组下标，但是我们在找到数组下标后需要对链表进行遍历直到找到需要的数据，时间复杂度为O(n).</p><p>为了减小俩表遍历的开销，Java8对HashMap进行了优化，将数据结构修改为<strong>数组+链表或红黑树</strong>。在链表中元素<strong>超过8</strong>后，HashMap会将链表转为红黑树结构以提高查询效率，因此其时间复杂度为O(logN)。如图</p><p><img src="https://i.loli.net/2019/12/10/voKyxMumfpiF6zt.png" srcset="/img/loading.gif" alt=""></p><pre><code class="JAVA">    /**     * 使用树的阈值，如果链表长度超过此值，则链表转为红黑树     */    static final int TREEIFY_THRESHOLD = 8;    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {        TreeNode&lt;K,V&gt; parent;          TreeNode&lt;K,V&gt; left;        TreeNode&lt;K,V&gt; right;        TreeNode&lt;K,V&gt; prev;        boolean red;    }</code></pre><h3 id="2-ConcurrentHashMap：分段锁实现，线程安全"><a href="#2-ConcurrentHashMap：分段锁实现，线程安全" class="headerlink" title="2.ConcurrentHashMap：分段锁实现，线程安全"></a>2.ConcurrentHashMap：分段锁实现，线程安全</h3><p>在<strong>JDK1.7</strong>中，ConcurrentHashMap采用<strong>分段锁</strong>的思想实现并发操作，因此是线程安全的。ConcurrentHashMap由多个Segment组成（Segment的数量也是锁的并发度），每个Segment都继承自<strong>ReentrantLock</strong>并单独加锁，所以每次进行加锁操作时锁住的都是一个Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。如图，所示：</p><p><img src="https://i.loli.net/2019/12/11/JrMAnaPEy461kmj.png" srcset="/img/loading.gif" alt=""></p><p>在<strong>JDK1.8</strong>中，抛弃了Segment分段锁机制，利用<strong>CAS+Synchronized</strong>，数据结构采用<strong>数组 + 链表 + 红黑树</strong></p><h3 id="3-HashTable：线程安全"><a href="#3-HashTable：线程安全" class="headerlink" title="3.HashTable：线程安全"></a>3.HashTable：线程安全</h3><p>HashTable是遗留类，很多映射的常用功能都与HashMap类似，不同的是它继承自<strong>Dictionary</strong>类，并且是线程安全的，同一时刻只能有一个线程能写HashTable，并发性不如ConcurrentHashMap。</p><h3 id="4-TreeMap：基于二叉树数据结构"><a href="#4-TreeMap：基于二叉树数据结构" class="headerlink" title="4.TreeMap：基于二叉树数据结构"></a>4.TreeMap：基于二叉树数据结构</h3><p>TreeMap基于二叉树数据结构存储数据，同时实现了<strong>SortedMap</strong>接口，以保障元素的顺序存储，默认按键值的升序排序，也可以自定义排序比较器。</p><p>TreeMap常用于实现排序的映射列表。在使用TreeMap时其key必须实现Comparable接口或采用自定义比较器，否则会抛出java.lang.ClassCastException异常</p><h3 id="5-LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序"><a href="#5-LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序" class="headerlink" title="5.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序"></a>5.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序</h3><p>LinkedHashMap是HashMap的子类，其内部使用链表保存元素的插入顺序，在通过Iterator遍历LinkedHashMap时，会按照元素的插入顺序访问元素。</p><h2 id="Set：不可重复"><a href="#Set：不可重复" class="headerlink" title="Set：不可重复"></a>Set：不可重复</h2><p>Set的核心是<strong>独一无二</strong>的性质，适用于存储无序且值不相等的元素。</p><h3 id="1-HashSet：HashMap实现，无序"><a href="#1-HashSet：HashMap实现，无序" class="headerlink" title="1.HashSet：HashMap实现，无序"></a>1.HashSet：HashMap实现，无序</h3><p><strong>HashSet是基于HashMap实现的</strong>，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个<strong>private static final Object PRESENT = new Object();。</strong>HashSet跟HashMap一样，都是存放链表的数组。</p><pre><code class="java">public class HashSet&lt;E&gt;    extends AbstractSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable{    static final long serialVersionUID = -5024744406713321676L;    private transient HashMap&lt;E,Object&gt; map;    private static final Object PRESENT = new Object();    public HashSet() {        map = new HashMap&lt;&gt;();    }    public boolean add(E e) {        return map.put(e, PRESENT)==null;    }    ....}</code></pre><h3 id="2-TreeSet：二叉树实现"><a href="#2-TreeSet：二叉树实现" class="headerlink" title="2.TreeSet：二叉树实现"></a>2.TreeSet：二叉树实现</h3><p><strong>TreeSet是基于TreeMap实现</strong>，和HashSet类似</p><pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{    private transient NavigableMap&lt;E,Object&gt; m;    private static final Object PRESENT = new Object();    public TreeSet() {        this(new TreeMap&lt;E,Object&gt;());    }    public boolean add(E e) {        return m.put(e, PRESENT)==null;    }}</code></pre><p>可以自定义排序方法</p><pre><code class="java">Set&lt;String&gt; treeSet = new TreeSet(Comparator.comparing(String::length));</code></pre><p>如果是自定义数据类型，必须<strong>实现Comparable接口</strong>。并<strong>覆写compareTo函数</strong>。</p><h3 id="3-LinkedHashSet：数据插入顺序和遍历数据一样"><a href="#3-LinkedHashSet：数据插入顺序和遍历数据一样" class="headerlink" title="3.LinkedHashSet：数据插入顺序和遍历数据一样"></a>3.LinkedHashSet：数据插入顺序和遍历数据一样</h3><p> <strong>LinkedHashSet继承了HashSet</strong>，所有的操作都与HashSet一样，底层使用<strong>LinkedHashMap存储元素</strong></p><pre><code class="java">public class LinkedHashSet&lt;E&gt;    extends HashSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {     public LinkedHashSet(int initialCapacity, float loadFactor) {        super(initialCapacity, loadFactor, true);    }     public LinkedHashSet(int initialCapacity) {        super(initialCapacity, .75f, true);    }     public LinkedHashSet() {        super(16, .75f, true);    }}</code></pre><p>这里神奇的是，LinkedHashSet创建对象却是在HashSet里</p><pre><code class="java">    HashSet(int initialCapacity, float loadFactor, boolean dummy) {        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);    }</code></pre><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>用的不是很多，所以不详细说明</p><ul><li><p><strong>ArrayBlockingQueue：</strong>基于数组数据结构实现的有界阻塞队列</p></li><li><p><strong>LinkedBlockingQueue：</strong>基于链表数据结构实现的有界阻塞队列</p></li><li><p><strong>PriorityBlockingQueue：</strong>支持优先级排序的无界队列</p></li><li><p><strong>DelayQueue：</strong>支持延迟操作的无界阻塞队列</p></li><li><p><strong>SynchronousQueue：</strong>用于线程同步的阻塞队列</p></li><li><p><strong>LinkedTransferQueue：</strong>基于链表数据结构实现的无界阻塞队列</p></li><li><p><strong>LinkedBlockingDeque：</strong>基于链表数据结构实现的双向阻塞队列</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题(一)</title>
    <link href="undefined2019/11/17/%E9%9D%A2%E8%AF%95-1/"/>
    <url>2019/11/17/%E9%9D%A2%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>我一个好朋友，在BOSS上投简历收到了面试邀请，这是他面试回来说的面试题，我整理了一下并查了答案，以免自己去面试的时候不会</p><p>下面是面试问题：</p><blockquote><p>1.JAVA数据类型以及所占字节</p><p>2.手写三个单例模式</p><p>3.ArrayList与LinkList区别</p><p>4.HashSet原理</p><p>5.常用的Linux命令</p><p>6.JAVA反射机制</p><p>7.手画一个线程状态图</p><p>8.手写三个线程交替打印ABC</p><p>9.什么是TCP三次握手，为什么四次挥手断开连接，为什么</p><p>10.手写一个冒泡算法</p><p>11.SpringMVC是怎么运行的？</p><p>12.索引类型及作用</p></blockquote><p>下面面试答案：</p><h2 id="1-JAVA数据类型及所占字节"><a href="#1-JAVA数据类型及所占字节" class="headerlink" title="1.JAVA数据类型及所占字节"></a>1.JAVA数据类型及所占字节</h2><pre><code class="java">整型:  byte--1字节    short--2字节    int--4字节    long--8字节浮点型:  float--4字节    double--8字节字符型:  char--2字节布尔型:  boolean--1字节</code></pre><h2 id="2-单例模式的三种实现"><a href="#2-单例模式的三种实现" class="headerlink" title="2.单例模式的三种实现"></a>2.单例模式的三种实现</h2><pre><code class="JAVA">/*** 1.懒汉式,默认不实例化，什么时候用什么时候创建对象* 优点：懒加载启动快，资源占用小，使用时才实例化，无锁。* 缺点：非线程安全。*/public class Singleton{    private static Singleton instance;    private Singleton(){}    public static synchronized Singleton getInstance(){        if(instance == null){            instance = new Singleton();        }        return instance;    }}/** 2.饿汉式，类加载的时候就实例化* 优点：饿汉模式天生是线程安全的，使用时没有延迟。* 缺点：启动时即创建实例，启动慢，有可能造成资源浪费。*/public class Singleton{    private Singleton(){}    private static final Singleton singleton = new Singleton();    public static Singleton getInstance(){        return singleton;    }}/** 3.静态内部类* 优点：将懒加载和线程安全完美结合的一种方式（无锁）。（推荐）*/public class Singleton{    private Singleton(){}    public static final Singleton getInstance(){        return SingletonHolder.INSTANCE;    }    private static class SingletonHolder{        private static final Singleton INSTANCE = new Singleton();    }}</code></pre><h2 id="3-ArrayList和LinkList的区别"><a href="#3-ArrayList和LinkList的区别" class="headerlink" title="3.ArrayList和LinkList的区别"></a>3.ArrayList和LinkList的区别</h2><pre><code class="JAVA">ArrayList是基于数组实现的，查询快，更新慢。LinkList是基于链表实现的，插入，删除快，查询慢</code></pre><h2 id="4-HashSet原理"><a href="#4-HashSet原理" class="headerlink" title="4.HashSet原理"></a>4.HashSet原理</h2><pre><code class="JAVA">HashSet实现Set接口，由一个HashMap实例支持。不保证set的迭代顺序;不保证舒徐恒久不变。此类允许使用nullprivate transient HashMap&lt;E,Object&gt; map;  //map集合，HashSet存放元素的容器private static final Object PRESENT = new Object(); //map，中键对应的value值</code></pre><h2 id="5-常用的Linux命令"><a href="#5-常用的Linux命令" class="headerlink" title="5.常用的Linux命令"></a>5.常用的Linux命令</h2><pre><code class="bash">ll ls cd pwd mkdir touch rm -rf grep less</code></pre><h2 id="6-JAVA反射机制"><a href="#6-JAVA反射机制" class="headerlink" title="6.JAVA反射机制"></a>6.JAVA反射机制</h2><pre><code class="java">java反射机制是指在运行时，对任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取对象信息及动态调用方法的功能称为JAVA反射机制。通过Class.forName(包名.类名)获得类对象Class，通过操作Class对象达到运行时操作类</code></pre><h2 id="7-手画一个线程状态图"><a href="#7-手画一个线程状态图" class="headerlink" title="7.手画一个线程状态图"></a>7.手画一个线程状态图</h2><pre><code class="java">线程有五个状态：新建态(new)、就绪态(runnable)、运行态(running)、阻塞态(blocked)、死亡态(dead)</code></pre><p><img src="https://images2017.cnblogs.com/blog/432513/201712/432513-20171214160438717-1661848063.png" srcset="/img/loading.gif" alt=""></p><h2 id="8-手写三个线程交替打印ABC"><a href="#8-手写三个线程交替打印ABC" class="headerlink" title="8.手写三个线程交替打印ABC"></a>8.手写三个线程交替打印ABC</h2><pre><code class="java">/*** 主要考察的使是线程间的同步唤醒操作，线程的逻辑执行步骤为ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA.......* 要控制线程的执行顺序,就要确定唤醒和等待的顺序,一种解题思路是一个线程持有两个对象锁.一个对象锁是pret即前* * 一个对象所持有的锁,还有一个是自身锁.*/public class SysaAbcThread implements Runnable{    private Object pret;     //上一个锁    private Object self;     //自身锁    private String sout;     //要输出的内容    public SysaAbcThread(Object pret, Object self, String sout) {        super();        this.pret = pret;        this.self = self;        this.sout = sout;    }    @Override    public void run() {        while(true){            synchronized (pret) {     //获取 pret锁                synchronized (self) { //获取 self锁                    System.out.println(sout);                    self.notifyAll();  //释放self锁，唤醒其他线程竞争self锁                }                try {                    pret.wait();      //释放pret锁，休眠等待唤醒                } catch (InterruptedException e) {}            }        }    }    public static void main(String[] args) throws InterruptedException {        Object a = new Object();        Object b = new Object();        Object c = new Object();        SysaAbcThread aThread = new SysaAbcThread(c, a, &quot;A&quot;);        SysaAbcThread bThread = new SysaAbcThread(a, b, &quot;B&quot;);        SysaAbcThread cThread = new SysaAbcThread(b, c, &quot;C&quot;);        /**         * 如果不sleep，则启动顺序会乱         */        new Thread(aThread).start();        Thread.sleep(100);        new Thread(bThread).start();        Thread.sleep(100);        new Thread(cThread).start();        Thread.sleep(100);    }}</code></pre><h2 id="9-什么是TCP三次握手，为什么四次挥手断开连接"><a href="#9-什么是TCP三次握手，为什么四次挥手断开连接" class="headerlink" title="9.什么是TCP三次握手，为什么四次挥手断开连接"></a>9.什么是TCP三次握手，为什么四次挥手断开连接</h2><p><strong>三此握手(Three-way Handshake)是指建立一个TCP连接时</strong>，需要客户端和服务端总共发送三个包。</p><p>三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><ul><li><p>第一次握手(SYN=1,seq=x):   <strong>客户端=&gt;服务端</strong></p><p>客户端发送一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口，以及初始序号X，保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕客户端进入<strong>SYN_SEND</strong>状态。</p></li></ul><ul><li><p>第二次握手(SYN=1,ACK=1,seq=y,ACKnum=x+1):  <strong>服务端=&gt;客户端</strong></p><p>服务器发回确认包(ACK)应答。即SYN标志和ACK标志位均为1。服务器端选择自己的ISN序列号，放到Seq域里，同时将确认序号(Acknowledgement Number)设置为客户端的ISN加1，即X+1。发送完毕后，服务器端进入<strong>SYN_RCVD</strong>状态。</p></li></ul><ul><li><p>第三次握手(ACK=1,ACKnum=y+1)：<strong>客户端=&gt;服务端</strong></p><p>客户端再次发回确认包(ACK)，SYN标志位为0，ACK标志为1，并把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写INS的+1</p><p>发送完毕后，客户端进入<strong>ESTABLISHED</strong>状态，当服务器端接收到这个包时，也进入<strong>ESTABLISHED</strong>状态，TCP握手结束。</p></li></ul><p><strong>四次挥手(Four-Way Wavehand)是指断开一个TCP连接时</strong>，需要客户端和服务端发送四个包确认连接断开。客户端或服务端均可主动发起挥手动作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<strong>FIN_WAIT_1</strong>状态</p></li></ul><ul><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端发送的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<strong>CLOSE_WAIT</strong>状态，客户端接收到这个确认包之后，进入<strong>FIN_WAIT_2</strong>状态，等待服务器关闭连接。</p></li></ul><ul><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN设置为1.</p><p>发送完毕后，服务端进入<strong>LAST_ACK</strong>状态，等待来自客户端的最后一个ACK。</p></li></ul><ul><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收来自服务器端的关闭请求，发送一个确认包，并进入<strong>TIME_WAIT</strong>状态，等待可能出现的要求重传的ACK包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入<strong>CLOSED</strong>状态。</p><p>客户端等待了某个固定时间（两个最大生命周期，2MSL，2 Maximum Segment Lifetime）之后，没收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<strong>CLOSED</strong>状态</p></li></ul><h2 id="10-手写一个冒泡算法"><a href="#10-手写一个冒泡算法" class="headerlink" title="10.手写一个冒泡算法"></a>10.手写一个冒泡算法</h2><pre><code class="java">    public int[] sort(int[] arr){        int length = arr.length;        for(int i=0;i&lt;length;i++){            for(int j=i;j&lt;length;j++){                if(arr[i] &gt; arr[j]){                    int temp = arr[j];                    arr[j] = arr[i];                    arr[i] = temp;                }            }        }        return arr;    }   </code></pre><h2 id="11-SpringMVC是怎么运行的？"><a href="#11-SpringMVC是怎么运行的？" class="headerlink" title="11.SpringMVC是怎么运行的？"></a>11.SpringMVC是怎么运行的？</h2><p>（1）用户发送请求至前端控制器<strong>DispatcherServlet</strong></p><p>（2）<strong>DispatcherServlet</strong>收到请求后，调用<strong>HandlerMapping</strong>处理映射器，请求获取Handle;</p><p>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有就生成)，一并返回给<strong>DispatcherServlet</strong></p><p>（4）<strong>DispatcherServlet</strong>调用<strong>HandlerAdapter</strong>处理适配器</p><p>（5）<strong>HandlerAdapter</strong>经过适配调用具体处理器(Handler，也叫后端控制器)；</p><p>（6）<strong>Handler</strong>执行完成返回<strong>ModelAndView</strong>；</p><p>（7）<strong>HandlerAdapter</strong>将Handler执行结果<strong>ModelAndView</strong>返回给<strong>DispatcherServlet</strong></p><p>（8）<strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>传给<strong>ViewResolver</strong>视图解析器进行解析</p><p>（9）<strong>ViewResolver</strong>解析后返回具体的<strong>view</strong></p><p>（10）<strong>DispatcherServlet</strong>对<strong>View</strong>进行渲染试图</p><p>（11）<strong>DispatcherServlet</strong>响应用户</p><p><img src="https://img-blog.csdn.net/20180708224853769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt=""></p><h2 id="12-索引类型及作用"><a href="#12-索引类型及作用" class="headerlink" title="12.索引类型及作用"></a>12.索引类型及作用</h2><ol><li><strong>主键索引：</strong>数据记录里面不能有null，数据内容不能重复，在一张表里不能有多个主键索引</li><li><strong>普通索引：</strong>使用字段关键字建立索引，提高查询质量</li><li><strong>唯一索引：</strong>字段数据是唯一的，可以为null，在一张表里，是可以添加多个唯一索引</li><li><strong>全文索引：</strong>对文本内容进行分词，进行搜索</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(三):实用指令</title>
    <link href="undefined2019/11/02/Linux-3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>2019/11/02/Linux-3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h3 id="Linux系统的运行级别"><a href="#Linux系统的运行级别" class="headerlink" title="Linux系统的运行级别"></a>Linux系统的运行级别</h3><pre><code class="bash">0:关机  1:单用户(找回丢失密码)2:多用户无网络服务3:多用户有网络服务4:保留5:图形界面6:重启命令 init [0||num]系统运行级别配置文件： /etc/inittab</code></pre><p><img src="https://i.loli.net/2019/10/09/R9DjLcyuoXtGkFI.png" srcset="/img/loading.gif" alt=""></p><h5 id="如何修改已经忘记密码"><a href="#如何修改已经忘记密码" class="headerlink" title="如何修改已经忘记密码"></a>如何修改已经忘记密码</h5><p><img src="https://i.loli.net/2019/10/09/rcNa2gMqbYtGkLe.png" srcset="/img/loading.gif" alt=""></p><p>首先，在进入启动页面的时候按<strong>e</strong>键，然后会进入下面这个页面</p><p><img src="https://i.loli.net/2019/10/09/g4j2GNFevKImaQn.png" srcset="/img/loading.gif" alt=""></p><p>将光标移动到下图那一行</p><p><img src="https://i.loli.net/2019/10/09/8k4sZdrAvRgEVno.png" srcset="/img/loading.gif" alt=""></p><p>在行尾添加 <strong>init=/bin/sh</strong>,</p><p><img src="https://i.loli.net/2019/10/09/LhdHGqYpItZvMAK.png" srcset="/img/loading.gif" alt=""></p><p>添加完，按<strong>Ctrl + X</strong>执行，即可进入单用户模式</p><p><img src="https://i.loli.net/2019/10/09/JBKHTxbWS5dGYIy.png" srcset="/img/loading.gif" alt=""></p><p>然后，就可以<strong>修改密码</strong>了</p><p><img src="https://i.loli.net/2019/10/09/4wbFxDeHrJGKBm8.png" srcset="/img/loading.gif" alt=""></p><p>这里可以看见会字符不可见，你需要输入<strong>LANG=en</strong>，才能让字符可见</p><p><img src="https://i.loli.net/2019/10/09/trswoihHCvd7JGu.png" srcset="/img/loading.gif" alt=""></p><p>最后,执行<strong>exec /sbin/init</strong>即可退出单用户模式</p><p><img src="https://i.loli.net/2019/10/09/gvKOq5eVhc3FwXd.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当你对某个指令不收悉的时候，就可以使用帮助指令</p><h4 id="获得帮助信息"><a href="#获得帮助信息" class="headerlink" title="获得帮助信息"></a>获得帮助信息</h4><ul><li><p>语法</p><pre><code class="bash">man [命令||配置文件]</code></pre></li><li><p>命令演示</p><pre><code class="bash">[root@localhost ~]# man ls</code></pre><p>输入命令按<strong>回车</strong>,</p><p><img src="https://i.loli.net/2019/10/10/AnB285ODQH9RKLf.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>ls加-a可以<strong>显示隐藏文件</strong></p><p><img src="https://i.loli.net/2019/10/10/mNfp1tGsEaX38D9.png" srcset="/img/loading.gif" alt=""></p><p>ls加-l可以以<strong>另外的列表形式显示</strong></p><p><img src="https://i.loli.net/2019/10/10/eOT45wiHoPu6gys.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">[root@localhost home]# ls -a.  ..  crg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><p>命令选项不光可以单个用，也可以连用，</p><pre><code class="bash">[root@localhost home]# ls -la总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy</code></pre><h4 id="help-命令"><a href="#help-命令" class="headerlink" title="help 命令"></a>help 命令</h4><ul><li><p>基本语法</p><pre><code class="bash">help 命令</code></pre></li><li><p>实例演示</p><pre><code class="bash">[root@localhost home]# help cdcd: cd [-L|[-P [-e]]] [dir]    Change the shell working directory.    Change the current directory to DIR.  The default DIR is the value of the    HOME shell variable.    The variable CDPATH defines the search path for the directory containing    DIR.  Alternative directory names in CDPATH are separated by a colon (:).    A null directory name is the same as the current directory.  If DIR begins    with a slash (/), then CDPATH is not used.    If the directory is not found, and the shell option `cdable_vars&#39; is set,    the word is assumed to be  a variable name.  If that variable has a value,    its value is used for DIR.    Options:        -L      force symbolic links to be followed        -P      use the physical directory structure without following symbolic        links        -e      if the -P option is supplied, and the current working directory        cannot be determined successfully, exit with a non-zero status    The default is to follow symbolic links, as if `-L&#39; were specified.    Exit Status:    Returns 0 if the directory is changed, and if $PWD is set successfully when    -P is used; non-zero otherwise.[root@localhost home]# </code></pre></li></ul><hr><h3 id="查看目录类命令"><a href="#查看目录类命令" class="headerlink" title="查看目录类命令"></a>查看目录类命令</h3><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p><strong>这个命令用来显示当前工作的绝对路径</strong></p><pre><code class="bash">[root@localhost ~]# pwd/root[root@localhost ~]# </code></pre><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p><strong>该命令用来查看当前目录的所有内容</strong></p><pre><code class="bash">ls [选项] [目录||文件]</code></pre><pre><code class="bash">[root@localhost home]# lscrg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# ls -al总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p><strong>用于切换目录</strong></p><pre><code class="bash">cd [参数](指定目录)</code></pre><pre><code class="bash">[root@localhost /]# ll总用量 16lrwxrwxrwx.   1 root root    7 9月   4 20:33 bin -&gt; usr/bindr-xr-xr-x.   5 root root 4096 9月   4 20:37 bootdrwxr-xr-x.  20 root root 3220 10月 10 09:01 devdrwxr-xr-x.  75 root root 8192 10月 10 09:01 etcdrwxr-xr-x.   4 root root   27 9月  29 09:45 homelrwxrwxrwx.   1 root root    7 9月   4 20:33 lib -&gt; usr/liblrwxrwxrwx.   1 root root    9 9月   4 20:33 lib64 -&gt; usr/lib64drwxr-xr-x.   2 root root    6 4月  11 2018 mediadrwxr-xr-x.   2 root root    6 4月  11 2018 mntdrwxr-xr-x.   2 root root    6 4月  11 2018 optdr-xr-xr-x. 135 root root    0 10月 10 09:01 procdr-xr-x---.   2 root root  151 10月  9 14:26 rootdrwxr-xr-x.  24 root root  720 10月 10 09:01 runlrwxrwxrwx.   1 root root    8 9月   4 20:33 sbin -&gt; usr/sbindrwxr-xr-x.   2 root root    6 4月  11 2018 srvdr-xr-xr-x.  13 root root    0 10月 10 09:01 sysdrwxrwxrwt.  12 root root  265 10月 10 10:09 tmpdrwxr-xr-x.  13 root root  144 9月  28 15:29 usrdrwxr-xr-x.  19 root root  267 9月   4 20:37 var[root@localhost /]# cd /home[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><hr><h3 id="操作文件类命令"><a href="#操作文件类命令" class="headerlink" title="操作文件类命令"></a>操作文件类命令</h3><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p><strong>用于创建目录</strong></p><pre><code class="bash">mkdir [选项] 要创建的目录-p : 创建多级目录</code></pre><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# mkdir dog[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mkdir /home/animal/catmkdir: 无法创建目录&quot;/home/animal/cat&quot;: 没有那个文件或目录[root@localhost home]# mkdir -p /home/animal/cat[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:46 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost animal]# cd animal[root@localhost animal]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 10 13:46 cat</code></pre><h4 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h4><p><strong>rmdir命令用于删除空目录</strong></p><pre><code class="bash">rmdir [目录]</code></pre><p>删除dog目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir dog[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir animalrmdir: 删除 &quot;animal&quot; 失败: 目录非空</code></pre><p>如果要删除一个<strong>非空的目录</strong>需要用<strong>rm -rf</strong>命令</p><pre><code class="bash">[root@localhost home]# rm -rf animal[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p><strong>创建一个空的文件</strong></p><p>接下来，创建一个Hello.txt</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# touch hello.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:14 hello.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# </code></pre><p><strong>touch</strong>也可以创建多个文件</p><pre><code class="bash">[root@localhost home]# touch sb.txt dl.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:15 dl.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy-rw-r--r--. 1 root root  0 10月 10 15:15 sb.txt[root@localhost home]# </code></pre><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p><strong>拷贝文件到指定目录</strong></p><pre><code class="bash">cp [选项] [待拷贝文件] [拷贝目标]-r: 拷贝整个文件夹</code></pre><p>接下来,将a.txt<strong>拷贝到</strong>aaa目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:23 aaa-rw-r--r--. 1 root root  0 10月 10 15:23 a.txtdrwxr-xr-x. 2 root root  6 10月 10 15:25 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# cp a.txt aaa[root@localhost home]# cd aaa[root@localhost aaa]# ll总用量 0-rw-r--r--. 1 root root 0 10月 10 15:23 a.txt[root@localhost aaa]# </code></pre><p>如果，要将aaa目录拷贝到bbb目录下，</p><pre><code class="bash">[root@localhost home]# cp aaa bbbcp: 略过目录&quot;aaa&quot;[root@localhost home]# </code></pre><p>会提示一个错误，略过目录”aaa”，这个时候就需要加入选项<strong>-r</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbb[root@localhost home]# cd bbb[root@localhost bbb]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:29 aaa[root@localhost bbb]# </code></pre><p>如果，再复制一次，会提示要不要覆盖，如果默认要覆盖可以使用<strong>\cp</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbbcp：是否覆盖&quot;bbb/aaa/a.txt&quot;？ y[root@localhost home]# /cp -r aaa bbb-bash: /cp: 没有那个文件或目录[root@localhost home]# \cp -r aaa bbb[root@localhost home]# </code></pre><p>这里注意是<strong>\cp</strong>，不仔细的话容易弄反</p><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p><strong>用于移除文件或目录</strong></p><pre><code class="bash">rm [文件||目录]-r : 递归删除整个文件夹-f : 强制删除不提示</code></pre><p>删除<strong>/home/a.txt</strong>，</p><pre><code class="bash">[root@localhost home]# rm a.txtrm：是否删除普通空文件 &quot;a.txt&quot;？y[root@localhost home]# </code></pre><p>删除<strong>/home/aaa</strong></p><pre><code class="bash">[root@localhost aaa]# rm /home/aaarm: 无法删除&quot;/home/aaa&quot;: 是一个目录[root@localhost aaa]# rm -r /home/aaarm：是否进入目录&quot;/home/aaa&quot;? yrm：是否删除普通空文件 &quot;/home/aaa/a.txt&quot;？yrm：是否删除目录 &quot;/home/aaa&quot;？y[root@localhost aaa]# </code></pre><p>这里可以看出如果要删除目录，要对目录下所有文件确认是否删除，非常麻烦，所以，如果不想提示，加上<strong>-f</strong>命令强制删除<strong>/home/bbb</strong>，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 15:29 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rm -rf /home/bbb/[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p><strong>mv指令用于移动文件或重命名</strong></p><pre><code class="bash">重命名 ： mv oldNameFile newNameFile移动 ： mv /oldPath /newPath</code></pre><p>接下来，我们将<strong>/home/aaa.txt</strong>重命名为<strong>sz.txt</strong></p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root  6 10月 11 09:26 aaa.txtdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mv aaa.txt sz.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# </code></pre><p>然后，将sz.txt移动到<strong>crg</strong>目录里面，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# mv /home/sz.txt/ /home/crg/[root@localhost home]# ll总用量 0drwx------. 3 crg dw 76 10月 11 09:34 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# cd crg[root@localhost crg]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 11 09:26 sz.txt[root@localhost crg]# </code></pre><hr><h3 id="查看文件类命令"><a href="#查看文件类命令" class="headerlink" title="查看文件类命令"></a>查看文件类命令</h3><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p><strong>用来查看文件内容，以只读的方式</strong></p><pre><code class="bash">cat [选项] [目标文件]</code></pre><p>用cat的方式查看<strong>/etc/profile</strong></p><pre><code class="bash">[root@localhost ~]# cat /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091155.png" srcset="/img/loading.gif" alt=""></p><p>这里可以查看，但没有行号，我们给他设定一个行号,加上选项<strong>-n</strong></p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091429.png" srcset="/img/loading.gif" alt=""></p><p>但是，cat命令每次都会直接跑到文件末尾，让你看不清，所以，一般还会给和<strong>| more</strong>连用，</p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile | more</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091759.png" srcset="/img/loading.gif" alt=""></p><p><strong>| more</strong>用来<strong>分页显示</strong>，按<strong>空格</strong>看下一页</p><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p><strong>more命令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件内容</strong></p><p>用<strong>more命令</strong>查看文件,</p><pre><code class="bash">[root@localhost ~]# more /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095423.png" srcset="/img/loading.gif" alt=""></p><p>快捷键,</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095608.png" srcset="/img/loading.gif" alt=""></p><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><p><strong>less命令和more命令类似，但它功能更强大，不会将整个文件加载完后再显示，比more效率更高，一般用于查看大型文件</strong></p><p>接下来，用less命令查看<strong>/etc/services</strong></p><pre><code class="bash">[root@localhost etc]# less /etc/services</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/1570846827372.png" srcset="/img/loading.gif" alt=""></p><p>可以看出，它只加载了这么多就不往下显示了，</p><p><strong>less快捷键：</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012102549.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(二):用户管理</title>
    <link href="undefined2019/11/02/Linux-2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>2019/11/02/Linux-2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h3 id="Linux用户基本介绍"><a href="#Linux用户基本介绍" class="headerlink" title="Linux用户基本介绍"></a>Linux用户基本介绍</h3><blockquote><p> Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 </p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录</p></blockquote><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927160228.png" srcset="/img/loading.gif" alt=""></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code class="bash">useradd [选项] 用户名</code></pre><p>接下来，添加一个用户 dl</p><pre><code class="bash">[root@localhost ~]# useradd dl</code></pre><p>可能界面看不出什么效果，其实系统已经创建了一个叫<strong>dl的用户</strong>并创建了同名的<strong>组</strong>和 <strong>/home/dl目录</strong></p><pre><code class="bash">[root@localhost /]# cd /home/[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 lj lj 83 9月   5 09:02 lj</code></pre><p>如果你不想创建在<strong>home目录</strong>下，你还可以将<strong>用户</strong>创建在其他目录，这里我想将用户创建在<strong>/home/sb/#</strong></p><pre><code class="bash">[root@localhost home]# mkdir sb[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwxr-xr-x. 2 root root  6 9月  28 08:54 sb</code></pre><p>此时目录已经创建完毕，接着输入命令：</p><pre><code class="bash">[root@localhost home]# useradd -d /home/sb/ qyuseradd：警告：此主目录已经存在。不从 skel 目录里向其中复制任何文件。正在创建信箱文件: 文件已存在</code></pre><p>然后，给用户<strong>dl</strong>和<strong>qy</strong>设置密码:</p><pre><code class="bash">[root@localhost home]# passwd dl更改用户 dl 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@localhost home]# passwd qy更改用户 qy 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。</code></pre><p>这里我两个用户密码都设置为：<strong>12345678</strong>,就算系统提示为通过字典检查，只要你无视它，接着输入<strong>密码</strong>，还是会设置成功，然后我使用<strong>SmarTTY</strong> 登录用户 <strong>dl</strong>和<strong>qy</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928094858.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928102011.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><h5 id="1-删除用户，但保留目录"><a href="#1-删除用户，但保留目录" class="headerlink" title="1.删除用户，但保留目录"></a>1.删除用户，但保留目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 qy qy 62 9月  28 13:48 qy[root@localhost home]# userdel qy //执行删除[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwx------. 2 1002 1002 62 9月  28 13:48 qy</code></pre><h5 id="2-删除用户和目录"><a href="#2-删除用户和目录" class="headerlink" title="2.删除用户和目录"></a>2.删除用户和目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  28 14:19 dldrwx------. 2 qy qy 62 9月  28 14:19 qy[root@localhost home]# userdel -r dl  //执行删除[root@localhost home]# ll总用量 0drwx------. 2 qy qy 62 9月  28 14:19 qy</code></pre><hr><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><pre><code>id  [用户名]</code></pre><pre><code class="bash">[root@localhost home]# id rootuid=0(root) gid=0(root) 组=0(root)[root@localhost home]# id qyuid=1001(qy) gid=1001(qy) 组=1001(qy)[root@localhost home]# </code></pre><hr><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre><code>su [用户名]</code></pre><pre><code class="bash">[root@localhost ~]# su qy[qy@localhost root]$ su root密码：[root@localhost ~]# </code></pre><p>这是一种从<strong>低权限用户</strong>切换到<strong>高权限用户</strong>的方法，</p><p>还有一种</p><pre><code class="bash">[qy@localhost /]$ exitexit[root@localhost ~]# </code></pre><p>直接<strong>exit</strong>，这样就避免了输密码</p><hr><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h5 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h5><pre><code class="bash">groupadd [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupadd dang[root@localhost ~]# </code></pre><h5 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h5><pre><code class="bash">groupdel [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupdel dang[root@localhost ~]# </code></pre><h5 id="增加用户直接加上组"><a href="#增加用户直接加上组" class="headerlink" title="增加用户直接加上组"></a>增加用户直接加上组</h5><pre><code class="bash">useradd -g [组] [用户名]</code></pre><p>增加一个用户crg，分组到zf</p><pre><code class="bash">[root@localhost ~]# useradd -g zf crguseradd：“zf”组不存在[root@localhost ~]# groupadd zf[root@localhost ~]# useradd -g zf crg[root@localhost ~]# id crguid=1002(crg) gid=1002(zf) 组=1002(zf)</code></pre><p>这里我原本以为直接用命令，系统会自动帮我建组，看来我想多了😭，必须你自己建个组，然后再分组</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg zf 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><pre><code class="bash">usermod -g [用户组] [用户名]</code></pre><pre><code class="bash">[root@localhost home]# groupadd dw[root@localhost home]# usermod -g dw crg[root@localhost home]# id crguid=1002(crg) gid=1003(dw) 组=1003(dw)</code></pre><p>这样我们就把<strong>crg</strong>从<strong>zf组</strong>调到<strong>dw组</strong></p><hr><h3 id="用户的配置文件"><a href="#用户的配置文件" class="headerlink" title="用户的配置文件"></a>用户的配置文件</h3><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190929105530.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009095520.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">crg: 用户名x: 加密的密码 真正的密码在 shadow文件里1002: 用户id1003: 组id/home/crg: 用户所在home目录/bin/bash：对应的shell</code></pre><h5 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009100032.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009140544.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">dw: 组名1003: 组id</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(一):vim与vi</title>
    <link href="undefined2019/11/02/Linux-1-vim%E4%B8%8Evi/"/>
    <url>2019/11/02/Linux-1-vim%E4%B8%8Evi/</url>
    
    <content type="html"><![CDATA[<h1 id="vim与vi"><a href="#vim与vi" class="headerlink" title="vim与vi"></a>vim与vi</h1><h3 id="什么是vim？"><a href="#什么是vim？" class="headerlink" title="什么是vim？"></a>什么是vim？</h3><blockquote><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p></blockquote><h3 id="vi和vim的三种模式转化图如下"><a href="#vi和vim的三种模式转化图如下" class="headerlink" title="vi和vim的三种模式转化图如下:"></a>vi和vim的三种模式转化图如下:</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtbszrfgj30ik0a4whj.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><pre><code class="linux">[root@localhost ~]# ll总用量 4-rw-------. 1 root root 1416 9月   4 20:36 anaconda-ks.cfg[root@localhost ~]# </code></pre><p>可以看出我没有Hello.java文件</p><p>使用命令</p><pre><code class="linux">[root@localhost ~]# vim Hello.java</code></pre><p>随后进入一般模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1dy0j2nj30lf0tb3yo.jpg" srcset="/img/loading.gif" alt=""></p><p>此时还不能编辑，如果要编辑 需要按  <strong>Insert</strong> 或 按 <strong>i</strong> ，进入编辑模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1gyfv0bj30ho0a5q2v.jpg" srcset="/img/loading.gif" alt=""></p><p>当左下角出现<strong>插入</strong>的时候才能开始编辑，如图</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1jlvw60j30ib04i3ys.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，如果要保存</p><blockquote><p><strong>Shift + ; + wq</strong>(wq是 写入(wirte)并退出(queit))</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1mqs047j303p03gmwz.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>:q!</strong>是不保存退出</p><h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtnweqdbj30q90f0gr2.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="1-拷贝"><a href="#1-拷贝" class="headerlink" title="1. 拷贝"></a>1. 拷贝</h5><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dubycqkbj307105zt8s.jpg" srcset="/img/loading.gif" alt=""></p><p>首先插入一些字符,随后按<strong>ESC</strong>进入<strong>命令模式</strong>，选定一行按<strong>yy</strong>，之后按<strong>p</strong>，按一次<strong>P</strong>，粘贴一次</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7duf1mpdzj3063071dft.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，将<strong>光标</strong>移动到第一行，并按<strong>5yy</strong>（Linux的所有数字都是大键盘上的，小键盘的数字会产生其他效果）,随后按<strong>P</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dulepza4j308b02g744.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dumcpa0bj30530bajrl.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h5><p>和拷贝语法类似，我们用<strong>5dd</strong>删除五行</p><p>效果如下:</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dusx4k7gj304406gdfu.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h5><p>进入<strong>命令模式</strong>，输入<strong>/ + [关键字] + 回车</strong>即可查询,按<strong>N</strong>查找下一个</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv1j36y1j303w01ft8h.jpg" srcset="/img/loading.gif" alt=""></p><p>这里要注意Linux的查找字符是<strong>严格区分大小写</strong>的，我这里小写的sbdl就没匹配到😭</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv20n1r3j305u0ag74k.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="4-设置行号"><a href="#4-设置行号" class="headerlink" title="4.设置行号"></a>4.设置行号</h5><p>例行进入<strong>命令模式</strong>，输入 <strong>:set nu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvy3a60vj304o02e3yc.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvygdj6ej307008xq37.jpg" srcset="/img/loading.gif" alt=""></p><p>取消，行号<strong>:set nonu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzjksdfj305r023t8i.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzwzaktj3049081jrj.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="5-行尾和行首"><a href="#5-行尾和行首" class="headerlink" title="5.行尾和行首"></a>5.行尾和行首</h5><pre><code>[root@localhost ~]# vim /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>Shift + g</strong>，进入行尾</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145504.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>gg</strong>回到行首</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><h5 id="6-撤消"><a href="#6-撤消" class="headerlink" title="6.撤消"></a>6.撤消</h5><p>在<strong>编辑模式</strong>下乱输字符</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145915.png" srcset="/img/loading.gif" alt=""></p><p>随后,按<strong>ESC</strong>进入<strong>正常模式</strong>按<strong>u</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927150026.png" srcset="/img/loading.gif" alt=""></p><h5 id="7-移动光标"><a href="#7-移动光标" class="headerlink" title="7.移动光标"></a>7.移动光标</h5><p>第一步：进入<strong>编辑模式</strong>，设置行号， <strong>:set nu</strong></p><p>第二步：进入<strong>正常模式</strong>，输入你要去的行数  10 + <strong>Shift + g</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927153646.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>