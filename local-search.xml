<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LJ理光打印机维修手册</title>
    <link href="undefined2020/04/18/LJ%E7%90%86%E5%85%89%E6%89%93%E5%8D%B0%E6%9C%BA%E7%BB%B4%E4%BF%AE%E6%89%8B%E5%86%8C/"/>
    <url>2020/04/18/LJ%E7%90%86%E5%85%89%E6%89%93%E5%8D%B0%E6%9C%BA%E7%BB%B4%E4%BF%AE%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="理光打印机基本操作"><a href="#理光打印机基本操作" class="headerlink" title="理光打印机基本操作"></a>理光打印机基本操作</h1><h2 id="进入维修模式"><a href="#进入维修模式" class="headerlink" title="进入维修模式"></a>进入维修模式</h2><p>1.点击 <strong>重置</strong>按钮 </p><p>2.输入<strong>806182C</strong>(C要按住不放)</p><h2 id="刷卡器基本配置"><a href="#刷卡器基本配置" class="headerlink" title="刷卡器基本配置"></a>刷卡器基本配置</h2><p><img src="https://i.loli.net/2020/04/11/kuAOWXxKiBIpwUr.jpg" srcset="/img/loading.gif" alt="RicoohConfig.jpg"></p><p>纯数字 为进入<strong>维修模式后</strong>，需要更改的代码值</p><h2 id="清除内存"><a href="#清除内存" class="headerlink" title="清除内存"></a>清除内存</h2><p><strong>清楚内存前，需要记住原打印机网络地址（可用手机拍照）！！！</strong></p><p>1.进入维修模式</p><p>2.输入代码 <strong>5-801-00</strong></p><h2 id="打印机出现黑线"><a href="#打印机出现黑线" class="headerlink" title="打印机出现黑线"></a>打印机出现黑线</h2><p>1.更换充电辊 或 更换刮板</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux(五)：SSH免密登录</title>
    <link href="undefined2020/03/09/Linux-5-%E5%AE%89%E8%A3%85SSH/"/>
    <url>2020/03/09/Linux-5-%E5%AE%89%E8%A3%85SSH/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h1><p><strong>SSH(Secure Shell)</strong>是一种<strong>网络协议</strong>，用于计算机之间的<strong>加密登录</strong>。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p><p>想进一步了解的话可以，参考阮一峰老师的<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">博客</a></p><h2 id="一-配置Hosts"><a href="#一-配置Hosts" class="headerlink" title="一.配置Hosts"></a>一.配置Hosts</h2><p>配置你的hosts，不配置会导致ssh登录无效</p><pre><code class="bash">$ sudo vim /etc/hosts</code></pre><p>添加服务器所对应的IP和主机名</p><p><img src="https://i.loli.net/2020/03/09/6zhtRGrVs2laPAT.png" srcset="/img/loading.gif" alt="ssh-hosts.png"></p><h2 id="二-生成密钥"><a href="#二-生成密钥" class="headerlink" title="二.生成密钥"></a>二.生成密钥</h2><p>在<strong>hadoop000</strong>用命令生成<strong>SSH密钥</strong>，接着，按三下回车就好</p><pre><code class="bash">$ ssh-keygen -t rsa</code></pre><p><img src="https://i.loli.net/2020/03/06/lGMkCYLPdoV8yni.png" srcset="/img/loading.gif" alt="ssh-keygen"></p><p>然后，进入<strong>.ssh</strong>文件夹，查看目录，会发现多了两个文件，<strong>id_rsa(私钥)</strong>和<strong>id_rsa.pub(公钥)</strong></p><p><img src="https://i.loli.net/2020/03/06/rl7G81CyxpAumYg.png" srcset="/img/loading.gif" alt=""></p><h2 id="三-公钥登录"><a href="#三-公钥登录" class="headerlink" title="三.公钥登录"></a>三.公钥登录</h2><p>用<strong>ssh-copy-id</strong>命令，将<strong>hadoop000</strong>生成的公钥传到<strong>hadoop8</strong>，@前面是目标用户名，@后面为目标服务器IP，如果用户名不同，还是要密码登录</p><pre><code class="bash">$ ssh-copy-id hadoop@192.168.1.8</code></pre><p><strong>hadoop8</strong>的<strong>.ssh</strong>目录会多出来一个<strong>authorized_keys</strong>的文件，然后设置一下权限</p><pre><code class="bash">$ chmod 600 authorized_keys #如果不设置，可能会因为权限问题不能免密登录</code></pre><p>用<strong>hadoop000</strong>ssh登录<strong>hadoop8</strong>，登录的时候不用输入密码了，<strong>SSH配置成功</strong></p><p><img src="https://i.loli.net/2020/03/09/ZSRxlpLfwJuk8Kt.png" srcset="/img/loading.gif" alt="ssh-success.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(四):安装JAVA环境(jdk1.8)</title>
    <link href="undefined2020/03/04/Linux-4-%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/"/>
    <url>2020/03/04/Linux-4-%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-JAVA环境-jdk1-8"><a href="#安装-JAVA环境-jdk1-8" class="headerlink" title="安装 JAVA环境(jdk1.8)"></a>安装 JAVA环境(jdk1.8)</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p><strong>下载jdk1.8</strong></p><p>进入Oracle官网下载页面</p><p><img src="https://i.loli.net/2020/03/04/SIwEvHBJ56gzUtr.png" srcset="/img/loading.gif" alt=""></p><p>如果你下的很慢的话，我给你贴心的准备好了我下好了的    <a href="https://pan.baidu.com/s/1_toI_omzKLYwinFo60BpRA" target="_blank" rel="noopener">点我(提取码：guk0)</a></p><p>下好后可以用<strong>WinScp</strong>或<strong>XFTP</strong>自行上传到自己的服务器目录，如果不会的话，我建议你<strong>百度</strong></p><p>我这里将JDK传到了我的<strong>~/software</strong>目录，我建议你们也可以自己建个software目录专门存放要安装的软件包</p><p><img src="https://i.loli.net/2020/03/04/Twra1WCDXcSZkoN.png" srcset="/img/loading.gif" alt="linux"></p><p>这里可以看到我的<strong>software</strong>目录已经有我上传的jdk了</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p><strong>解压</strong>已经传到服务器的jdk文件</p><p>使用<strong>tar</strong>命令将software目录下的jdk解压到app目录</p><pre><code class="bash">tar -zvxf jdk-8u241-linux-x64.tar.gz  -C ~/app</code></pre><p>解压完进入查看一下</p><pre><code class="bash">[hadoop@hadoop000 ~]$ lsapp   Desktop    Downloads  maven_resp  Pictures  README.txt  software   t.txtdata  Documents  lib        Music       Public    shell       Templates  Videos[hadoop@hadoop000 ~]$ cd app[hadoop@hadoop000 app]$ lshadoop-2.6.0-cdh5.15.1  hive-1.1.0-cdh5.15.1  jdk1.8.0_241  tmp[hadoop@hadoop000 app]$ cd jdk1.8.0_241/[hadoop@hadoop000 jdk1.8.0_241]$ pwd/home/hadoop/app/jdk1.8.0_241</code></pre><p>可以看到我的jdk已经解压到app目录了，路径是<strong>/home/hadoop/app/jdk1.8.0_241</strong></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p><strong>配置环境变量</strong></p><p>编辑环境变量文件</p><pre><code class="bash">vim ~/.bash_profile</code></pre><p>找个地方，添加下面这段</p><pre><code class="bash">export JAVA_HOME=/home/hadoop/app/jdk1.8.0_241export PATH=$JAVA_HOME/bin:$PATH</code></pre><p><img src="https://i.loli.net/2020/03/04/FZrAkKRNPIL71XT.png" srcset="/img/loading.gif" alt=""></p><p>使环境变量生效</p><pre><code class="bash"> source ~/.bash_profile</code></pre><p>使用java命令，验证生效情况</p><pre><code class="bash">java</code></pre><p><img src="https://i.loli.net/2020/03/04/P3ncaNAEDtiUqrb.png" srcset="/img/loading.gif" alt=""></p><p>出现，如图所示情况，安装成功😀</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在配置环境变量的时候，一般网上都是</p><pre><code class="bash">vim /etc/profile</code></pre><p>而我的是<strong>.bash_profile</strong>，这两者的区别再去</p><p><strong>/etc/profile：</strong>这个配置文件是对<strong>所有系统用户</strong>生效</p><p><strong>.bash_profile：</strong>这个配置文件是对<strong>当前登录</strong>生效</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弹钢琴吗？用键盘的那种(一):The Game is On</title>
    <link href="undefined2020/02/28/Pinao-1-TheGameIsOn/"/>
    <url>2020/02/28/Pinao-1-TheGameIsOn/</url>
    
    <content type="html"><![CDATA[<h1 id="The-game-is-on钢琴曲谱"><a href="#The-game-is-on钢琴曲谱" class="headerlink" title="The game is on钢琴曲谱"></a>The game is on钢琴曲谱</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> <strong>本曲用于在<a href="https://www.autopiano.cn/" target="_blank" rel="noopener">自由钢琴</a>弹奏，帮助同志们在闲暇之余，接受艺术的洗礼，陶冶自己的情操，升华自己的灵魂😀</strong></p><p><img src="https://i.loli.net/2020/02/28/v54Pb8eZOM21NCf.png" srcset="/img/loading.gif" alt="AutoPiano.png"></p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><div><table>        <thead>            <tr>                <th >描述</th>                <th >语法</th>            </tr>        </thead>        <tbody>            <tr>                <td>白键</td>                <td >0-9 a-z (小写字母)</td>            </tr>            <tr>                <td>黑键，需要按住<strong>Shift键</strong></td>                <td ><strong>!@$%^*(</strong> 和 A-Z (大写字母)</td>            </tr>            <tr>                <td><strong>同时</strong>按下abc三个键</td>                <td >[abc]</td>            </tr>            <tr>                <td>以一定间隔按下a b c 三个键</td>                <td >a b c</td>            </tr>            <tr>                <td>延音 ~</td>                <td >a~ 或 a~~</td>            </tr>        </tbody>    </table></div><p><strong>t   o   o   I   o   O   o   t   s   t   s   s   a   s   d   s   D</strong></p><p><strong>h   s   s   d   D   d   D   d   s   g   s   s   d   D   D   g   d   d   D   s   s   d   a   O   o   s</strong></p><p><strong>v   l   l   z   Z   z   Z   z   l   c   l   l   z   Z   Z   c   z   z   Z   l   l   z   k   H   h   l</strong></p><h2 id="音名"><a href="#音名" class="headerlink" title="音名"></a>音名</h2><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1177649593,2842240244&fm=173&app=25&f=JPEG?w=640&h=167&s=A7947C22C8A8C50142D565DE0000C0B2" srcset="/img/loading.gif" alt=""></p><p><strong>^：</strong>代表黑键</p><p><strong>C4    G4    G4    F4^    G4    G4^    G4    C4    C5    C4    C5    C5    B4    C5    D5    C5    D5^</strong></p><p><strong>G5    C5    C5    D5    D5^    D5    D5^    D5    C5    F5    C5    C5    D5    D5^    D5^    F5    D5    D5    D5^    C5    C5    D5    B4    G4^    G4    C5</strong></p><p><strong>G6    C6    C6    D6    D6^    D6    D6^    D6    C6    F6    C6    C6    D6    D6^    D6^    F6    D6    D6    D6^    C6    C6    D6    B5    G5^    G5    C6</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>钢琴</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop(一):初识Hadoop</title>
    <link href="undefined2020/02/26/Hadoop-1-%E5%88%9D%E5%A7%8BHadoop/"/>
    <url>2020/02/26/Hadoop-1-%E5%88%9D%E5%A7%8BHadoop/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Hadoop"><a href="#初识Hadoop" class="headerlink" title="初识Hadoop"></a>初识Hadoop</h1><h2 id="Hadoop名字怎么来的？"><a href="#Hadoop名字怎么来的？" class="headerlink" title="Hadoop名字怎么来的？"></a>Hadoop名字怎么来的？</h2><p>Hadoop之父的名字叫<strong>Doug Cutting</strong>，就是下图那位儒雅随和的男人，他不仅仅是Hadoop的创始人，同时也是<strong>nutch(一个开源Java实现的搜索引擎)</strong>的创始人，而Hadoop这个名字<strong>其实是他孩子一个玩具的名字</strong>，就是下图那个那个小黄象，这个玩具也是<strong>Hadoop的Logo</strong>，小朋友们起名字确实很厉害，类似的还有大名鼎鼎<strong>Google</strong>这个名字就是<strong>由美国数学家 Edward Kasner 九岁的侄子 Milton Sirotta 发明的</strong></p><p><img src="https://i.loli.net/2020/02/26/76KYFDEqloJRUmV.jpg" srcset="/img/loading.gif" alt="hadoopFather"></p><h2 id="Hadoop是干什么的？"><a href="#Hadoop是干什么的？" class="headerlink" title="Hadoop是干什么的？"></a>Hadoop是干什么的？</h2><p><img src="https://i.loli.net/2020/02/26/mwleA3x86Pdc7bY.png" srcset="/img/loading.gif" alt="Hadoop-introduce.png"></p><p>这是Hadoop的官网(<a href="https://hadoop.apache.org/" target="_blank" rel="noopener">https://hadoop.apache.org/</a>) 的介绍，简单来说，Hadoop就是一个开源的，可靠的，可扩展的分布式计算框架，它用来对海量数据进行<strong>分布式存储和计算</strong>，就是传说中的<strong>大数据</strong>。</p><h2 id="Hadoop有几个模块"><a href="#Hadoop有几个模块" class="headerlink" title="Hadoop有几个模块?"></a>Hadoop有几个模块?</h2><p><img src="https://i.loli.net/2020/02/26/AqvmgxCGbW81RSi.png" srcset="/img/loading.gif" alt="hadoop-modules.png"></p><ul><li><p><strong>Hadoop Common：</strong> 公共的模块，用来给其他模块调用</p></li><li><p><strong>Hadoop分布式存储系统(HDFS)：</strong>提供对应用程序数据的<strong>高吞吐量</strong>访问的分布式文件系统</p></li><li><p><strong>Hadoop YARN：</strong>一个用来作业调度和群集资源管理的<strong>框架</strong>。</p></li><li><p><strong>Hadoop MapReduce：</strong>基于<strong>YARN</strong>可在很多机器上进行<strong>分布式并行计算</strong></p></li><li><p><strong>Hadoop Ozone：</strong>Hadoop的对象存储</p></li><li><p><strong>Hadoop Submarine：</strong>一个Hadoop的<strong>机器学习</strong>框架</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node安装与配置</title>
    <link href="undefined2020/01/23/Node%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>2020/01/23/Node%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Node环境搭建"><a href="#Node环境搭建" class="headerlink" title="Node环境搭建"></a>Node环境搭建</h1><p>简单的说，node就是一个前端程序员看后端不爽，用<strong>JavaScript</strong>写出来的后端。</p><p><strong>下载地址：</strong></p><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a></p><p><img src="https://i.loli.net/2020/01/29/4iNUcfwOZk7qVxQ.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-20-25.png"></p><p>选择自己系统对应的版本下载，然后一键安装，小白看教程：</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></p><p>打开<strong>CMD</strong>，输入<strong>node -v</strong>和<strong>npm -v</strong>，如果显示了版本，则安装完成</p><p><img src="https://i.loli.net/2020/01/29/GU8cF6YdOTePqiL.png" srcset="/img/loading.gif" alt="Photo_2020-01-21_18-50-27.png"></p><h2 id="Node配置"><a href="#Node配置" class="headerlink" title="Node配置"></a>Node配置</h2><p>这里node的配置主要是配置<strong>npm</strong>，简单来说<strong>npm</strong>就相当于<strong>Java中的Maven</strong>，或者说它就是前端开发中的Maven</p><h3 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>node也和Maven一样有着默认镜像，默认镜像访问速度较慢，下面是它原本的镜像</p><pre><code class="bash">npm get registry //获取镜像</code></pre><p><img src="http://ww1.sinaimg.cn/large/007SzKTZgy1gb6amm6wulj30d6065jr9.jpg" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-37-07.png"></p><p>我们要将默认镜像切换为淘宝镜像</p><pre><code class="bash">npm config set registry https://registry.npm.taobao.org        //设置镜像</code></pre><p><img src="https://i.loli.net/2020/01/29/iGoHaKL9YCnPFBM.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-40-17.png"></p><p>上面已经切换成淘宝镜像了，如果想国内镜像和国外镜像一起使用的也可以，通过<strong>cnpm</strong></p><pre><code class="bash">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>这样以后使用，<strong>cnpm i <model_name></strong>就是使用国内镜像，<strong>npm i <model_name></strong>就是使用默认镜像</p><h3 id="npm仓库地址"><a href="#npm仓库地址" class="headerlink" title="npm仓库地址"></a>npm仓库地址</h3><p>npm库拉到本地后，会默认存在你的<strong>C盘</strong>，占C盘空间</p><h4 id="1-新建node-global和node-cache"><a href="#1-新建node-global和node-cache" class="headerlink" title="1.新建node_global和node_cache"></a>1.新建node_global和node_cache</h4><ul><li><strong>node_globa</strong>为npm的全局安装路径，类似maven仓库地址</li><li><strong>node_cache</strong>为缓存路径</li></ul><p>一般我习惯在我的nodejs安装目录下新建，如果你想放别的地方也可以</p><p><img src="https://i.loli.net/2020/01/29/mzUkENQTleAZpu3.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-53-07.png"></p><h4 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h4><p>打开<strong>此电脑=&gt;属性=&gt;高级系统设置=&gt;环境变量</strong></p><p><img src="https://i.loli.net/2020/01/29/FKaE7kC2lp6UxRz.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_10-59-38.png"></p><p>新建系统变量<strong>NODE_PATH</strong>，填写新建的<strong>node_global</strong>的路径</p><p><img src="https://i.loli.net/2020/01/29/e1gQ7RcKPo3SYfE.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-04-54.png"></p><p>然后配置<strong>用户变量-&gt;Path</strong>，加入<strong>%NODE_PATH%</strong></p><p><img src="https://i.loli.net/2020/01/29/ET2BuDXCVY8Oh5S.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-10-35.png"></p><h4 id="3-设置全局"><a href="#3-设置全局" class="headerlink" title="3.设置全局"></a>3.设置全局</h4><p>打开cmd，输入命令：</p><pre><code class="bash">npm config set prefix &quot;F:\Node\node_global&quot;npm config set cache &quot;F:\Node\node_cache&quot;</code></pre><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><p>我们全局安装一下常用的<strong>express</strong>模块试一下</p><pre><code class="bash">npm install express -g</code></pre><p><img src="https://i.loli.net/2020/01/29/muvyVU29Jz5HjOA.png" srcset="/img/loading.gif" alt="Photo_2020-01-23_11-17-10.png"></p><p>可以看到在node_global文件夹出现了express，配置完成😀</p>]]></content>
    
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA压力测试:Jmeter初体验</title>
    <link href="undefined2019/12/19/JAVA%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-1/"/>
    <url>2019/12/19/JAVA%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmeter初体验"><a href="#Jmeter初体验" class="headerlink" title="Jmeter初体验"></a>Jmeter初体验</h1><p>校园博客的项目需要上线，所以要进行压力测试，于是就开始了测试初体验</p><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/</a></p><p><img src="https://i.loli.net/2019/12/19/OYQVBDkJ3idjo6m.png" srcset="/img/loading.gif" alt=""></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="1-配置JMETER-HOME"><a href="#1-配置JMETER-HOME" class="headerlink" title="1.配置JMETER_HOME"></a>1.配置JMETER_HOME</h4><p>打开系统变量新建变量<strong>JMETER_HOME</strong>,然后，填写你的jmeter安装目录</p><p><img src="https://i.loli.net/2019/12/19/j5RmbN3ey4KQVud.png" srcset="/img/loading.gif" alt=""></p><h4 id="2-配置path"><a href="#2-配置path" class="headerlink" title="2.配置path"></a>2.配置path</h4><p>在path变量加入 <strong>%JMETER_HOME%\bin</strong></p><h3 id="确认安装"><a href="#确认安装" class="headerlink" title="确认安装"></a>确认安装</h3><p>随便找个地方，打开cmd，输入 <strong>jmeter</strong>能打开jmeter就算配置完成</p><p><img src="https://i.loli.net/2019/12/19/V8kNMaqAKmZyUYb.png" srcset="/img/loading.gif" alt=""></p><h2 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h2><p>进入jmeter的bin目录下,打开 jmeter.bat文件</p><p><img src="https://i.loli.net/2019/12/19/ctOTD7Y4BpvxVLF.png" srcset="/img/loading.gif" alt=""></p><p>打开<strong>Options</strong>，选择<strong>Choose Language</strong>中的<strong>Chinese(Simplified)</strong>可以切换成简体中文</p><p><img src="https://i.loli.net/2019/12/19/cQ1MkaDhzIrmufl.png" srcset="/img/loading.gif" alt=""></p><p>右键一个test plan 点击 添加 线程 线程组</p><p><img src="https://i.loli.net/2019/12/19/S8c1LB5ZpjWVeFR.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2019/12/19/UGqAbLdYHrzmOha.png" srcset="/img/loading.gif" alt=""></p><p><strong>线程数：</strong>虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个线程数。</p><p><strong>Ramp-Up Period(in seconds)准备时长：</strong>设置的虚拟用户数需要多长时间全部启动。如果线程数为10，准备时长为2，那么需要2秒钟启动10个线程，也就是每秒钟启动5个线程。</p><p><strong>循环次数：</strong>每个线程发送请求的次数。如果线程数为10，循环次数为100，那么每个线程发送100次请求。总请求数为10*100=1000 。如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。</p><p>将要测试的接口的信息填上，这里我的接口是：<strong><a href="http://localhsot:10002/api/post" target="_blank" rel="noopener">http://localhsot:10002/api/post</a></strong></p><p><img src="https://i.loli.net/2019/12/19/QD1mWkcZn6lBX3N.png" srcset="/img/loading.gif" alt=""></p><p>随后，将测试计划保存到一个目录</p><p><img src="https://i.loli.net/2019/12/19/gue35fmwZFjTvHt.png" srcset="/img/loading.gif" alt=""></p><p>接着到执行计划保存目录，用命令执行测试计划</p><p>非GUI并生成html报告：</p><p>jmeter -n -t <test JMX file> -l <test log file> -e -o <Path to output folder></p><p>非GUI并生成html报告：</p><pre><code class="bash">E:\apache-jmeter\TestPlan&gt;jmeter -n -t &quot;post all.jmx&quot; -l read.jtl -e -o E:\apache-jmeter\TestPlan\Report</code></pre><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110258.png" srcset="/img/loading.gif" alt=""></p><p>然后就会jmeter会帮你生成报告文件</p><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110444.png" srcset="/img/loading.gif" alt=""></p><p>随后打开Repost下index.html查看结果</p><p><img src="https://raw.githubusercontent.com/GrowthLj/markdown_upload/master/img/20191219110541.png" srcset="/img/loading.gif" alt=""></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>由于我是在pc上测的，内存和cpu都比不上服务器，这样的测试结果不准确</p></li><li><p>命令生成报告的时候，比如我的是Report目录，如果这个目录<strong>不为空</strong>，JMeter就会报错</p></li><li><p>重新打开JMeter，它的设置会恢复默认，重新变成英文的了¿¿¿  </p></li><li><p>重新打开JMeter执行计划也不见了，可以导入之前的执行计划。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>压力测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点(二):集合</title>
    <link href="undefined2019/12/04/JAVA%E5%9F%BA%E7%A1%80-2-%E9%9B%86%E5%90%88/"/>
    <url>2019/12/04/JAVA%E5%9F%BA%E7%A1%80-2-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-集合"><a href="#JAVA-集合" class="headerlink" title="JAVA 集合"></a>JAVA 集合</h1><p>JAVA的集合类被定义在Java.util包中，主要有4种集合，分别为<strong>List、Queue、Set、Map</strong>，每种集合的具体分类如图：</p><p><img src="https://i.loli.net/2019/12/04/XAyEQ4fDdN35sCz.png" srcset="/img/loading.gif" alt=""></p><h2 id="List：加强版数组"><a href="#List：加强版数组" class="headerlink" title="List：加强版数组"></a>List：加强版数组</h2><h3 id="1-ArrayList：基于数组实现，增删慢，查询快，线程不安全"><a href="#1-ArrayList：基于数组实现，增删慢，查询快，线程不安全" class="headerlink" title="1.ArrayList：基于数组实现，增删慢，查询快，线程不安全"></a>1.ArrayList：基于数组实现，增删慢，查询快，线程不安全</h3><p>因为是基于数组实现，所以当需要<strong>插入</strong>或<strong>删除</strong>一个节点时，需要移动其他所有节点，代价较高，因此，ArrayList不适合更新操作。</p><p>ArrayList不需要定义数组长度，在默认长度（默认长度为10）不够时，ArrayList会创建一个新的更大数组并将已有的数据复制到新数组中，通过调用一个native方法<strong>System.arraycopy</strong>实现</p><h3 id="2-Vector-基于数组实现，增删慢，查询快，线程安全"><a href="#2-Vector-基于数组实现，增删慢，查询快，线程安全" class="headerlink" title="2.Vector: 基于数组实现，增删慢，查询快，线程安全"></a>2.Vector: 基于数组实现，增删慢，查询快，线程安全</h3><p>Vector的数据结构与ArrayList一样，都是基于数组实现，不同的是Vector支持线程同步，以保证多线程环境下数据的一致性，但由于频繁的加锁和释放锁操作，Vector整体独写效率比ArrayList低。</p><h3 id="3-LinkedList-基于双向链表实现，增删快，查询慢，线程不安全"><a href="#3-LinkedList-基于双向链表实现，增删快，查询慢，线程不安全" class="headerlink" title="3.LinkedList: 基于双向链表实现，增删快，查询慢，线程不安全"></a>3.LinkedList: 基于双向链表实现，增删快，查询慢，线程不安全</h3><p>LinkedList采用双向链表结构存储元素，在对LinkedList插入和删除时，只需要将上一个节点的指针指向要操作的节点即可，数据改动较小，因此更新效率高。但对LinkedList进行访问时，需要从链表头部一直遍历到需要访问的节点，因此查询的效率很慢。除此之外，LinkedList还定义了用于<strong>操作链表头和尾部</strong>的元素，因此有时可以当作堆栈、队列和双向队列使用。</p><h2 id="Map-键值对"><a href="#Map-键值对" class="headerlink" title="Map: 键值对"></a>Map: 键值对</h2><h3 id="1-HashMap：数组-链表实现，线程不安全"><a href="#1-HashMap：数组-链表实现，线程不安全" class="headerlink" title="1.HashMap：数组 + 链表实现，线程不安全"></a>1.HashMap：数组 + 链表实现，线程不安全</h3><p>HashMap基于键的HashCode值唯一标识一条数据，同时<strong>基于HashCode进行数据的存取</strong>，因此可以快速更新和查找数据，但遍历顺序不保证一样，HashMap的key和valu允许为null.</p><p>HashMap不是线程安全的，如果同一时刻多个线程操作HashMap会导致数据不一致，使HashMap造成环形链表。如果需要线程安全可以使用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或使用ConcurrentHashMap.</p><p>HashMap的结构如图所示，</p><p><img src="https://i.loli.net/2019/12/10/aEwPsmeXMQuCp2y.png" srcset="/img/loading.gif" alt=""></p><p>其内部是一个<strong>数组</strong>，数组中的<strong>每个元素都是一个单向链表</strong>，链表中的每个元素都是Node类实例，Node类包含4个属性：<strong>key、value、hash和用于指向下一个元素的next</strong></p><pre><code class="JAVA">    /**     * 初始化数组容量，默认为16，可以扩容，扩容后数组大小为当前的两倍，该值使用为2^n次方     */    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16    transient Node&lt;K,V&gt;[] table;    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;    }</code></pre><p>HashMap在查找数据时，根据HashMap的Hash值可以快速定位到数组下标，但是我们在找到数组下标后需要对链表进行遍历直到找到需要的数据，时间复杂度为O(n).</p><p>为了减小俩表遍历的开销，Java8对HashMap进行了优化，将数据结构修改为<strong>数组+链表或红黑树</strong>。在链表中元素<strong>超过8</strong>后，HashMap会将链表转为红黑树结构以提高查询效率，因此其时间复杂度为O(logN)。如图</p><p><img src="https://i.loli.net/2019/12/10/voKyxMumfpiF6zt.png" srcset="/img/loading.gif" alt=""></p><pre><code class="JAVA">    /**     * 使用树的阈值，如果链表长度超过此值，则链表转为红黑树     */    static final int TREEIFY_THRESHOLD = 8;    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {        TreeNode&lt;K,V&gt; parent;          TreeNode&lt;K,V&gt; left;        TreeNode&lt;K,V&gt; right;        TreeNode&lt;K,V&gt; prev;        boolean red;    }</code></pre><h3 id="2-ConcurrentHashMap：分段锁实现，线程安全"><a href="#2-ConcurrentHashMap：分段锁实现，线程安全" class="headerlink" title="2.ConcurrentHashMap：分段锁实现，线程安全"></a>2.ConcurrentHashMap：分段锁实现，线程安全</h3><p>在<strong>JDK1.7</strong>中，ConcurrentHashMap采用<strong>分段锁</strong>的思想实现并发操作，因此是线程安全的。ConcurrentHashMap由多个Segment组成（Segment的数量也是锁的并发度），每个Segment都继承自<strong>ReentrantLock</strong>并单独加锁，所以每次进行加锁操作时锁住的都是一个Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。如图，所示：</p><p><img src="https://i.loli.net/2019/12/11/JrMAnaPEy461kmj.png" srcset="/img/loading.gif" alt=""></p><p>在<strong>JDK1.8</strong>中，抛弃了Segment分段锁机制，利用<strong>CAS+Synchronized</strong>，数据结构采用<strong>数组 + 链表 + 红黑树</strong></p><h3 id="3-HashTable：线程安全"><a href="#3-HashTable：线程安全" class="headerlink" title="3.HashTable：线程安全"></a>3.HashTable：线程安全</h3><p>HashTable是遗留类，很多映射的常用功能都与HashMap类似，不同的是它继承自<strong>Dictionary</strong>类，并且是线程安全的，同一时刻只能有一个线程能写HashTable，并发性不如ConcurrentHashMap。</p><h3 id="4-TreeMap：基于二叉树数据结构"><a href="#4-TreeMap：基于二叉树数据结构" class="headerlink" title="4.TreeMap：基于二叉树数据结构"></a>4.TreeMap：基于二叉树数据结构</h3><p>TreeMap基于二叉树数据结构存储数据，同时实现了<strong>SortedMap</strong>接口，以保障元素的顺序存储，默认按键值的升序排序，也可以自定义排序比较器。</p><p>TreeMap常用于实现排序的映射列表。在使用TreeMap时其key必须实现Comparable接口或采用自定义比较器，否则会抛出java.lang.ClassCastException异常</p><h3 id="5-LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序"><a href="#5-LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序" class="headerlink" title="5.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序"></a>5.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序</h3><p>LinkedHashMap是HashMap的子类，其内部使用链表保存元素的插入顺序，在通过Iterator遍历LinkedHashMap时，会按照元素的插入顺序访问元素。</p><h2 id="Set：不可重复"><a href="#Set：不可重复" class="headerlink" title="Set：不可重复"></a>Set：不可重复</h2><p>Set的核心是<strong>独一无二</strong>的性质，适用于存储无序且值不相等的元素。</p><h3 id="1-HashSet：HashMap实现，无序"><a href="#1-HashSet：HashMap实现，无序" class="headerlink" title="1.HashSet：HashMap实现，无序"></a>1.HashSet：HashMap实现，无序</h3><p><strong>HashSet是基于HashMap实现的</strong>，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个<strong>private static final Object PRESENT = new Object();。</strong>HashSet跟HashMap一样，都是存放链表的数组。</p><pre><code class="java">public class HashSet&lt;E&gt;    extends AbstractSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable{    static final long serialVersionUID = -5024744406713321676L;    private transient HashMap&lt;E,Object&gt; map;    private static final Object PRESENT = new Object();    public HashSet() {        map = new HashMap&lt;&gt;();    }    public boolean add(E e) {        return map.put(e, PRESENT)==null;    }    ....}</code></pre><h3 id="2-TreeSet：二叉树实现"><a href="#2-TreeSet：二叉树实现" class="headerlink" title="2.TreeSet：二叉树实现"></a>2.TreeSet：二叉树实现</h3><p><strong>TreeSet是基于TreeMap实现</strong>，和HashSet类似</p><pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{    private transient NavigableMap&lt;E,Object&gt; m;    private static final Object PRESENT = new Object();    public TreeSet() {        this(new TreeMap&lt;E,Object&gt;());    }    public boolean add(E e) {        return m.put(e, PRESENT)==null;    }}</code></pre><p>可以自定义排序方法</p><pre><code class="java">Set&lt;String&gt; treeSet = new TreeSet(Comparator.comparing(String::length));</code></pre><p>如果是自定义数据类型，必须<strong>实现Comparable接口</strong>。并<strong>覆写compareTo函数</strong>。</p><h3 id="3-LinkedHashSet：数据插入顺序和遍历数据一样"><a href="#3-LinkedHashSet：数据插入顺序和遍历数据一样" class="headerlink" title="3.LinkedHashSet：数据插入顺序和遍历数据一样"></a>3.LinkedHashSet：数据插入顺序和遍历数据一样</h3><p> <strong>LinkedHashSet继承了HashSet</strong>，所有的操作都与HashSet一样，底层使用<strong>LinkedHashMap存储元素</strong></p><pre><code class="java">public class LinkedHashSet&lt;E&gt;    extends HashSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {     public LinkedHashSet(int initialCapacity, float loadFactor) {        super(initialCapacity, loadFactor, true);    }     public LinkedHashSet(int initialCapacity) {        super(initialCapacity, .75f, true);    }     public LinkedHashSet() {        super(16, .75f, true);    }}</code></pre><p>这里神奇的是，LinkedHashSet创建对象却是在HashSet里</p><pre><code class="java">    HashSet(int initialCapacity, float loadFactor, boolean dummy) {        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);    }</code></pre><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>用的不是很多，所以不详细说明</p><ul><li><p><strong>ArrayBlockingQueue：</strong>基于数组数据结构实现的有界阻塞队列</p></li><li><p><strong>LinkedBlockingQueue：</strong>基于链表数据结构实现的有界阻塞队列</p></li><li><p><strong>PriorityBlockingQueue：</strong>支持优先级排序的无界队列</p></li><li><p><strong>DelayQueue：</strong>支持延迟操作的无界阻塞队列</p></li><li><p><strong>SynchronousQueue：</strong>用于线程同步的阻塞队列</p></li><li><p><strong>LinkedTransferQueue：</strong>基于链表数据结构实现的无界阻塞队列</p></li><li><p><strong>LinkedBlockingDeque：</strong>基于链表数据结构实现的双向阻塞队列</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点(一):JVM</title>
    <link href="undefined2019/12/02/JAVA%E5%9F%BA%E7%A1%80-1-JVM/"/>
    <url>2019/12/02/JAVA%E5%9F%BA%E7%A1%80-1-JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><strong>JVM(Java Virtual Machine)</strong>是用于运行Java字节码的虚拟机包括一个<strong>类加载器子系统（Class Loader SubSystem）</strong>、<strong>运行时数据区（Runtime Data Area）</strong>、执行引擎和<strong>本地接口库（Native Interface Library）</strong>。本地接口库通过调用<strong>本地方法库（Native Method Library）</strong>与操作系统交互，如图：</p><p><img src="https://i.loli.net/2019/12/02/ikFsOqoJ98NbCKe.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>Java堆（Heap）：</strong>是Java虚拟机所管理的内存最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的<strong>唯一目的就是存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</li><li><strong>方法区（Method Area）：</strong>与java堆一样，是各个线程共享的内存区域，它用于<strong>存储</strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li><strong>程序计数器（Program Counter Register）：</strong>是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li><li><strong>JVM栈（JVM Stacks）：</strong>与程序计数器一样，<strong>java虚拟机栈（Java Virtual Machine Stacks）</strong>也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被创建的时候都会创建一个<strong>栈帧(Stack Frame)</strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。</li><li><strong>本地方法栈（Native Method Stacks）：</strong>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行JAVA方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题(一)</title>
    <link href="undefined2019/11/17/%E9%9D%A2%E8%AF%95-1/"/>
    <url>2019/11/17/%E9%9D%A2%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>我一个好朋友，在BOSS上投简历收到了面试邀请，这是他面试回来说的面试题，我整理了一下并查了答案，以免自己去面试的时候不会</p><p>下面是面试问题：</p><blockquote><p>1.JAVA数据类型以及所占字节</p><p>2.手写三个单例模式</p><p>3.ArrayList与LinkList区别</p><p>4.HashSet原理</p><p>5.常用的Linux命令</p><p>6.JAVA反射机制</p><p>7.手画一个线程状态图</p><p>8.手写三个线程交替打印ABC</p><p>9.什么是TCP三次握手，为什么四次挥手断开连接，为什么</p><p>10.手写一个冒泡算法</p><p>11.SpringMVC是怎么运行的？</p><p>12.索引类型及作用</p></blockquote><p>下面面试答案：</p><h2 id="1-JAVA数据类型及所占字节"><a href="#1-JAVA数据类型及所占字节" class="headerlink" title="1.JAVA数据类型及所占字节"></a>1.JAVA数据类型及所占字节</h2><pre><code class="java">整型:  byte--1字节    short--2字节    int--4字节    long--8字节浮点型:  float--4字节    double--8字节字符型:  char--2字节布尔型:  boolean--1字节</code></pre><h2 id="2-单例模式的三种实现"><a href="#2-单例模式的三种实现" class="headerlink" title="2.单例模式的三种实现"></a>2.单例模式的三种实现</h2><pre><code class="JAVA">/*** 1.懒汉式,默认不实例化，什么时候用什么时候创建对象* 优点：懒加载启动快，资源占用小，使用时才实例化，无锁。* 缺点：非线程安全。*/public class Singleton{    private static Singleton instance;    private Singleton(){}    public static synchronized Singleton getInstance(){        if(instance == null){            instance = new Singleton();        }        return instance;    }}/** 2.饿汉式，类加载的时候就实例化* 优点：饿汉模式天生是线程安全的，使用时没有延迟。* 缺点：启动时即创建实例，启动慢，有可能造成资源浪费。*/public class Singleton{    private Singleton(){}    private static final Singleton singleton = new Singleton();    public static Singleton getInstance(){        return singleton;    }}/** 3.静态内部类* 优点：将懒加载和线程安全完美结合的一种方式（无锁）。（推荐）*/public class Singleton{    private Singleton(){}    public static final Singleton getInstance(){        return SingletonHolder.INSTANCE;    }    private static class SingletonHolder{        private static final Singleton INSTANCE = new Singleton();    }}</code></pre><h2 id="3-ArrayList和LinkList的区别"><a href="#3-ArrayList和LinkList的区别" class="headerlink" title="3.ArrayList和LinkList的区别"></a>3.ArrayList和LinkList的区别</h2><pre><code class="JAVA">ArrayList是基于数组实现的，查询快，更新慢。LinkList是基于链表实现的，插入，删除快，查询慢</code></pre><h2 id="4-HashSet原理"><a href="#4-HashSet原理" class="headerlink" title="4.HashSet原理"></a>4.HashSet原理</h2><pre><code class="JAVA">HashSet实现Set接口，由一个HashMap实例支持。不保证set的迭代顺序;不保证舒徐恒久不变。此类允许使用nullprivate transient HashMap&lt;E,Object&gt; map;  //map集合，HashSet存放元素的容器private static final Object PRESENT = new Object(); //map，中键对应的value值</code></pre><h2 id="5-常用的Linux命令"><a href="#5-常用的Linux命令" class="headerlink" title="5.常用的Linux命令"></a>5.常用的Linux命令</h2><pre><code class="bash">ll ls cd pwd mkdir touch rm -rf grep less</code></pre><h2 id="6-JAVA反射机制"><a href="#6-JAVA反射机制" class="headerlink" title="6.JAVA反射机制"></a>6.JAVA反射机制</h2><pre><code class="java">java反射机制是指在运行时，对任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取对象信息及动态调用方法的功能称为JAVA反射机制。通过Class.forName(包名.类名)获得类对象Class，通过操作Class对象达到运行时操作类</code></pre><h2 id="7-手画一个线程状态图"><a href="#7-手画一个线程状态图" class="headerlink" title="7.手画一个线程状态图"></a>7.手画一个线程状态图</h2><pre><code class="java">线程有五个状态：新建态(new)、就绪态(runnable)、运行态(running)、阻塞态(blocked)、死亡态(dead)</code></pre><p><img src="https://images2017.cnblogs.com/blog/432513/201712/432513-20171214160438717-1661848063.png" srcset="/img/loading.gif" alt=""></p><h2 id="8-手写三个线程交替打印ABC"><a href="#8-手写三个线程交替打印ABC" class="headerlink" title="8.手写三个线程交替打印ABC"></a>8.手写三个线程交替打印ABC</h2><pre><code class="java">/*** 主要考察的使是线程间的同步唤醒操作，线程的逻辑执行步骤为ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA.......* 要控制线程的执行顺序,就要确定唤醒和等待的顺序,一种解题思路是一个线程持有两个对象锁.一个对象锁是pret即前* * 一个对象所持有的锁,还有一个是自身锁.*/public class SysaAbcThread implements Runnable{    private Object pret;     //上一个锁    private Object self;     //自身锁    private String sout;     //要输出的内容    public SysaAbcThread(Object pret, Object self, String sout) {        super();        this.pret = pret;        this.self = self;        this.sout = sout;    }    @Override    public void run() {        while(true){            synchronized (pret) {     //获取 pret锁                synchronized (self) { //获取 self锁                    System.out.println(sout);                    self.notifyAll();  //释放self锁，唤醒其他线程竞争self锁                }                try {                    pret.wait();      //释放pret锁，休眠等待唤醒                } catch (InterruptedException e) {}            }        }    }    public static void main(String[] args) throws InterruptedException {        Object a = new Object();        Object b = new Object();        Object c = new Object();        SysaAbcThread aThread = new SysaAbcThread(c, a, &quot;A&quot;);        SysaAbcThread bThread = new SysaAbcThread(a, b, &quot;B&quot;);        SysaAbcThread cThread = new SysaAbcThread(b, c, &quot;C&quot;);        /**         * 如果不sleep，则启动顺序会乱         */        new Thread(aThread).start();        Thread.sleep(100);        new Thread(bThread).start();        Thread.sleep(100);        new Thread(cThread).start();        Thread.sleep(100);    }}</code></pre><h2 id="9-什么是TCP三次握手，为什么四次挥手断开连接"><a href="#9-什么是TCP三次握手，为什么四次挥手断开连接" class="headerlink" title="9.什么是TCP三次握手，为什么四次挥手断开连接"></a>9.什么是TCP三次握手，为什么四次挥手断开连接</h2><p><strong>三此握手(Three-way Handshake)是指建立一个TCP连接时</strong>，需要客户端和服务端总共发送三个包。</p><p>三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><ul><li><p>第一次握手(SYN=1,seq=x):   <strong>客户端=&gt;服务端</strong></p><p>客户端发送一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口，以及初始序号X，保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕客户端进入<strong>SYN_SEND</strong>状态。</p></li></ul><ul><li><p>第二次握手(SYN=1,ACK=1,seq=y,ACKnum=x+1):  <strong>服务端=&gt;客户端</strong></p><p>服务器发回确认包(ACK)应答。即SYN标志和ACK标志位均为1。服务器端选择自己的ISN序列号，放到Seq域里，同时将确认序号(Acknowledgement Number)设置为客户端的ISN加1，即X+1。发送完毕后，服务器端进入<strong>SYN_RCVD</strong>状态。</p></li></ul><ul><li><p>第三次握手(ACK=1,ACKnum=y+1)：<strong>客户端=&gt;服务端</strong></p><p>客户端再次发回确认包(ACK)，SYN标志位为0，ACK标志为1，并把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写INS的+1</p><p>发送完毕后，客户端进入<strong>ESTABLISHED</strong>状态，当服务器端接收到这个包时，也进入<strong>ESTABLISHED</strong>状态，TCP握手结束。</p></li></ul><p><strong>四次挥手(Four-Way Wavehand)是指断开一个TCP连接时</strong>，需要客户端和服务端发送四个包确认连接断开。客户端或服务端均可主动发起挥手动作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<strong>FIN_WAIT_1</strong>状态</p></li></ul><ul><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端发送的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<strong>CLOSE_WAIT</strong>状态，客户端接收到这个确认包之后，进入<strong>FIN_WAIT_2</strong>状态，等待服务器关闭连接。</p></li></ul><ul><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN设置为1.</p><p>发送完毕后，服务端进入<strong>LAST_ACK</strong>状态，等待来自客户端的最后一个ACK。</p></li></ul><ul><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收来自服务器端的关闭请求，发送一个确认包，并进入<strong>TIME_WAIT</strong>状态，等待可能出现的要求重传的ACK包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入<strong>CLOSED</strong>状态。</p><p>客户端等待了某个固定时间（两个最大生命周期，2MSL，2 Maximum Segment Lifetime）之后，没收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<strong>CLOSED</strong>状态</p></li></ul><h2 id="10-手写一个冒泡算法"><a href="#10-手写一个冒泡算法" class="headerlink" title="10.手写一个冒泡算法"></a>10.手写一个冒泡算法</h2><pre><code class="java">    public int[] sort(int[] arr){        int length = arr.length;        for(int i=0;i&lt;length;i++){            for(int j=i;j&lt;length;j++){                if(arr[i] &gt; arr[j]){                    int temp = arr[j];                    arr[j] = arr[i];                    arr[i] = temp;                }            }        }        return arr;    }   </code></pre><h2 id="11-SpringMVC是怎么运行的？"><a href="#11-SpringMVC是怎么运行的？" class="headerlink" title="11.SpringMVC是怎么运行的？"></a>11.SpringMVC是怎么运行的？</h2><p>（1）用户发送请求至前端控制器<strong>DispatcherServlet</strong></p><p>（2）<strong>DispatcherServlet</strong>收到请求后，调用<strong>HandlerMapping</strong>处理映射器，请求获取Handle;</p><p>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有就生成)，一并返回给<strong>DispatcherServlet</strong></p><p>（4）<strong>DispatcherServlet</strong>调用<strong>HandlerAdapter</strong>处理适配器</p><p>（5）<strong>HandlerAdapter</strong>经过适配调用具体处理器(Handler，也叫后端控制器)；</p><p>（6）<strong>Handler</strong>执行完成返回<strong>ModelAndView</strong>；</p><p>（7）<strong>HandlerAdapter</strong>将Handler执行结果<strong>ModelAndView</strong>返回给<strong>DispatcherServlet</strong></p><p>（8）<strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>传给<strong>ViewResolver</strong>视图解析器进行解析</p><p>（9）<strong>ViewResolver</strong>解析后返回具体的<strong>view</strong></p><p>（10）<strong>DispatcherServlet</strong>对<strong>View</strong>进行渲染试图</p><p>（11）<strong>DispatcherServlet</strong>响应用户</p><p><img src="https://img-blog.csdn.net/20180708224853769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt=""></p><h2 id="12-索引类型及作用"><a href="#12-索引类型及作用" class="headerlink" title="12.索引类型及作用"></a>12.索引类型及作用</h2><ol><li><strong>主键索引：</strong>数据记录里面不能有null，数据内容不能重复，在一张表里不能有多个主键索引</li><li><strong>普通索引：</strong>使用字段关键字建立索引，提高查询质量</li><li><strong>唯一索引：</strong>字段数据是唯一的，可以为null，在一张表里，是可以添加多个唯一索引</li><li><strong>全文索引：</strong>对文本内容进行分词，进行搜索</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(三):实用指令</title>
    <link href="undefined2019/11/02/Linux-3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>2019/11/02/Linux-3-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h3 id="Linux系统的运行级别"><a href="#Linux系统的运行级别" class="headerlink" title="Linux系统的运行级别"></a>Linux系统的运行级别</h3><pre><code class="bash">0:关机  1:单用户(找回丢失密码)2:多用户无网络服务3:多用户有网络服务4:保留5:图形界面6:重启命令 init [0||num]系统运行级别配置文件： /etc/inittab</code></pre><p><img src="https://i.loli.net/2019/10/09/R9DjLcyuoXtGkFI.png" srcset="/img/loading.gif" alt=""></p><h5 id="如何修改已经忘记密码"><a href="#如何修改已经忘记密码" class="headerlink" title="如何修改已经忘记密码"></a>如何修改已经忘记密码</h5><p><img src="https://i.loli.net/2019/10/09/rcNa2gMqbYtGkLe.png" srcset="/img/loading.gif" alt=""></p><p>首先，在进入启动页面的时候按<strong>e</strong>键，然后会进入下面这个页面</p><p><img src="https://i.loli.net/2019/10/09/g4j2GNFevKImaQn.png" srcset="/img/loading.gif" alt=""></p><p>将光标移动到下图那一行</p><p><img src="https://i.loli.net/2019/10/09/8k4sZdrAvRgEVno.png" srcset="/img/loading.gif" alt=""></p><p>在行尾添加 <strong>init=/bin/sh</strong>,</p><p><img src="https://i.loli.net/2019/10/09/LhdHGqYpItZvMAK.png" srcset="/img/loading.gif" alt=""></p><p>添加完，按<strong>Ctrl + X</strong>执行，即可进入单用户模式</p><p><img src="https://i.loli.net/2019/10/09/JBKHTxbWS5dGYIy.png" srcset="/img/loading.gif" alt=""></p><p>然后，就可以<strong>修改密码</strong>了</p><p><img src="https://i.loli.net/2019/10/09/4wbFxDeHrJGKBm8.png" srcset="/img/loading.gif" alt=""></p><p>这里可以看见会字符不可见，你需要输入<strong>LANG=en</strong>，才能让字符可见</p><p><img src="https://i.loli.net/2019/10/09/trswoihHCvd7JGu.png" srcset="/img/loading.gif" alt=""></p><p>最后,执行<strong>exec /sbin/init</strong>即可退出单用户模式</p><p><img src="https://i.loli.net/2019/10/09/gvKOq5eVhc3FwXd.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当你对某个指令不收悉的时候，就可以使用帮助指令</p><h4 id="获得帮助信息"><a href="#获得帮助信息" class="headerlink" title="获得帮助信息"></a>获得帮助信息</h4><ul><li><p>语法</p><pre><code class="bash">man [命令||配置文件]</code></pre></li><li><p>命令演示</p><pre><code class="bash">[root@localhost ~]# man ls</code></pre><p>输入命令按<strong>回车</strong>,</p><p><img src="https://i.loli.net/2019/10/10/AnB285ODQH9RKLf.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>ls加-a可以<strong>显示隐藏文件</strong></p><p><img src="https://i.loli.net/2019/10/10/mNfp1tGsEaX38D9.png" srcset="/img/loading.gif" alt=""></p><p>ls加-l可以以<strong>另外的列表形式显示</strong></p><p><img src="https://i.loli.net/2019/10/10/eOT45wiHoPu6gys.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">[root@localhost home]# ls -a.  ..  crg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><p>命令选项不光可以单个用，也可以连用，</p><pre><code class="bash">[root@localhost home]# ls -la总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy</code></pre><h4 id="help-命令"><a href="#help-命令" class="headerlink" title="help 命令"></a>help 命令</h4><ul><li><p>基本语法</p><pre><code class="bash">help 命令</code></pre></li><li><p>实例演示</p><pre><code class="bash">[root@localhost home]# help cdcd: cd [-L|[-P [-e]]] [dir]    Change the shell working directory.    Change the current directory to DIR.  The default DIR is the value of the    HOME shell variable.    The variable CDPATH defines the search path for the directory containing    DIR.  Alternative directory names in CDPATH are separated by a colon (:).    A null directory name is the same as the current directory.  If DIR begins    with a slash (/), then CDPATH is not used.    If the directory is not found, and the shell option `cdable_vars&#39; is set,    the word is assumed to be  a variable name.  If that variable has a value,    its value is used for DIR.    Options:        -L      force symbolic links to be followed        -P      use the physical directory structure without following symbolic        links        -e      if the -P option is supplied, and the current working directory        cannot be determined successfully, exit with a non-zero status    The default is to follow symbolic links, as if `-L&#39; were specified.    Exit Status:    Returns 0 if the directory is changed, and if $PWD is set successfully when    -P is used; non-zero otherwise.[root@localhost home]# </code></pre></li></ul><hr><h3 id="查看目录类命令"><a href="#查看目录类命令" class="headerlink" title="查看目录类命令"></a>查看目录类命令</h3><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p><strong>这个命令用来显示当前工作的绝对路径</strong></p><pre><code class="bash">[root@localhost ~]# pwd/root[root@localhost ~]# </code></pre><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p><strong>该命令用来查看当前目录的所有内容</strong></p><pre><code class="bash">ls [选项] [目录||文件]</code></pre><pre><code class="bash">[root@localhost home]# lscrg  qy[root@localhost home]# ls -l总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# ls -al总用量 0drwxr-xr-x.  4 root root  27 9月  29 09:45 .dr-xr-xr-x. 17 root root 224 9月   4 20:36 ..drwx------.  2 crg  dw    62 9月  29 09:45 crgdrwx------.  2 qy   qy    83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p><strong>用于切换目录</strong></p><pre><code class="bash">cd [参数](指定目录)</code></pre><pre><code class="bash">[root@localhost /]# ll总用量 16lrwxrwxrwx.   1 root root    7 9月   4 20:33 bin -&gt; usr/bindr-xr-xr-x.   5 root root 4096 9月   4 20:37 bootdrwxr-xr-x.  20 root root 3220 10月 10 09:01 devdrwxr-xr-x.  75 root root 8192 10月 10 09:01 etcdrwxr-xr-x.   4 root root   27 9月  29 09:45 homelrwxrwxrwx.   1 root root    7 9月   4 20:33 lib -&gt; usr/liblrwxrwxrwx.   1 root root    9 9月   4 20:33 lib64 -&gt; usr/lib64drwxr-xr-x.   2 root root    6 4月  11 2018 mediadrwxr-xr-x.   2 root root    6 4月  11 2018 mntdrwxr-xr-x.   2 root root    6 4月  11 2018 optdr-xr-xr-x. 135 root root    0 10月 10 09:01 procdr-xr-x---.   2 root root  151 10月  9 14:26 rootdrwxr-xr-x.  24 root root  720 10月 10 09:01 runlrwxrwxrwx.   1 root root    8 9月   4 20:33 sbin -&gt; usr/sbindrwxr-xr-x.   2 root root    6 4月  11 2018 srvdr-xr-xr-x.  13 root root    0 10月 10 09:01 sysdrwxrwxrwt.  12 root root  265 10月 10 10:09 tmpdrwxr-xr-x.  13 root root  144 9月  28 15:29 usrdrwxr-xr-x.  19 root root  267 9月   4 20:37 var[root@localhost /]# cd /home[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><hr><h3 id="操作文件类命令"><a href="#操作文件类命令" class="headerlink" title="操作文件类命令"></a>操作文件类命令</h3><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p><strong>用于创建目录</strong></p><pre><code class="bash">mkdir [选项] 要创建的目录-p : 创建多级目录</code></pre><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# mkdir dog[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mkdir /home/animal/catmkdir: 无法创建目录&quot;/home/animal/cat&quot;: 没有那个文件或目录[root@localhost home]# mkdir -p /home/animal/cat[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:46 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost animal]# cd animal[root@localhost animal]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 10 13:46 cat</code></pre><h4 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h4><p><strong>rmdir命令用于删除空目录</strong></p><pre><code class="bash">rmdir [目录]</code></pre><p>删除dog目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwxr-xr-x. 2 root root  6 10月 10 13:42 dogdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir dog[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 13:48 animaldrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rmdir animalrmdir: 删除 &quot;animal&quot; 失败: 目录非空</code></pre><p>如果要删除一个<strong>非空的目录</strong>需要用<strong>rm -rf</strong>命令</p><pre><code class="bash">[root@localhost home]# rm -rf animal[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p><strong>创建一个空的文件</strong></p><p>接下来，创建一个Hello.txt</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# touch hello.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:14 hello.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# </code></pre><p><strong>touch</strong>也可以创建多个文件</p><pre><code class="bash">[root@localhost home]# touch sb.txt dl.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crg-rw-r--r--. 1 root root  0 10月 10 15:15 dl.txtdrwx------. 2 qy   qy   83 9月  28 14:53 qy-rw-r--r--. 1 root root  0 10月 10 15:15 sb.txt[root@localhost home]# </code></pre><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p><strong>拷贝文件到指定目录</strong></p><pre><code class="bash">cp [选项] [待拷贝文件] [拷贝目标]-r: 拷贝整个文件夹</code></pre><p>接下来,将a.txt<strong>拷贝到</strong>aaa目录</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:23 aaa-rw-r--r--. 1 root root  0 10月 10 15:23 a.txtdrwxr-xr-x. 2 root root  6 10月 10 15:25 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# cp a.txt aaa[root@localhost home]# cd aaa[root@localhost aaa]# ll总用量 0-rw-r--r--. 1 root root 0 10月 10 15:23 a.txt[root@localhost aaa]# </code></pre><p>如果，要将aaa目录拷贝到bbb目录下，</p><pre><code class="bash">[root@localhost home]# cp aaa bbbcp: 略过目录&quot;aaa&quot;[root@localhost home]# </code></pre><p>会提示一个错误，略过目录”aaa”，这个时候就需要加入选项<strong>-r</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbb[root@localhost home]# cd bbb[root@localhost bbb]# ll总用量 0drwxr-xr-x. 2 root root 19 10月 10 15:29 aaa[root@localhost bbb]# </code></pre><p>如果，再复制一次，会提示要不要覆盖，如果默认要覆盖可以使用<strong>\cp</strong></p><pre><code class="bash">[root@localhost home]# cp -r aaa bbbcp：是否覆盖&quot;bbb/aaa/a.txt&quot;？ y[root@localhost home]# /cp -r aaa bbb-bash: /cp: 没有那个文件或目录[root@localhost home]# \cp -r aaa bbb[root@localhost home]# </code></pre><p>这里注意是<strong>\cp</strong>，不仔细的话容易弄反</p><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p><strong>用于移除文件或目录</strong></p><pre><code class="bash">rm [文件||目录]-r : 递归删除整个文件夹-f : 强制删除不提示</code></pre><p>删除<strong>/home/a.txt</strong>，</p><pre><code class="bash">[root@localhost home]# rm a.txtrm：是否删除普通空文件 &quot;a.txt&quot;？y[root@localhost home]# </code></pre><p>删除<strong>/home/aaa</strong></p><pre><code class="bash">[root@localhost aaa]# rm /home/aaarm: 无法删除&quot;/home/aaa&quot;: 是一个目录[root@localhost aaa]# rm -r /home/aaarm：是否进入目录&quot;/home/aaa&quot;? yrm：是否删除普通空文件 &quot;/home/aaa/a.txt&quot;？yrm：是否删除目录 &quot;/home/aaa&quot;？y[root@localhost aaa]# </code></pre><p>这里可以看出如果要删除目录，要对目录下所有文件确认是否删除，非常麻烦，所以，如果不想提示，加上<strong>-f</strong>命令强制删除<strong>/home/bbb</strong>，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 3 root root 17 10月 10 15:29 bbbdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# rm -rf /home/bbb/[root@localhost home]# ll总用量 0drwx------. 2 crg dw 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# </code></pre><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p><strong>mv指令用于移动文件或重命名</strong></p><pre><code class="bash">重命名 ： mv oldNameFile newNameFile移动 ： mv /oldPath /newPath</code></pre><p>接下来，我们将<strong>/home/aaa.txt</strong>重命名为<strong>sz.txt</strong></p><pre><code class="bash">[root@localhost home]# ll总用量 0drwxr-xr-x. 2 root root  6 10月 11 09:26 aaa.txtdrwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qy[root@localhost home]# mv aaa.txt sz.txt[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# </code></pre><p>然后，将sz.txt移动到<strong>crg</strong>目录里面，</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg  dw   62 9月  29 09:45 crgdrwx------. 2 qy   qy   83 9月  28 14:53 qydrwxr-xr-x. 2 root root  6 10月 11 09:26 sz.txt[root@localhost home]# mv /home/sz.txt/ /home/crg/[root@localhost home]# ll总用量 0drwx------. 3 crg dw 76 10月 11 09:34 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy[root@localhost home]# cd crg[root@localhost crg]# ll总用量 0drwxr-xr-x. 2 root root 6 10月 11 09:26 sz.txt[root@localhost crg]# </code></pre><hr><h3 id="查看文件类命令"><a href="#查看文件类命令" class="headerlink" title="查看文件类命令"></a>查看文件类命令</h3><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p><strong>用来查看文件内容，以只读的方式</strong></p><pre><code class="bash">cat [选项] [目标文件]</code></pre><p>用cat的方式查看<strong>/etc/profile</strong></p><pre><code class="bash">[root@localhost ~]# cat /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091155.png" srcset="/img/loading.gif" alt=""></p><p>这里可以查看，但没有行号，我们给他设定一个行号,加上选项<strong>-n</strong></p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091429.png" srcset="/img/loading.gif" alt=""></p><p>但是，cat命令每次都会直接跑到文件末尾，让你看不清，所以，一般还会给和<strong>| more</strong>连用，</p><pre><code class="bash">[root@localhost ~]# cat -n /etc/profile | more</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012091759.png" srcset="/img/loading.gif" alt=""></p><p><strong>| more</strong>用来<strong>分页显示</strong>，按<strong>空格</strong>看下一页</p><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p><strong>more命令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件内容</strong></p><p>用<strong>more命令</strong>查看文件,</p><pre><code class="bash">[root@localhost ~]# more /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095423.png" srcset="/img/loading.gif" alt=""></p><p>快捷键,</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012095608.png" srcset="/img/loading.gif" alt=""></p><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><p><strong>less命令和more命令类似，但它功能更强大，不会将整个文件加载完后再显示，比more效率更高，一般用于查看大型文件</strong></p><p>接下来，用less命令查看<strong>/etc/services</strong></p><pre><code class="bash">[root@localhost etc]# less /etc/services</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/1570846827372.png" srcset="/img/loading.gif" alt=""></p><p>可以看出，它只加载了这么多就不往下显示了，</p><p><strong>less快捷键：</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191012102549.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(二):用户管理</title>
    <link href="undefined2019/11/02/Linux-2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>2019/11/02/Linux-2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h3 id="Linux用户基本介绍"><a href="#Linux用户基本介绍" class="headerlink" title="Linux用户基本介绍"></a>Linux用户基本介绍</h3><blockquote><p> Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 </p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录</p></blockquote><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927160228.png" srcset="/img/loading.gif" alt=""></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code class="bash">useradd [选项] 用户名</code></pre><p>接下来，添加一个用户 dl</p><pre><code class="bash">[root@localhost ~]# useradd dl</code></pre><p>可能界面看不出什么效果，其实系统已经创建了一个叫<strong>dl的用户</strong>并创建了同名的<strong>组</strong>和 <strong>/home/dl目录</strong></p><pre><code class="bash">[root@localhost /]# cd /home/[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 lj lj 83 9月   5 09:02 lj</code></pre><p>如果你不想创建在<strong>home目录</strong>下，你还可以将<strong>用户</strong>创建在其他目录，这里我想将用户创建在<strong>/home/sb/#</strong></p><pre><code class="bash">[root@localhost home]# mkdir sb[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwxr-xr-x. 2 root root  6 9月  28 08:54 sb</code></pre><p>此时目录已经创建完毕，接着输入命令：</p><pre><code class="bash">[root@localhost home]# useradd -d /home/sb/ qyuseradd：警告：此主目录已经存在。不从 skel 目录里向其中复制任何文件。正在创建信箱文件: 文件已存在</code></pre><p>然后，给用户<strong>dl</strong>和<strong>qy</strong>设置密码:</p><pre><code class="bash">[root@localhost home]# passwd dl更改用户 dl 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@localhost home]# passwd qy更改用户 qy 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 过于简单化/系统化重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。</code></pre><p>这里我两个用户密码都设置为：<strong>12345678</strong>,就算系统提示为通过字典检查，只要你无视它，接着输入<strong>密码</strong>，还是会设置成功，然后我使用<strong>SmarTTY</strong> 登录用户 <strong>dl</strong>和<strong>qy</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928094858.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190928102011.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><h5 id="1-删除用户，但保留目录"><a href="#1-删除用户，但保留目录" class="headerlink" title="1.删除用户，但保留目录"></a>1.删除用户，但保留目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  27 16:08 dldrwx------. 2 qy qy 62 9月  28 13:48 qy[root@localhost home]# userdel qy //执行删除[root@localhost home]# ll总用量 0drwx------. 2 dl   dl   62 9月  27 16:08 dldrwx------. 2 1002 1002 62 9月  28 13:48 qy</code></pre><h5 id="2-删除用户和目录"><a href="#2-删除用户和目录" class="headerlink" title="2.删除用户和目录"></a>2.删除用户和目录</h5><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 dl dl 62 9月  28 14:19 dldrwx------. 2 qy qy 62 9月  28 14:19 qy[root@localhost home]# userdel -r dl  //执行删除[root@localhost home]# ll总用量 0drwx------. 2 qy qy 62 9月  28 14:19 qy</code></pre><hr><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><pre><code>id  [用户名]</code></pre><pre><code class="bash">[root@localhost home]# id rootuid=0(root) gid=0(root) 组=0(root)[root@localhost home]# id qyuid=1001(qy) gid=1001(qy) 组=1001(qy)[root@localhost home]# </code></pre><hr><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre><code>su [用户名]</code></pre><pre><code class="bash">[root@localhost ~]# su qy[qy@localhost root]$ su root密码：[root@localhost ~]# </code></pre><p>这是一种从<strong>低权限用户</strong>切换到<strong>高权限用户</strong>的方法，</p><p>还有一种</p><pre><code class="bash">[qy@localhost /]$ exitexit[root@localhost ~]# </code></pre><p>直接<strong>exit</strong>，这样就避免了输密码</p><hr><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h5 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h5><pre><code class="bash">groupadd [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupadd dang[root@localhost ~]# </code></pre><h5 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h5><pre><code class="bash">groupdel [组名]</code></pre><pre><code class="bash">[root@localhost ~]# groupdel dang[root@localhost ~]# </code></pre><h5 id="增加用户直接加上组"><a href="#增加用户直接加上组" class="headerlink" title="增加用户直接加上组"></a>增加用户直接加上组</h5><pre><code class="bash">useradd -g [组] [用户名]</code></pre><p>增加一个用户crg，分组到zf</p><pre><code class="bash">[root@localhost ~]# useradd -g zf crguseradd：“zf”组不存在[root@localhost ~]# groupadd zf[root@localhost ~]# useradd -g zf crg[root@localhost ~]# id crguid=1002(crg) gid=1002(zf) 组=1002(zf)</code></pre><p>这里我原本以为直接用命令，系统会自动帮我建组，看来我想多了😭，必须你自己建个组，然后再分组</p><pre><code class="bash">[root@localhost home]# ll总用量 0drwx------. 2 crg zf 62 9月  29 09:45 crgdrwx------. 2 qy  qy 83 9月  28 14:53 qy</code></pre><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><pre><code class="bash">usermod -g [用户组] [用户名]</code></pre><pre><code class="bash">[root@localhost home]# groupadd dw[root@localhost home]# usermod -g dw crg[root@localhost home]# id crguid=1002(crg) gid=1003(dw) 组=1003(dw)</code></pre><p>这样我们就把<strong>crg</strong>从<strong>zf组</strong>调到<strong>dw组</strong></p><hr><h3 id="用户的配置文件"><a href="#用户的配置文件" class="headerlink" title="用户的配置文件"></a>用户的配置文件</h3><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190929105530.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009095520.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">crg: 用户名x: 加密的密码 真正的密码在 shadow文件里1002: 用户id1003: 组id/home/crg: 用户所在home目录/bin/bash：对应的shell</code></pre><h5 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009100032.png" srcset="/img/loading.gif" alt=""></p><h5 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h5><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20191009140544.png" srcset="/img/loading.gif" alt=""></p><pre><code class="bash">dw: 组名1003: 组id</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(一):vim与vi</title>
    <link href="undefined2019/11/02/Linux-1-vim%E4%B8%8Evi/"/>
    <url>2019/11/02/Linux-1-vim%E4%B8%8Evi/</url>
    
    <content type="html"><![CDATA[<h1 id="vim与vi"><a href="#vim与vi" class="headerlink" title="vim与vi"></a>vim与vi</h1><h3 id="什么是vim？"><a href="#什么是vim？" class="headerlink" title="什么是vim？"></a>什么是vim？</h3><blockquote><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p></blockquote><h3 id="vi和vim的三种模式转化图如下"><a href="#vi和vim的三种模式转化图如下" class="headerlink" title="vi和vim的三种模式转化图如下:"></a>vi和vim的三种模式转化图如下:</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtbszrfgj30ik0a4whj.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><pre><code class="linux">[root@localhost ~]# ll总用量 4-rw-------. 1 root root 1416 9月   4 20:36 anaconda-ks.cfg[root@localhost ~]# </code></pre><p>可以看出我没有Hello.java文件</p><p>使用命令</p><pre><code class="linux">[root@localhost ~]# vim Hello.java</code></pre><p>随后进入一般模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1dy0j2nj30lf0tb3yo.jpg" srcset="/img/loading.gif" alt=""></p><p>此时还不能编辑，如果要编辑 需要按  <strong>Insert</strong> 或 按 <strong>i</strong> ，进入编辑模式</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1gyfv0bj30ho0a5q2v.jpg" srcset="/img/loading.gif" alt=""></p><p>当左下角出现<strong>插入</strong>的时候才能开始编辑，如图</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1jlvw60j30ib04i3ys.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，如果要保存</p><blockquote><p><strong>Shift + ; + wq</strong>(wq是 写入(wirte)并退出(queit))</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7d1mqs047j303p03gmwz.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>:q!</strong>是不保存退出</p><h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dtnweqdbj30q90f0gr2.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="1-拷贝"><a href="#1-拷贝" class="headerlink" title="1. 拷贝"></a>1. 拷贝</h5><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dubycqkbj307105zt8s.jpg" srcset="/img/loading.gif" alt=""></p><p>首先插入一些字符,随后按<strong>ESC</strong>进入<strong>命令模式</strong>，选定一行按<strong>yy</strong>，之后按<strong>p</strong>，按一次<strong>P</strong>，粘贴一次</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7duf1mpdzj3063071dft.jpg" srcset="/img/loading.gif" alt=""></p><p>随后，将<strong>光标</strong>移动到第一行，并按<strong>5yy</strong>（Linux的所有数字都是大键盘上的，小键盘的数字会产生其他效果）,随后按<strong>P</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dulepza4j308b02g744.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dumcpa0bj30530bajrl.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h5><p>和拷贝语法类似，我们用<strong>5dd</strong>删除五行</p><p>效果如下:</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dusx4k7gj304406gdfu.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h5><p>进入<strong>命令模式</strong>，输入<strong>/ + [关键字] + 回车</strong>即可查询,按<strong>N</strong>查找下一个</p><p>效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv1j36y1j303w01ft8h.jpg" srcset="/img/loading.gif" alt=""></p><p>这里要注意Linux的查找字符是<strong>严格区分大小写</strong>的，我这里小写的sbdl就没匹配到😭</p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dv20n1r3j305u0ag74k.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="4-设置行号"><a href="#4-设置行号" class="headerlink" title="4.设置行号"></a>4.设置行号</h5><p>例行进入<strong>命令模式</strong>，输入 <strong>:set nu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvy3a60vj304o02e3yc.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvygdj6ej307008xq37.jpg" srcset="/img/loading.gif" alt=""></p><p>取消，行号<strong>:set nonu</strong></p><p><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzjksdfj305r023t8i.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://ws1.sinaimg.cn/large/007SzKTZgy1g7dvzwzaktj3049081jrj.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="5-行尾和行首"><a href="#5-行尾和行首" class="headerlink" title="5.行尾和行首"></a>5.行尾和行首</h5><pre><code>[root@localhost ~]# vim /etc/profile</code></pre><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>Shift + g</strong>，进入行尾</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145504.png" srcset="/img/loading.gif" alt=""></p><p>按下<strong>gg</strong>回到行首</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145402.png" srcset="/img/loading.gif" alt=""></p><h5 id="6-撤消"><a href="#6-撤消" class="headerlink" title="6.撤消"></a>6.撤消</h5><p>在<strong>编辑模式</strong>下乱输字符</p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927145915.png" srcset="/img/loading.gif" alt=""></p><p>随后,按<strong>ESC</strong>进入<strong>正常模式</strong>按<strong>u</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927150026.png" srcset="/img/loading.gif" alt=""></p><h5 id="7-移动光标"><a href="#7-移动光标" class="headerlink" title="7.移动光标"></a>7.移动光标</h5><p>第一步：进入<strong>编辑模式</strong>，设置行号， <strong>:set nu</strong></p><p>第二步：进入<strong>正常模式</strong>，输入你要去的行数  10 + <strong>Shift + g</strong></p><p><img src="https://raw.githubusercontent.com/201500317/markdown_upload/master/img/20190927153646.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/10/30/hello-world/"/>
    <url>2019/10/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>